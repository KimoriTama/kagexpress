// Menus.tjs - メニュー作成関数の定義  此文件是用来设置菜单项的
// Copyright (C)2001-2005, W.Dee and contributors  改変・配布は自由です
/*
function KAGWindow_createMenus()
{
	// この関数は MainWindow クラスのオブジェクトのコンテキスト上で実行されます

	menu.add(this.systemMenu = new KAGMenuItem(this, "系统", 0, "", false));

	systemMenu.add(this.rightClickMenuItem = new KAGMenuItem(this, "隐藏文字框", 0,
		onRightClickMenuItemClick, false));

	systemMenu.add(this.showHistoryMenuItem = new KAGMenuItem(this, "显示履历", 0,
		onShowHistoryMenuItemClick, false));

	systemMenu.add(this.skipToNextStopMenuItem = new KAGMenuItem(this,
		autoRecordPageShowing?"前进到下个选项(&F)":"前进到下个选项(&F)", 0,
		onSkipToNextStopMenuItemClick, false));

	systemMenu.add(this.autoModeMenuItem = new KAGMenuItem(this, "自动模式(&A)", 0,
		onAutoModeMenuItemClick, false));

	systemMenu.add(this.autoModeWaitMenu = new KAGMenuItem(this, "自动模式的等待时间(&D)", 0,
		void, false));

		autoModeWaitMenu.add(this.autoModeFastMenuItem = new KAGMenuItem(this, "短(&1)", 1,
			onAutoModeWaitMenuClick, false));
		autoModeFastMenuItem.wait = autoModePageWaits.fast;
		autoModeFastMenuItem.lwait = autoModeLineWaits.fast;
		autoModeWaitMenu.add(this.autoModeFasterMenuItem = new KAGMenuItem(this, "较短(&2)", 1,
			onAutoModeWaitMenuClick, false));
		autoModeFasterMenuItem.wait = autoModePageWaits.faster;
		autoModeFasterMenuItem.lwait = autoModeLineWaits.faster;
		autoModeWaitMenu.add(this.autoModeMediumMenuItem = new KAGMenuItem(this, "普通(&3)", 1,
			onAutoModeWaitMenuClick, false));
		autoModeMediumMenuItem.wait = autoModePageWaits.medium;
		autoModeMediumMenuItem.lwait = autoModeLineWaits.medium;
		autoModeWaitMenu.add(this.autoModeSlowerMenuItem = new KAGMenuItem(this, "较长(&4)", 1,
			onAutoModeWaitMenuClick, false));
		autoModeSlowerMenuItem.wait = autoModePageWaits.slower;
		autoModeSlowerMenuItem.lwait = autoModeLineWaits.slower;
		autoModeWaitMenu.add(this.autoModeSlowMenuItem = new KAGMenuItem(this, "长(&5)", 1,
			onAutoModeWaitMenuClick, false));
		autoModeSlowMenuItem.wait = autoModePageWaits.slow;
		autoModeSlowMenuItem.lwait = autoModeLineWaits.slow;

	systemMenu.add(this.goBackMenuItem = new KAGMenuItem(this, "后退(&B)", 0,
		onBackStartMenuItemClick, false));

	systemMenu.add(this.goToStartMenuItem = new KAGMenuItem(this, "返回主题画面", 0,
		onGoToStartMenuItemClick, false));

	systemMenu.add(this.exitMenuItem = new KAGMenuItem(this, "结束", 0, onExitMenuItemClick, false));

	menu.add(this.characterMenu = new KAGMenuItem(this, "文字表示", 0, void, false));

		characterMenu.add(this.chSpeedMenu = new KAGMenuItem(this, "表示速度", 0, void, false));

			chSpeedMenu.add(this.chNoWaitMenuItem = new KAGMenuItem(this, "瞬间", 1,
				onChSpeedMenuItemClick, false));
			chNoWaitMenuItem.speed = 0;
			chSpeedMenu.add(this.chFastMenuItem = new KAGMenuItem(this, "高速", 1,
				onChSpeedMenuItemClick, false));
			chFastMenuItem.speed = chSpeeds.fast;
			chSpeedMenu.add(this.chNormalMenuItem = new KAGMenuItem(this, "普通", 1,
				onChSpeedMenuItemClick, false));
			chNormalMenuItem.speed = chSpeeds.normal;
			chSpeedMenu.add(this.chSlowMenuItem = new KAGMenuItem(this, "缓慢", 1,
				onChSpeedMenuItemClick, false));
			chSlowMenuItem.speed = chSpeeds.slow;

			chSpeedMenu.add(new MenuItem(this, "-"));

			chSpeedMenu.add(this.chNonStopToPageBreakItem = new KAGMenuItem(this, "前进到页尾(&P)", 0,
				onChNonStopToPageBreakItemClick, false));

		characterMenu.add(this.ch2ndSpeedMenu = new KAGMenuItem(this, "已读部分(&I)", 0, void, false));

			ch2ndSpeedMenu.add(this.ch2ndNoWaitMenuItem = new KAGMenuItem(this, "不等待(&W)", 1,
				onCh2ndSpeedMenuItemClick, false));
			ch2ndNoWaitMenuItem.speed = 0;
			ch2ndSpeedMenu.add(this.ch2ndFastMenuItem = new KAGMenuItem(this, "高速(&F)", 1,
				onCh2ndSpeedMenuItemClick, false));
			ch2ndFastMenuItem.speed = chSpeeds.fast;
			ch2ndSpeedMenu.add(this.ch2ndNormalMenuItem = new KAGMenuItem(this, "普通(&N)", 1,
				onCh2ndSpeedMenuItemClick, false));
			ch2ndNormalMenuItem.speed = chSpeeds.normal;
			ch2ndSpeedMenu.add(this.ch2ndNoChangeMenuItem = new KAGMenuItem(this, "不改变(&M)", 1,
				onCh2ndSpeedMenuItemClick, false));
			ch2ndNoChangeMenuItem.speed = -1; // 変えない

			ch2ndSpeedMenu.add(new MenuItem(this, "-"));

			ch2ndSpeedMenu.add(this.ch2ndNonStopToPageBreakItem = new KAGMenuItem(this, "前进到页尾(&P)", 0,
				onCh2ndNonStopToPageBreakItemClick, false));

		characterMenu.add(new MenuItem(this, "-"));

		characterMenu.add(this.chAntialiasMenuItem = new KAGMenuItem(this, "反走样(&A)", 0,
			onChAntialiasMenuItemClick, false));

		characterMenu.add(this.chChangeFontMenuItem = new KAGMenuItem(this, "字体(&D) ...", 0,
			onChChangeFontMenuItem, false));

	if(freeSaveDataMode)
	{
		// フリーセーブモードの場合
		menu.add(this.bookMarkMenu = new KAGMenuItem(this, "进度", 0, void, false));
		bookMarkMenu.add(this.restoreMenu = new KAGMenuItem(this, "读取进度...", 0, onRestoreMenuClick, false));
		bookMarkMenu.add(this.storeMenu = new KAGMenuItem(this, "保存进度...", 0, onStoreMenuClick, false));
	}
	else
	{
		menu.add(this.restoreMenu = new KAGMenuItem(this, "读取进度", 0, onRestoreMenuClick, false));
		menu.add(this.storeMenu = new KAGMenuItem(this, "保存进度", 0, onStoreMenuClick, false));
	}

	menu.add(this.displayMenu = new KAGMenuItem(this, "画面(&V)", 0, void, false));

		displayMenu.add(this.windowedMenuItem = new KAGMenuItem(this, "窗口", 1,
			onWindowedMenuItemClick, false));
		displayMenu.add(this.fullScreenMenuItem = new KAGMenuItem(this, "全屏", 1,
			onFullScreenMenuItemClick, false));

	menu.add(this.helpMenu = new KAGMenuItem(this, "帮助", 0, void, false));

		helpMenu.add(this.helpIndexMenuItem = new KAGMenuItem(this, "帮助...", 0,
			onHelpIndexMenuItemClick, false));
		helpMenu.add(this.helpAboutMenuItem = new KAGMenuItem(this, "关于...", 0,
			onHelpAboutMenuItemClick, false));

	menu.add(this.debugMenu = new KAGMenuItem(this, "调试(&D)", 0, void, false));

		debugMenu.add(this.reloadScenarioMenuItem = new KAGMenuItem(this, "重新读取剧本(&R)", 1,
			onReloadScenarioMenuItemClick, false));
		debugMenu.add(this.showConsoleMenuItem = new KAGMenuItem(this, "控制台(&C)\tShift+F4", 1,
			onTest, false)); //onShowConsoleMenuItemClick
		debugMenu.add(this.showControllerMenuItem = new KAGMenuItem(this, "控制器(&S)\tShift+F1", 1,
			onShowContollerMenuItemClick, false));

}
*/
// 常に手前表示
/* todo 加个菜单
addKagHookCallback("onKAGSetupMenu", function(kag) {
	createMenuFromList(kag, kag.displayMenu, [
		"-",
		getSysArgCheckMenuItem("stayOnTopMenuItem", "常に手前に表示(&Y)", "stayontop", true, "no"),
		]);
	updateSysArgMenuItem(kag.stayOnTopMenuItem);*/
//	systemUpdate("topMost");


// ---------------------------------------系统命令行参数相关（systemArgument）------------------------------------------------------------------------

/** 
 * @description: 更改引擎配置文件.cfu
 * @param name	命令行参数名
 * @param value	对应值
 * @return  无
 */
function changeUserConf(name, value)
{
	var cfu, path;
	// cfu のパスを求める
	with (global.kag) {
		if (.readOnlyMode) return;
		path = System.dataPath;
	}
	path += "/" if (path.charAt(path.length-1) != "/");
	with (Storages) path += .chopStorageExt(.extractStorageName(System.exeName));
	path += ".cfu";

	// saveStructプラグインをリンクする
	var ins = [], ss = "savestruct.dll";
	ins.assign(Plugins.getList());
	if (ins.find(ss) < 0) try { Plugins.link(ss); }
	catch { System.inform("設定を保存できませんでした: プラグイン読み込み失敗"); }

	// cfu を読み込む
	if (Storages.isExistentStorage(path)) {
		cfu = [];
		try { cfu.load(path); } catch { cfu = void; }
	}
	// ない場合はデフォルトテキストを設定
	if (cfu === void) cfu = [
		'; ============================================================================',
		'; *DO NOT EDIT* this file unless you are understanding what you are doing.',
		'; FYI:',
		';  Each line consists of NAME="VALUE" pair, VALUE is a series of',
		';  \\xNN, where NN is hexadecimal representation of UNICODE codepoint.',
		';  For example, opt="\\x61\\x62\\x63\\x3042\\x3044\\x3046" means that the',
		';  value of options "opt" is alphabets a, b, and c followed by Japanese',
		';  Hiraganas A, I, and U.',
		';  DO NOT PUT non-escaped value like opt="abc". This doesn\'t work and should',
		';  be like opt="\\x61\\x62\\x63".',
		'; ============================================================================' ];

	// 設定する値を生成
	var update = name + '="';
	for (var i = 0; i < value.length; i++)
		update += "\\x%X".sprintf(# value.charAt(i));
	update += '"';

	// 全行パースして置換
	var find = false;
	for (var i = 0; i < cfu.count; i++) {
		var line = cfu[i];
		if (line.indexOf(name+'="') == 0) {
			// 重複がある場合は最初のみ有効
			cfu[i] = find ? ";" : update;
			find = true;
		}
	}
	// 見つからなかった場合は最後に追加   未找到则追加至末尾
	if (!find) cfu.add(update);

	// セーブする
	try { cfu.save2(path); }
	catch { System.inform(@"設定を保存できませんでした: 書き込み失敗\n${Storages.getLocalName(path)}"); }
}

//----------------------------------------------快捷键相关设置---------------------------------------

//        VK_? : 素の      VK_?		
// "S_" + VK_? : Shift   + VK_?
// "C_" + VK_? : Control + VK_?
// "A_" + VK_? : Alt     + VK_?
// 複数同時指定の場合は SCA_ の順		指定复数个则以SCA的顺序
// * 代表任意移位键都可以
// 如果以感叹号! 开头加上功能键，则直接在这里定义功能键的触发方法，不建议这么做，
// 建议只定义F1-12的功能键的触发功能，以及 none进行的按键拦截
var kagCustomizedKeys = %[
	// ファンクションキー機能一覧		功能键功能一览   @开头代表可以重复按下
	VK_F1 => "about",							// F1: ヘルプ(About)
	VK_F2 => "save",							// F2: セーブ
	VK_F3 => "load",							// F3: ロード
	VK_F4 => "screen",							// F4: 画面切り替え(kag.toggleScreenMenuItem.shortcut に Alt+Enter が指定してあるので上書き時は注意）
	VK_F5 => "backlog", VK_PRIOR => "backlog",	// F5, PageUp: バックログ
	VK_F6 => "auto",							// F6: オート
	VK_F7 => "skip",							// F7: スキップ
	VK_F8 => "option",							// F8: オプション画面
	VK_F11=> "qsave",							// F11: クイックセーブ
	VK_F12=> "qload",							// F12: クイックロード

	// 吉里吉里機能キー抑制一覧		吉里吉里功能键抑制一览
	"*" + #'F' => "none", // 次の選択肢/未読まで進む
	"*" + #'B' => "none", // 前に戻る
	"*" + #'A' => "none", // オート
	"*" + #'S' => "none", // セーブ
	"*" + #'L' => "none", // ロード
	"*" + #'R' => "none", // バックログ
	"S_" + VK_UP => "none", // バックログ

	"A_" + VK_LEFT  => "none", // 前のラベルへ戻る
	"A_" + VK_RIGHT => "none", // 次のラベルへ進む

	"S_" + VK_BACK => "none", // 直前に戻る
	];



// キー入力の横取り		抢占 键盘输入

/** 
 * @description: 用于添加到kag的键盘hook事件，拦截键盘事件,
 * 基本上事件有两种定义法，要么在SystemAction 定义，要么直接在按键映射数组中定义
 * @param key		键盘状态
 * @param shift		移位键状态
 * @return 			是否成功拦截事件
 */
function keyFunc(key, shift)
{
	var tag, mod = "";
	mod += "S" if (shift & ssShift);
	mod += "C" if (shift & ssCtrl);
	mod += "A" if (shift & ssAlt);
	mod += "_" if (mod !== "");

	try {
		tag = kagCustomizedKeys[mod + key];
		tag = kagCustomizedKeys["*" + key] if (tag == "");	// * 代表任意移位键都可以
	} catch {}
	if(isBlank(tag))return false;
	
	if (tag == "none") return true;	// none 直接拦截掉键，禁止触发
	// タグの先頭が @ の場合はリピート有効		标记的开头为@时重复有效
	if (tag.charAt(0) == "@") tag = tag.substr(1);
	else if (shift & ssRepeat) return true;	// 否则 拦截重复事件

	if (typeof SystemAction[tag] != "undefined")		// 存在系统功能中则调用
		return SystemAction[tag](true, tag, key, shift);

	var exp = kagCustomizedKeys["!" + tag];		// 如果直接定义了触发事件   不建议这么做
	switch (typeof exp) {
	case "Object": return exp(key, shift);
	case "String": Scripts.eval(exp); return true;
	}
	
}

//-----------------------------------------------全屏状态相关设置-----------------------------
//--------------下面这些选项虽然涉及到全屏模式更改的方法，但是由于关乎到fsres等选项的更改，只会在菜单这里用到----------------




function setEffect(sender)//TODO 再说吧
{
//	sender.checked = true;
	with (kag) {
		.noeffect = (typeof sender.noeffect != "undefined") ? sender.noeffect : !.noeffect;
		.saveSystemVariables();
	}
	systemUpdate("effectSpeed");
}



// 以下、KAG 用 メニューアイテムクラス
class KAGMenuItem extends MenuItem
{
	// 基本的に MenuItem だが、指定されたイベント、あるいは
	// 文字列を実行する機能を持つ
	var owner;
	var command;
	var _accessible = true;
	var _enabled = true;
	var autoEnable = false;
	var groupTag;

	function KAGMenuItem(window, caption, group, command, autoenable)
	{
		super.MenuItem(window, caption);
		this.owner = window;
		this.command = command;
		this.autoEnable = autoenable;	// 设置自动可用时，每次重置菜单状态都会先将此菜单置为可用，然后再去检查不可用的菜单
		if(group!=0)
		{
			this.group = group;
			this.radio = true;
		}
	}

	function finalize()
	{
		delete owner;
		delete command;
		super.finalize(...);
	}

	// groupTagでグループ番号を再設定  	用groupTag设置group		返回数组，下标为组序号对应groupTag
	function resetChildItemGrouping() {
		var list = this.children, sorted = [];
		var grpMap = %[], grpList = [], grp = 0;
		for (var i = 0; i < list.count; i++) { // 排序到sorted中
			var item = list[i];
			sorted[item.index] = item if (item !== void);
		}
		for (var i = 0; i < sorted.count; i++) {
			if (sorted[i] !== void) with (sorted[i]) {
				if (!.radio || typeof .groupTag === "undefined" || .groupTag === "") continue;
				if (grpMap[.groupTag] === void) {	// 第一次遇到的新组
					grpMap[.groupTag] = .group = ++grp;
					grpList[grp] = .groupTag;
				} else
					.group = grpMap[.groupTag];
				
			}
		}
		return grpList;// 返回所有组
	}

	property enabled  // オーバーライド
	{
		getter { return _enabled; }
		setter(x) { _enabled = x; super.enabled = _accessible && _enabled; }
	}

	property accessible
	{
		getter { return _accessible; }
		setter(x) { _accessible = x; super.enabled = _accessible && _enabled; }
	}

	function click()
	{
		// click 動作
		if (_accessible && _enabled && command !== void) 
		{
			if(typeof command == "String")
			{
				Scripts.eval(command);
			}
			else
			{
				command(this);
			}
		}
	}

	function onClick()
	{
		super.onClick(...);
		click();
	}
}

/*
我的建议是不要用
*/
// ウィンドウのメニュー部分のみshowModalで表示		弹出的菜单框
class PopupMenuWindow extends Window
{
	var owner, exev;
	var autoclose; // 自動で閉じるか 0:閉じない, -1:マウス操作, 1:キー操作
	function PopupMenuWindow(win, ac,show = true) {
		super.Window(null);
		owner = win;
		autoclose = ac;

		borderStyle = bsNone;

		menu.visible = true;
		if (typeof this.registerExEvent == "Object") {
			registerExEvent();
			with (win) {
				.onNonCapMouseEvent = function(rg, ev) {
					if (!isvalid this) return;
					if(rg!=65534)dm("onNonCapMouseEvent rg:"+rg+" ev :"+ev);
					/* if (!isvalid this) return;
					close() if (exev && autoclose < 0 && ev == 0x0200);
					return (rg == global.Window.nchtError);//65534 */
				} incontextof this;
				.enableNCMouseEvent = exev = true;
			}
		} else if (autoclose) {
			this.onKeyDown = function(key, shift) {
				close() if (key == VK_ESCAPE && autoclose); // esc 自动关闭
				return superKeyDown(...);
			} incontextof this;
		}
		// メニュー生成（windowからコピー）
		copyMenu(menu, win.menu.children);

		// 位置を決定
		var x,y,w;
		if (typeof win.getClientRect == "undefined") {
			x = win.left ;
			y = win.top  ;
			w = win.innerWidth ;
		} else {
			var rect = win.getClientRect();
			x = rect.x ;
			y = rect.y ;
			w = rect.w ;
		}
		setPos(x, y);
		setInnerSize(w, 1);

		if (autoclose > 0 && typeof this.setMessageHook == "Object") {
			setMessageHook(true, "SHOWWINDOW");
		}
		showModal() if (show);
	}
	function finalize() { super.finalize(...); }

	function onWindowsMessageHook(msg, wp, lp) {
		setMessageHook(false);
		focusMenuByKey();
	}

	var _closed, _closeExec;// 外部传递给此方法的关闭方法
	function close() {
		if (!isvalid this || _closed) return;
		dm(Scripts.getTraceString());
		if (exev) {
			owner.enableNCMouseEvent = exev = false;
			delete owner.onNonCapMouseEvent;
		}
		_closed = true;
		return super.close(...);
	}
	function onCloseQuery() {
		//dm("onCloseQuery", _closeExec);
		if (_closeExec) {
			_closeExec();
			_closeExec = void;
		}
		return super.onCloseQuery(true);
	}


	// メニューを複製
	function copyMenu(dst, srclist) {
		var items = [];
		for (var i = 0; i < srclist.count; i++) {
			var src = srclist[i], hasCh = src.children.count > 0;
			var caption = src.caption;

			if (typeof src.debug != "undefined" && src.debug) continue; //  k2compat 加的菜单
			var item = new MenuItem(this, caption);
			with (item) {
				.group    = src.group;
				.radio    = src.radio;
				.checked  = src.checked;
				.shortcut = src.shortcut;
				.enabled  = src.enabled;
				.visible  = src.visible;
				.exp      = src.onClick;
				.onClick  = (function() {
					//dm("onClick", exp);
					var win = root.window;
					if (win) with (win) {
						if (._closed) exp();
						else {
							._closeExec = this.exp;
							.close();
						}
					}
				} incontextof item) if (!hasCh);
			}
			add(item);
			dst.add(item);
			items.add(%[ item:item, src:src ]);
			// 再帰コピー
			copyMenu(item, src.children) if (hasCh);
		}
		// 順番を設定		设置按钮顺序
		items.sort(function(a,b) { return a.src.index < b.src.index; }, true);

		// 设置 index bmp图片
		for (var i = 0, item, src; i < items.count; i++) {
			with (items[i]) item = .item, src = .src;
			item.index = src.index;
			item.bmpItem      = src.bmpItem      if (typeof src.bmpItem      != "undefined");
			item.rightJustify = src.rightJustify if (typeof src.rightJustify != "undefined");
		}
	}
	function onMouseLeave() {// 基本很难触发
		// マウスがウィンドウの外に出たら自動で閉じる
		close() if (autoclose == -1);
		return super.onMouseLeave(...);
	}
	function onExitMenuLoop() {
		close() if (autoclose == 1);
	}
	function superKeyDown { return super.onKeyDown(...); }
}


class MenuManager extends KAGPlugin {

	var menus = %[];
	
	function MenuManager(){
		kag.add(this);	
	}
	function finalize()
	{
		invalidate menus;
	}
	// ラジオメニューの有効化・無効化  启用或停用menu下组序号对应的菜单
	function setEnableMenuGroup(menu, group, en) {
		if (typeof menu == "String")
			menu = menus[menu];
		if (menu === void) return;
		var list = [];
		list.assign(menu.children);
		for (var i = 0; i < list.count; i++)
			list[i].enabled = en if (list[i].group == group);
	}

	/** 
	* @description: 	更新菜单项的值，如果prop属性为value则勾选，如果为组按钮还会检查是否属于组内
	* @param menu 菜单对象
	* @param prop	属性名 默认为value
	* @param value	属性值
	* @param group	组序号 
	* @return 无
	*/
	function updateCheckMenuItem(menu, prop = "value",value,  group) {
		if (menu !== void) with (menu) {
			if (group !== void && !(.group == group && .radio)) return;// 指定了组则必须是在组内的菜单
			if (typeof ._default  != "undefined" && isBlank(value) )
				 value = ._default; //	值为空设为默认值
			if (typeof menu[prop] != "undefined") .checked = (menu[prop] == value);
		}
	}
	/** ラジオメニューの更新 更新整组radio按钮，将prop 为value的选项勾选 
	* @param menu radio选项组的父菜单
	* @param value 需要选中的值
	* @param prop 属性名称
	* @param group 组序号
	**/
	function updateRadioMenuItem(menu,  prop = "value",value, group = 1) {
		if (typeof menu == "String")//	字符串则从kag属性中取出值，作为菜单
			menu = menus[menu];
		if (menu === void) return;
		var list = [];
		list.assign(menu.children);
		if (list.count == 0) {
			// 子が無い場合はチェックメニューとして処理  无子项则 勾选此选项
			updateCheckMenuItem(menu,prop,value);
		} else { //否则循环处理子选项
			for (var i = 0; i < list.count; i++)
				updateCheckMenuItem(list[i],prop, value, +group ); 
		}
	}


	/** 
	* @description: 以列表创建菜单项，对象的 name属性会被注册为窗口中的属性名
	* @param win	窗口
	* @param menu	父级菜单
	* @param list	菜单定义列表(如果有children属性会创建子菜单)
	* @return 
	*/
	function createMenuFromList(win, menu, list) {
		if (typeof list !== "Object" || !(list instanceof "Array")) return;
		for (var i = 0; i < list.count; i++) {
			var item = list[i];
			switch (typeof item) {
			case "void": break;
			case "String": menu.add(new MenuItem(win, item)); break; // 区切り等	分割线之类的
			case "Object":
				if (!(item instanceof "Dictionary"))break;
				with (item) {
					var exp = .exp;
					/*if (.se != "") {
						var se = getSysSE(.se);  //TODO 获取音效 其实打算去掉音效的设置
						if (se.storage != "") exp = %[ exp:exp, clickse:se.storage, clicksebuf:se.buf];
					}*/
					var sub = new KAGMenuItem(win, .caption, +.group, exp, .autoenable);
					menus[.name] = sub if (.name != ""); //如果有name，则记录到本类中
					menu.add(sub) if (!.noadd); // noadd指定がない場合は子メニューとして追加		无noadd指定时作为子菜单添加
					createMenuFromList(win, sub, .children) if (.children !== void); // 子メニュー登録	注册子菜单
					if (.prop !== void) // プロパティ登録		注册属性
						foreach(.prop, function(tag, value, dic, sub) { if (tag !== void) sub[tag] = value; }, sub);
				}
			}
		}
	}

	//------------------------------------系统命令行参数相关------------------------------------

	
	// 吉里吉里の引数の型と対応メニューの情報，変更時の処理など   吉里吉里参数的类型和对应菜单的信息，变更时的处理方法等
	var SystemArgumentInfo = %[
	fsres:      %[  changed:reFullScreen ],
	fszoom:     %[  changed:function {
		if (!isBlank(kag)) with (kag) try {
			var resize = (.fullScreened ?(.pseudoFullScreened) : .isMaximizedMode());
			if (resize) {			// 模拟全屏时或最大化只需重置大小即可
				.onResize();
				return;
			}
		} catch {}
		reFullScreen();	// 否则需强制重置全屏状态
	} incontextof this],
	smoothzoom: %[  changed:resetScreen ],//是否平滑放大

	contfreq:   %[ restart:true ],// 不需重启，TODO  但是可能不会立即生效
	drawthread: %[  changed:function() {
		var num = System.getArgument("-drawthread");
		switch (num) {
		case "auto": num = 0; break;
		default: try { num = +num; } catch { num = 1; } break;
		}
		System.drawThreadNum = num;
	} incontextof global ],

	// 故障排除用设定
	vomstyle:      %[  caption:"ムービー表示" ],
	// z被删除的东西
	//fullscreenmode:%[  caption:"複数モニタ全画面", changed:function { updateFullScrZoomMenu(); reFullScreen(); } incontextof global ],
	//fsmethod:      %[   changed:reFullScreen ],
	//waitvsync:     %[  changed:function { try { kag.flipStart(); } catch {} } incontextof global ],
	//usedb:      %[ changed:resetScreen ],
	/*dbstyle:    %[  changed:function() { resetScreen(); initSysArgMenuItem("usedb"); } incontextof global,
			isauto:function() { var dbs = System.getArgument("-dbstyle"); return (dbs == "" || dbs == "auto"); } incontextof global ],*/
	memusage:      %[  restart:true ],
	curmove:       %[  changed:function { 
		MyYesNoDialog.setCursorMoveTime(System.getArgument("-curmove"));		// 对话框 鼠标移动的时间
		systemUpdate("curMove") if (typeof global.systemUpdate == "Object");
	} incontextof global ],
	wheel:         %[  restart:true ],
	joypad:        %[  restart:true ],

	// 调试用
	autoerrlogopen:%[ ],
	autoerrlogmove:%[ ],
	consolerepos:  %[ ],
	consolesyncpos:%[ ],
		];

	// メニュー項目名称を保存		仅保存菜单项*名称*，有关命令行选项对应的菜单项的tag
	var sysArgMenuNameList = [];

	/** 
	* @description: 更新命令行参数相关设置，更新菜单  同时会更新·cfu配置文件
	* @param tag	选项名称
	* @param arg	是设置的参数值
	* @return 	对应值是否发生改变
	*/
	function setSystemArgument(tag, arg) {
		var value, info = !isBlank(tag) ? SystemArgumentInfo[tag] : void;

		// 変更する値を取得
		if (info === void || isBlank(arg)) return;

		// SystemArgument 設定
		var old  = System.getArgument("-"+tag), changed = (old != arg);
		System.setArgument("-"+tag, arg);
		if (info.restart) changed = false;
		// メニューを更新
		updateRadioMenuItem(info.menu, ,arg , info.group); // 这里使用到了group，所以如果 getSysArgRadioMenu 的exp使用预定义的方法，必须记录group
		// cfu に保存
		changeUserConf(tag, (string)arg);
		return changed;
	}


	// System.setArgument 系メニューの更新処理	System.setArgument系列菜单的更新处理，会调用菜单的change方法
	/** 
	* @description: 系统命令行参数相关菜单被点击时时触发,触发菜单点击时的事件 
	* 系统radio菜单的exp默认的事件 更新系统的设置和菜单，之后触发字典中定义的changed事件
	* @param tag	命令行参数名称,  也可以传递菜单项自身的对象
	* @param arg	值
	* @return 
	*/
	function setSysArgMenuItem(tag, arg) {
		//首先获取需要更新的选项和值
		/*if (tag instanceof "KAGMenuItem") {	// 这时传递的是菜单项对象自身，代表是radio菜单
			arg <-> tag;
			tag = arg.parent.tag if (!isBlank(arg.parent) && !isBlank(arg.parent.tag));
			if (!isBlank(tag) ) {
				tag = tag[+arg.group -1 ];// 因为组序号以1开始
			}
			arg = arg.value; // 使用菜单value属性 作为值
		}*/
		//直接有值则是check菜单,arg会传递选中后的值
		var info = !isBlank(tag) ? SystemArgumentInfo[tag] : void;	
		if (info === void) return;
		// 更新系统设置
		setSystemArgument(tag, arg); // tag: 命令行选项名 tag:值
		//更新后的触发事件
		if ( true === info.restart ) {//出现无法设置的情况时显示信息
			if (!info.dialog) {	// 只提醒一次
				var mes = isBlank(info.message)?SystemLanguage.getSystemText(,"InfoApplyOnRestart","the setting will be applied when restart"):info.message;
				System.inform(mes);
			}
			info.dialog = true;
		} else if (info.changed !== void) return info.changed(info); //	info 就是当前存储的信息状态  但是基本都不用这个参数
	}

	/** 
	* @description: 初始化命令行参数相关菜单的选择
	* @param menus	对应的命令行参数的名称列表 例如 fsres 等
	* @return 无
	*/
	function initSysArgMenuItem(menus*) { 
		if (!menus.count && sysArgMenuNameList.count > 0) return initSysArgMenuItem(sysArgMenuNameList*);//参数为空数组直接更新全部
		for (var i = 0; i < menus.count; i++) {
			var tag = menus[i];		// 	tag 是命令行名称的字符串 
			if (tag == "") continue;
			var info = SystemArgumentInfo[tag];
			if(info == void )continue;
			updateRadioMenuItem(info.menu, ,System.getArgument("-" + tag), info.group);//勾选菜单
		}
	}

	/** 
	* @description:  保存菜单项名称，存储到sysArgMenuNameList中，并为SystemArgumentInfo 设置菜单项名称和组序号
	* @param name 是其menu属性的名称 
	* @param tag SystemArgumentInfo的键的数组
	* @param grp 第一组序号 ，随tag数组长度会增加,grp如果不设置则为空，除非tag为数组
	* @return 
	*/
	function addSysArgMenu(name, tag, grp) {// name为空，不会注册到窗口的实例对象中
		if (tag.count==0) return;
		for(var i = 0;i<tag.count;i++){
			sysArgMenuNameList.remove(tag[i], true);
			sysArgMenuNameList.add(tag[i]);
			var info = SystemArgumentInfo[tag[i]];		// 指定多个tag时  每个标记都添加menu 和group
			if (  info === void )  Debug.notice(@"SystemArgumentInfo.${tag[i]}: has no menu info");
			else if (info.menu != "" && info.menu != name) Debug.notice(@"SystemArgumentInfo.${tag[i]}.menu: replicated（${name}/${info.menu}）");
			else info.menu = name;				// 此处为	SystemArgumentInfo 的菜单设置menu 属性为菜单的名称 name
			info.group = grp + i if (grp !== void && info !== void);
		}
	}

	/** 
	* @description: 用列表获取系统的radio菜单
	* @param list	菜单列表，每个元素可以提供 exp group name caption prop value 这些参数
	* @param tag 系统命令选项的列表,用于记录更新的系统命令行选项
	* @return 用于生成菜单的列表
	*/
	function getSysArgRadioSubMenu(tag,list){
		var ret = [];
		for (var i = 0; i < list.count; i++) {
			var item = list[i];
			if( isBlank(item.group) )
				item.group=1;
			if( isBlank(item.exp) )	//	不指定exp 默认使用更新菜单项的方法
				item.exp=@"SystemMenuManager.setSysArgMenuItem(\"${tag[item.group-1]}\",\"${item.value}\")"; 
			item.prop = %[];
			item.prop.value = item.value;
			if(item._default)
				item.prop._default = item.value;
			ret.add(item);
		}
		return ret;
	}

	/** 
	* @description: 创建一组菜单，	命令行相关菜单的添加，首先会记录相关的信息，然后返回创建菜单用的字典 
	* @param name 名称
	* @param caption 组标题
	* @param tag	命令行参数的名称
	* @param visible 是否可见
	* @param list 用于创建的列表, 指定每个子菜单的具体属性
	* @param group 组编号，用于记录到SystemArgumentInfo中，tag为列表时会逐个递增
	* @return  返回System.setArgument系列菜单的 createMenuFromList 用字典（广播列表用）
	*/
	function getSysArgRadioMenu(name, caption, tag, visible, list,group=1) {
		addSysArgMenu(name, tag,group);	//首先添加到记录 命令行选项对应的菜单的字典中
		return %[
		name:name, caption:caption, prop:%[ tag:tag, visible:visible ],	// 这里会指定tag的属性 ,代表菜单对应几个命令行参数
		children: getSysArgRadioSubMenu(tag,list)
			];
	}
	/** 
	* @description: 	创建一个系统命令行参数相关的 勾选模式菜单
	* @param name	名称
	* @param caption	标题
	* @param tag	命令行参数
	* @param visible	是否可见
	* @param defval	默认值
	* @param chkval 	勾选值
	* @param noval		取消勾选值
	* @return 	返回System.setArgument系菜单的 createMenuFromList 用字典（ON/off勾选用）
	*/
	function getSysArgCheckMenuItem(name, caption, tag, visible, defval, chkval = "yes", noval = "no") {
		var list = [tag];
		addSysArgMenu(name, list);
		return %[
		name:name, caption:caption,
		prop:%[ tag:tag, visible:visible, value:chkval, novalue:noval, _default:defval ],
		exp:function(sender) {//sender 就是菜单对象自身
			with (sender) setSysArgMenuItem(.tag, .checked ? .novalue : .value);
		} incontextof this];
	}
	//-----------------------------------------快捷键相关设置---------------------------------------------------------------
		// 功能名 - 菜单项的映射
	var updateCaptionMenusMap = %[	//这个map 键为操作的名称  值为kag内的属性名
		about:	"helpAboutMenuItem",		// 版本信息(F1)
		save:	"storeMenu",				// 存档(F2)
		load:	"restoreMenu",				// 读档(F3)
		screen:	"toggleScreenMenuItem",		// 窗口⇔全屏 切换(F4)
		backlog:"showHistoryMenuItem",		// 履历层(F5)
		auto:	"autoModeMenuItem",			// 自动模式(F6)
		skip:	"skipToNextStopMenuItem",	// 跳过(F7)
		option:	"configMenuItem",			// 选项(F8)
		qsave:	"quickStoreMenu",			// クイックセーブ(F11)
		qload:	"quickRestoreMenu",			// クイックロード(F12)

		next:	"goNextMenuItem",			// 后一个选项
		prev:	"goBackMenuItem",			// 前一个选项

		vreplay:"voiceReplayMenuItem",		// 音声リプレイ
		title:	"goToStartMenuItem",		// タイトルへ戻る
		rclick:	"rightClickMenuItem",		// 画面表示
		exit:	"exitMenuItem",				// 終了
		];

	/** 
	* @description: 	更改菜单的快捷键
	* @param hotkey	快捷键
	* @param tag	菜单项名称
	* @return 
	*/
	function updateMenuItemHotKey( hotkey, tag) {	//更新菜单显示的 快捷键 
		if (typeof menus[tag] == "undefined") return;
		with (menus[tag]) {
			// 记录原来的标题
			.origHotKey = .shortcut if (typeof .origHotKey == "undefined");
			if ( isBlank(hotkey) ) 
				.shortcut = .origHotKey;	//参数的快捷键为空则使用原来的快捷键
			else {
				.shortcut = hotkey;
			}
		}
	}

	/** 被且仅被 resetShortcutFunctionKeys 函数使用
	* @description: 	循环定义的功能列表，把菜单名称中对应这些菜单的名称
	* @param cap	快捷键映射字典
	* @return 
	*/
	function updateMenusHotkey(cap) {	//更新菜单快捷键部分的名称
		var ext = [];
		ext.assign(updateCaptionMenusMap);	// 需要更改的功能定义在这里
		for (var i = 0; i < ext.count; i+=2)
			updateMenuItemHotKey(cap[ext[i]], ext[i+1]);// cap[ext[i]] 是用功能名求出快捷键的字符串
	}

	/** 
	* @description: 更新F1-12功能键相关的菜单的名称
	* @return 无
	*/
	function resetShortcutFunctionKeys() {	//重新从 kagCustomizedKeys 构造出功能与F几键的映射关系,并更新名称中有 F几 作为快捷键部分的菜单的快捷键
		// 功能名-快捷键的字典 例：backlog - F5
		var updateCaptionFunctionKeys = %[];	
		var kck  = global.kagCustomizedKeys;

		for (var i = 0; i < 12; i++) {	// 循环F1-12
			var key = kck[VK_F1+i];
			updateCaptionFunctionKeys[key] = "F"+(i+1) if (key != "" && key != "none");
		}
		updateMenusHotkey( updateCaptionFunctionKeys );//更新菜单名称的快捷键
	}

	//------------------------------------分辨率和窗口部分-------------------------------------------------------
	
	// 更新菜单选项 全屏时会强制重设放大模式
	function reFullScreen() { updateFullScrZoomMenu(); resetScreenMode(true, true); }
	//重设放大模式，不强制
	function resetScreen()  { resetScreenMode(kag.fullScreened); }
	/** 
	* @description: 	暂时变更画面模式 并返回（用于反映 -fres 设定）
	* @param isfull	是否全屏,非强制模式下当前状态与此状态相同时才会生效
	* @param forcetrig	是否强制设置
	* @return 
	*/
	function resetScreenMode(isfull, forcetrig = false) {
		if (!isvalid global.kag) return;
		with (global.kag) {
			if (!forcetrig) {
				if (.drawDevice instanceof "DrawDeviceD3D") {
					.d3dStretchType = (System.getArgument("-smoothzoom") == "no") ? stNearest : stLinear; // [XXX] type選択可能に
				}
			} else {
				var trig, name = "resetScreenModeTrigger";
				if (( isfull  && !.fullScreened) ||
					(!isfull  &&  .fullScreened)) return;
				// トリガ取得     取得触发器
				if (typeof kag[name] != "undefined") trig = kag[name];
				else { // トリガがない場合は生成	没有则新生成
					kag[name] = trig = new AsyncTrigger(kag, 'onResetScreenModeTrigger');
					trig.cached = true;
					trig.mode = atmAtIdle;
					kag.onResetScreenModeTrigger = function() {
						global.System.setArgument("-fsres", fsres) if (hasset);
						global.kag.changeFullScreenOrWindow(isfull); 
					} incontextof trig;
				}
				// トリガ設定
				with (trig) {
					.isfull = isfull;
					.hasset = (typeof System.setArgument != "undefined");
					if (.hasset) {
						.fsres = System.getArgument("-fsres");
						System.setArgument("-fsres", "nochange");
					}
				}
				// 画面を一旦変更
				.changeFullScreenOrWindow(!isfull);
				// トリガでメニューをクリックさせる    在触发器中单击菜单
				trig.trigger();
			}
		}
	}


	/** TODO 之后需要测试下这个部分     使用原生fullScreen而不是无边框全屏/不使用winex
	* @description: 根据当前状态设置 更新 fsres fszoom等菜单选项的状态，纯菜单相关
	* @param menu 	菜单选项不指定默认为 fullScrResMenu 菜单,一般情况就是不填的吧
	* @return 
	*/
	function updateFullScrZoomMenu(menu = "fullScrResMenu") {
		if (isBlank(kag)) return;
		var res  = System.getArgument("-fsres"), pseudo = kag.exEventEnabled;
		var isauto = (res == "" || res == "auto");
		var ismiddle = (System.getArgument("-fszoom") == "middle");// middle这个选项是kag层次的
		var info = SystemArgumentInfo;
		//启动 或停用选项
		// fsres 为自动模式且非模拟模式无法设置zoom
		setEnableMenuGroup(menu, info.fszoom.group, !isauto || pseudo);	//如果menu选其他菜单的话，这里的组序号一定要保持一致,不然就有问题
		// 模拟模式无法设置 fsres
		setEnableMenuGroup(menu, info.fsres.group, !pseudo);	
		//模拟模式下勾选 nochange选项
		if (pseudo) updateRadioMenuItem(info.fsres.menu, ,"nochange", info.fsres.group);	
		else   initSysArgMenuItem("fsres");	

		if (ismiddle || (isauto && !pseudo)) {
			var tag = "inner";				// 非模拟模式 则auto代表inner
			tag = "middle" if (ismiddle && pseudo);	//模拟模式为middle
			updateRadioMenuItem(info.fszoom.menu, ,tag, info.fszoom.group);//	更新fszoom选项
		} else initSysArgMenuItem("fszoom");
		if (typeof menus.middleZoomPercentMenuItem == "Object")
			menus.middleZoomPercentMenuItem.enabled = (ismiddle && pseudo);	// 自定比例需要模拟模式且为middle
		if (typeof menus.fullScrResMiddleMenuItem == "Object")		//仅在模拟模式下 middle可用
			menus.fullScrResMiddleMenuItem.enabled = pseudo;
	}

	/** 
	* @description: 以当前的分辨率更新分辨率菜单
	* @return 无
	*/
	function _updateWindowResMenu() {
		with (kag) {
			var menu = menus.winResMenu;
			if(isBlank(menu))return;
			var now = .scWidth * .zoomNumer \ .zoomDenom;
			updateRadioMenuItem(menu, ,(now != .scWidth) ? now : void);
		}
	}

	/** 
	* @description: 设置窗口的分辨率，更新菜单选项，
	* @param arg 需要传递当前点击的菜单，或者实际宽度也可以
	* @return 
	*/
	function setWindowRes(arg) {
		var w = 0;
		if (arg instanceof "KAGMenuItem")
			w = +arg.value;
		else w = +arg;

		if (w == 0) return;
		w = kag.scWidth if (w < 0);
		kag.setZoom(w, kag.scWidth);
		_updateWindowResMenu();
	}

	/** 
	* @description: 窗口重置大小钩子函数,更新固定为XXX菜单的名称
	* @return  无
	*/
	function onWindowResizeHook() {
		if(isTempMenuShowing) return true; // 因临时菜单导致的变换，拦截掉不作处理
		var w = kag.innerWidth,h = kag.innerHeight;
		with (menus) {
			var sw = kag.scWidth;
			var sh = kag.scHeight;
			var dw = sw * kag.zoomNumer \ kag.zoomDenom;
			var dh = sh * kag.zoomNumer \ kag.zoomDenom;
			var amp = "&";
			if (typeof .disableWindowResizeMenuItem != "undefined") {
				.disableWindowResizeMenuItem.caption = @"fix to ${dw} x ${dh} (${amp}F)";//f是快捷键
			}
			
			updateRadioMenuItem(.winResMenu, ,w);	//更新分辨率的菜单勾选状态
			.winResMenu.enabled = !kag.tempZoomed && !kag.fullScreen;	// 非临时缩放且窗口化才能点击

			// pxWidth/pxHeightのサイズ変更があった場合はメニューのサイズを追従		调整pxWidth/pxHeight的大小时追随菜单的大小
			/*with (.winResMenu) if (typeof ._lastWidth == "undefined" || ._lastWidth != sw || ._lastHeight != sh) {
				._lastWidth  = sw;
				._lastHeight = sh;
				for (var i = 0, list = .children; i < list.count; i++) {	//更改下面的联动子菜单的标题
					var item = list[i];
					if (typeof item.scut != "undefined") {
						var tag = _getWindowResMenuItem(sw, sh, item.value, item.scut);
						item.caption = tag.caption if (tag !== void);
					}
				}
			}*/
			
		}
		updateFullScrZoomMenu(); 	// 更新全屏菜单勾选状态
		updateResizeMenuItems();	//	更新窗口大小菜单勾选状态
	}

	// ウィンドウモード時のサイズ変更関連メニュー処理		窗口模式时的调整大小相关菜单处理
	var windowResolutionWidthList = [320, 400, 512, 640, 720, 800, 960, 1024, 1280, 1440, 1600];

	//	wh宽高比  zw实际宽度  scut 快捷键	获取设置窗口分辨率的菜单（用于创建菜单的信息）
	function _getWindowResMenuItem(w, h, zw, scut) {
		var zh = zw * h \ w;//实际高度
		return %[   name:@"windowResizeTo${zw}MenuItem", caption:(scut != "" ? "(&"+scut+") : ":"") + @"${zw} x ${zh}", group:1,
				exp:setWindowRes incontextof this, prop:%[ value:zw, scut:scut, visible:(zw <= System.screenWidth && zh < System.screenHeight) ] ];//仅当小于最大屏幕大小才可见
	}


	/** 
	* @description: 等倍大小
	* @return 
	*/
	function onResetWindowSizeMenuItemClick()
	{
		kag.setZoom(1, 1);
		updateResizeMenuItems();
	}
	/** 
	* @description: 禁止窗口调整大小
	* @return 
	*/		 
	function onDisableWindowResizeMenuItemClick()
	{
		kag.windowResizeable = !kag.windowResizeable;
		updateResizeMenuItems();
	}
	/** 
	* @description:  更新窗口等倍大小的菜单状况
	* 同时会更新是否固定窗口菜单的情况
	* @return 
	*/
	function updateResizeMenuItems() {
		var maxfull = kag.fullScreen || (typeof kag.maximized != "undefined" && kag.maximized);
		if (typeof menus.resetWindowSizeMenuItem == "Object") with (menus.resetWindowSizeMenuItem) {
			.enabled =  !maxfull;
			.checked = !maxfull && (kag.origZoomNumer == kag.origZoomDenom);
		}
		if (typeof menus.disableWindowResizeMenuItem == "Object") with (menus.disableWindowResizeMenuItem) {
			.enabled =  !maxfull;
			.checked = !kag.windowResizeable;
		}
	}

	//------------------------------------菜单整体定义部分-------------------------------------------------------

	function _createMenus()
	{
		// 解像度メニュー一覧はリストから動的生成	从列表动态生成分辨率菜单列表
		var resMenus = [
			%[  name:"resetWindowSizeMenuItem",     caption:"标准：等倍尺寸(&D)", exp:(onResetWindowSizeMenuItemClick incontextof this),    prop:%[ shortcut:"Alt+1" ] ],
			%[  name:"disableWindowResizeMenuItem", caption:"固定(&F)",             exp:(onDisableWindowResizeMenuItemClick incontextof this) ], "-" ];
		
		var shortcuts = "1234567890-QWERTYUIOPZXCVBNM";
		for (var i = 0, cnt = windowResolutionWidthList.count; i < cnt; i++)
			resMenus.add(_getWindowResMenuItem(kag.scWidth, kag.scHeight, windowResolutionWidthList[i], shortcuts.charAt(i)));

		//	获得debug选项的快捷键
		var getHotKey = debugEnabled ? function (arg, def) { var s = System.getArgument("-"+arg); return s != "" ? s : def; } incontextof global : function {};
		createMenuFromList(kag, kag.menu, [
			// -------- ファイル
			%[  name:"systemMenu", caption:"ファイル(&F)", children:[
				%[  name:"storeMenu",         caption:"セーブ(&S)",     exp:"SystemAction._save()",  se:"menu.save" ],
				%[  name:"restoreMenu",       caption:"ロード(&L)",     exp:"SystemAction._load()",  se:"menu.load" ],
				%[  name:"quickStoreMenu",    caption:"クイックセーブ(&W)", exp:"SystemAction._qsave()", se:"menu.qsave" ],
				%[  name:"quickRestoreMenu",  caption:"クイックロード(&Q)", exp:"SystemAction._qload()", se:"menu.qload" ],
				"-",
				%[  name:"goToStartMenuItem", caption:"タイトルへ戻る(&T)",   exp:"kag.goToStart()",  se:"menu.title" ],
				%[  name:"rightClickMenuItem",caption:"画面表示", exp:"SystemAction._rclick()", se:"menu.rclick", noadd:true ],//未使用
				"-",
				%[  name:"exitMenuItem",      caption:"終了(&X)",            exp:"SystemAction._exit()",    se:"menu.exit", prop:%[ shortcut:"Alt+F4" ] ],
				] ],

			// -------- 画面
			%[  name:"displayMenu", caption:"画面(&S)", children:[
				%[  name:"windowedMenuItem",     caption:"ウィンドウ表示(&W)", group:1, exp:"kag.changeFullScreenOrWindow(false)"],//SystemAction.window()
				%[  name:"fullScreenMenuItem",   caption:"フルスクリーン(&F)", group:1, exp:"kag.changeFullScreenOrWindow(true)"],//SystemAction.fullScreen()
				%[  name:"toggleScreenMenuItem", caption:"窓表示⇔全画面 切り替え",     exp:"kag.changeFullScreenOrWindow(!fullScreen)", prop:%[ shortcut:"Alt+Enter", visible:false ] ],
				"-",
				%[  name:"winResMenu", caption:"窗口显示时大小(&S)", children:resMenus ],//0项为值，1项为标题，2项为名称，3项为组序号
				getSysArgRadioMenu("fullScrResMenu", "フルスクリーン時解像度(&R)", ["fsres","fszoom"], true, [
					%[value:"auto",caption:"自動設定(&A)",_default:true],
					%[value:"nochange",caption:"解像度を変えない(&O)"],
					%[value:"nearest",caption:"最も近い解像度(&N)"],
					%[value:"proportional",caption:"縦横比が同じ解像度(&P)"],
					%[caption:"-",group:4],
					%[value:"inner",caption:"内接で拡大：端に黒帯(&I)",group:2,_default:true],
					%[value:"outer",caption:"外接で拡大：端をカット(&C)",group:2],
					%[value:"no",caption:"拡大しない：中央に表示(&D)",group:2],
					%[value:"middle",caption:"中間で拡大：カットして黒帯(&M)",name:"fullScrResMiddleMenuItem",group:2],
					%[caption:"-",group:4],
					%[ name:"middleZoomPercentMenuItem", caption:"拡大割合指定(&Z)", exp:"inputMiddleZoomPercent()",group:3]
					]),
				getSysArgRadioMenu( "multiThreadDrawMenu", "描画スレッド分割数(&N)", ["drawthread"], (typeof System.drawThreadNum != "undefined"), [
					%[value:"1",caption:"無効：スレッド分割しない(&D)",_default:true],// 注意用get获得的都是字符串，所以用字符串类型
					%[value:"auto",caption:"自動：プロセッサ数で分割(&A)"],
					%[caption:"-",group:2],// 防止勾选到这里，组序号需要不同
					%[value:"2",caption:"2スレッド"],
					%[value:"4",caption:"4スレッド"],
					%[value:"8",caption:"8スレッド"]
					]),
				getSysArgCheckMenuItem("smoothZoomMenuItem", "拡大時スムージング(&T)", "smoothzoom", true, "yes"),
				"-",
				/*%[  name:"effectMenu", caption:"画面効果(&E)", noadd:true, children:[ // 未使用（チェックメニューに変更）
					%[  name:"effectMenuItem",   caption:"ON(&S)",  group:1, exp:setEffect, prop:%[ noeffect:false ] ],
					%[  name:"noeffectMenuItem", caption:"OFF(&N)", group:1, exp:setEffect, prop:%[ noeffect:true  ] ],
					] ],*/
				%[  name:"effectCheckMenuItem", caption:"画面効果(&E)",      exp:setEffect, prop:%[ toggle:true ] ],
				getSysArgRadioMenu("fpsLimitMenu", "最大フレームレート(&M)", ["contfreq"], true, [
					%[value:"0",caption:"制限なし(&N)",_default:true],
					%[value:"60",caption:"&60フレーム/秒"],
					%[value:"30",caption:"&30フレーム/秒"],
					%[value:"15",caption:"&15フレーム/秒"]
					]),
				] ],

			// -------- 進行制御
			%[  name:"systemControlMenu", caption:"進行制御(&M)", children:[
				%[  name:"showHistoryMenuItem",    caption:"バックログ(&L)",  exp:"SystemAction.backlog()", se:"menu.backlog" ],
				%[  name:"autoModeMenuItem",       caption:"オート(&A)",      exp:"SystemAction.auto()",    se:"menu.auto" ],
				%[  name:"skipToNextStopMenuItem", caption:"スキップ(&S)",    exp:"SystemAction.skip()",    se:"menu.skip" ],
				"-",
				/*%[  name:"goNextMenuItem",    caption:"次の選択肢へ進む(&N)", exp:"SystemAction.next()",    se:"menu.next"  ],
				%[  name:"goBackMenuItem",    caption:"前の選択肢に戻る(&B)", exp:"SystemAction.prev()",    se:"menu.prev"  ],*/
				"-",
				%[  name:"configMenuItem",         caption:"オプション(&O)",  exp:"SystemAction.option()",  se:"menu.option" ],
				%[  name:"voiceReplayMenuItem", caption:"音声リプレイ(&R)",   exp:"SystemAction.vreplay()", se:"menu.vreplay",visible:false ],
				] ],

			// -------- 文字表示
			/*%[  name:"characterMenu", caption:"文字表示(&C)", children:[
				%[  name:"chSpeedMenu", caption:"表示速度(&C)", children:[
					%[  name:"chSlowMenuItem",   caption:"遅い(&S)", group:1, exp:setTextSpeed, prop:%[ speed:chSpeeds.slow   ] ],
					%[  name:"chNormalMenuItem", caption:"普通(&N)", group:1, exp:setTextSpeed, prop:%[ speed:chSpeeds.normal ] ],
					%[  name:"chFastMenuItem",   caption:"速い(&F)", group:1, exp:setTextSpeed, prop:%[ speed:chSpeeds.fast   ] ],
					//"-",
					%[  noadd:true, name:"chNonStopToPageBreakItem", caption:"ページ末まで一気に(&P)", exp:onChNonStopToPageBreakItemClick ],//未使用
					] ],
				%[  name:"autoModeWaitMenu", caption:"オート待ち時間(&D)", children:[
					%[  name:"autoModeFastMenuItem",   caption:"短い(&1)",     group:1, exp:setAutoSpeed, prop:%[ wait:autoModePageWaits.fast,   lwait:autoModeLineWaits.fast   ] ],
					%[  name:"autoModeFasterMenuItem", caption:"略短(&2)", group:1, exp:setAutoSpeed, prop:%[ wait:autoModePageWaits.faster, lwait:autoModeLineWaits.faster ] ],
					%[  name:"autoModeMediumMenuItem", caption:"普通(&3)",     group:1, exp:setAutoSpeed, prop:%[ wait:autoModePageWaits.medium, lwait:autoModeLineWaits.medium ] ],
					%[  name:"autoModeSlowerMenuItem", caption:"略长(&4)", group:1, exp:setAutoSpeed, prop:%[ wait:autoModePageWaits.slower, lwait:autoModeLineWaits.slower ] ],
					%[  name:"autoModeSlowMenuItem",   caption:"长(&5)",     group:1, exp:setAutoSpeed, prop:%[ wait:autoModePageWaits.slow,   lwait:autoModeLineWaits.slow   ] ],
					] ],
				"-",
				%[  name:"cancelAutoByClickMenuItem", caption:"左击停止自动模式(&K)", exp:setCancelAutoByClick, prop:%[ checkitem:true ] ],
				// 未使用
				%[  noadd:true, name:"allskipMenu", caption:"未读台词跳过(&I)", children:[
					%[  name:"allskipMenuItem",   caption:"ON(&S)",  group:1, exp:setAllSkip, prop:%[ skip:true  ] ],
					%[  name:"noallskipMenuItem", caption:"OFF(&N)", group:1, exp:setAllSkip, prop:%[ skip:false ] ],
					] ],
				// 上記のチェックアイテム版 上述的勾选项目版
				%[  name:"allskipCheckMenuItem", caption:"未读台词跳过(&I)", exp:setAllSkip, prop:%[ checked:allskip, checkitem:true ] ],
				// 未使用
				%[  noadd:true, name:"ch2ndSpeedMenu", caption:"一度読んだところは(&I)", children:[
					%[  name:"ch2ndNoWaitMenuItem",   caption:"ノーウェイト(&W)", group:1, exp:onCh2ndSpeedMenuItemClick, prop:%[ speed:0               ] ],
					%[  name:"ch2ndFastMenuItem",     caption:"高速(&F)",         group:1, exp:onCh2ndSpeedMenuItemClick, prop:%[ speed:chSpeeds.fast   ] ],
					%[  name:"ch2ndNormalMenuItem",   caption:"普通(&N)",         group:1, exp:onCh2ndSpeedMenuItemClick, prop:%[ speed:chSpeeds.normal ] ],
					%[  name:"ch2ndNoChangeMenuItem", caption:"変えない(&M)",     group:1, exp:onCh2ndSpeedMenuItemClick, prop:%[ speed:-1  ] ],//不变更
					"-",
					%[  name:"ch2ndNonStopToPageBreakItem", caption:"ページ末まで一気に(&P)", exp:onCh2ndNonStopToPageBreakItemClick ],
					] ],
				"-",
				%[  name:"chAntialiasMenuItem",  caption:"アンチエイリアス(&A)", exp:onChAntialiasMenuItemClick ],
				%[  name:"chChangeFontMenuItem", caption:"フォント(&F) ...",     exp:onChChangeFontMenuItem ],
				] ],*/

			// -------- ヘルプ
			%[  name:"helpMenu", caption:"ヘルプ(&H)", children:[
				%[  name:"helpIndexMenuItem", caption:"目次(&I) ...", exp:"", noadd:!Storages.isExistentStorage("brows_help.ks") ],
				%[  name:"helpReadmeMenuItem", exp:"System.shellExecute('\"'+Storages.getLocalName(System.exePath+SystemConfig.ReadmeFile)+'\"')", //noadd:true,
					caption:         isBlank(SystemConfig.ReadmeName) ? SystemConfig.ReadmeName+"(&R)..." : "&README...",
					prop:%[ enabled: ( !isBlank(SystemConfig.ReadmeFile) && Storages.isExistentStorage(System.exePath+SystemConfig.ReadmeFile)), visible:false ] ],
				%[  name:"helpWebMenuItem",   caption:"&WEBサイトを開く", exp:"System.shellExecute(SystemConfig.GameURL);",
					prop:%[ enabled:(!isBlank(SystemConfig.GameURL)) ] ],
				"-",
				%[  name:"troubleShootMenu", caption:"環境依存の不具合回避(&T)", children:[	//TODO  这个和下面的鼠标移动都再说了
					getSysArgRadioMenu( "videoOverlayModeMenu", "ムービー表示", ["vomstyle"], true, [
						%[value:"auto",caption:"自動設定",_default:true],
						%[value:"overlay",caption:"オーバーレイ"],
						%[value:"mixer",caption:"ミキサー"],
						%[value:"layer",caption:"レイヤー"]
						]),

					getSysArgCheckMenuItem("disableCursorMoveMenuItem", "マウスカーソルの自動移動を禁止", "curmove",   true, "yes",    "no",      "yes"),
					getSysArgCheckMenuItem("mouseWheelMsgMenuItem",     "マウスホイールの取得方法を変更", "wheel",     true, "dinput", "message", "dinput"),
					getSysArgCheckMenuItem("disableJoypadMenuItem",     "ゲームパッドの使用禁止",         "joypad",    true, "dinput", "no",      "dinput"),
					%[  name:"bindGamePadButtonMenuItem", caption:      "ゲームパッドのボタン割り当て変更", exp:"bindGamePadButton()" ],
					"-",
					getSysArgCheckMenuItem("lowMemoryPerfMenuItem",     "省メモリ動作モード",             "memusage",  true, "normal", "low",     "normal"),
					] ],
				"-",
				%[  name:"helpAboutMenuItem", caption:"バージョン情報(&A)", group:1, exp:"SystemAction._about()" ],
				] ],

			// -------- デバッグ
			/*%[  name:"debugMenu", caption:"デバッグ(&D)", prop:%[ enabled:debugEnabled ], children:[
				%[  name:"loadScenarioMenuItem",     caption:"シナリオの読込み(&L)", exp:Storages.isExistentStorage("!scnlist.txt") && typeof global.MenuItem.popupEx == "Object" ?
					"execPopup('!scnlist.txt')" :                                         onExecDialogMenuItemClick,          prop:%[ shortcut:(debugEnabled?"Shift+F8":void) ] ],
				%[  name:"reloadScenarioMenuItem",   caption:"シナリオの再読込み(&R)",         exp:onReloadScenarioMenuItemClick,  prop:%[ shortcut:(debugEnabled?"Shift+F7":void) ] ],
				%[  name:"restartScenarioMenuItem",  caption:"現在のシナリオを先頭から(&S)",   exp:"skipToScenarioLine(0)",        prop:%[ shortcut:(debugEnabled?"Shift+F6":void) ] ],
				%[  name:"jumpPrev100LineScenarioMenuItem", caption:"現在のシナリオの100行前へ", exp:"skipToScenarioLine(-100)",      prop:%[ shortcut:(debugEnabled?"Shift+F10":void) ] ],
				%[  name:"jumpLineScenarioMenuItem", caption:"現在のシナリオの指定行数へ(&J)", exp:"skipToScenarioLine()",         prop:%[ shortcut:(debugEnabled?"Alt+G"   :void) ] ],
				%[  name:"editCurtScenarioMenuItem", caption:"現在のシナリオを編集(&E)",       exp:"editCurrentLineScenario()",    prop:%[ shortcut:(debugEnabled?"Alt+E"   :void) ] ],
				%[  name:"backToAutoLabelStoreMenuItem", caption:"直前に戻る\tShift+BS",       exp:onBackToAutoLabelStoreMenuItemClick ],
				%[  name:"selectAutoLabelStoreMenuItem", caption:"直前を選択して戻る\tAlt+BS", exp:selectAutoLabelStore                ],
				"-",
				%[  name:"debugFlagEditMenuItem",  caption:"フラグ参照・編集(&F)",   exp:"startFlagEdit()",                prop:%[ shortcut:(debugEnabled?"Shift+F9":void) ] ],
				%[  name:"allSeenMenuItem",        caption:"鑑賞モード全O&N", exp:
					function (sender) { tf.allseen = !tf.allseen; sender.checked = tf.allseen; kag.goToStart(); } ],
				"-",
				%[  name:"systemResetMenuItem",    caption:"システムリセット(マクロ再読)", prop:%[ shortcut:(debugEnabled?"Shift+DEL":void) ],
					exp:function() { resetAll(); terminator.invoke(); process("first.ks", "*reset",, true); } incontextof this ],
				%[  name:"systemRestartMenuItem",  caption:"システム再起動\tALT+DEL", exp:"systemReboot()", //prop:%[ shortcut:(debugEnabled?"Alt+DEL":void) ],
					enabled:(typeof System.waitForAppLock == "Object") ],
				"-",
				%[  name:"bugReportMenuItem", caption:"バグレポート作成(&B)", exp:"editBugReport()", prop:%[ shortcut:(debugEnabled?"Alt+B":void) ] ],
				%[  name:"debugWinMenuItem",  caption:"デバッグ情報表示(&I)", exp:onDebugWinMenuItemClick,   prop:%[ shortcut:(debugEnabled?"Shift+F5":void) ] ],
				%[  name:"debugLevelMenu",    caption:"デバッグログレベル(&D)", children:[
					%[  name:"debugLevelNoneMenuItem",    caption:"なし(&N)",     group:2, exp:onDebugLevelNoneMenuItemClick ],
					%[  name:"debugLevelSimpleMenuItem",  caption:"シンプル(&S)", group:2, exp:onDebugLevelSimpleMenuItemClick ],
					%[  name:"debugLevelVerboseMenuItem", caption:"詳細(&D)",     group:2, exp:onDebugLevelVerboseMenuItemClick ],
					"-",
					%[  name:"debugEnvCheckerSettingMenuItem",  caption:"デバッグ情報：環境表示項目(&C)", exp:function {
						if (hasDebugUtil) global.DebugEnvStateCheckerConfig();
					} incontextof global ],
					] ],
				%[  name:"voiceSpeedMenu", caption:"ボイス速度(&V)", children:[
					%[  name:"voiceNormalSpeedMenuItem",     caption:"通常(&N)",    group:1, exp:onVoiceSpeedMenuItemClick, prop:%[ speed:1.0 ] ],
					%[  name:"voiceOneHalfSpeedMenuItem",    caption:"1.5倍速(&F)", group:1, exp:onVoiceSpeedMenuItemClick, prop:%[ speed:1.5 ] ],
					%[  name:"voiceDoubleSpeedMenuItem",     caption:"2倍速(&D)",   group:1, exp:onVoiceSpeedMenuItemClick, prop:%[ speed:2.0 ] ],
					%[  name:"voiceDoubleHalfSpeedMenuItem", caption:"2.5倍速(&E)", group:1, exp:onVoiceSpeedMenuItemClick, prop:%[ speed:2.5 ] ],
					%[  name:"voiceTripleSpeedMenuItem",     caption:"3倍速(&T)",   group:1, exp:onVoiceSpeedMenuItemClick, prop:%[ speed:3.0 ] ],
					] ],
				%[  name:"debugDetailMenu",   caption:"詳細ツール(&T)", children:[
					%[  name:"showConsoleMenuItem",       caption:"コンソール(&C)\t"  +getHotKey("hkconsole",   "Shift+F4"), exp:onShowConsoleMenuItemClick ],
					getSysArgCheckMenuItem("restoreConsolePosMenuItem", "起動時にコンソール位置を確実に補正(&R)", "consolerepos", true, "no"),
					getSysArgCheckMenuItem("syncroConsolePosMenuItem",  "コンソールを連動移動(&M)", "consolesyncpos", true, "no"),
					"-",
					%[  name:"currentVoiceNumberMenuItem",caption:"ボイス番号をクリップボードにコピー(&V)", exp:"copyCurrentVoiceToClipBoard()",  prop:%[ shortcut:(debugEnabled?"Alt+V":void) ] ],
					%[  name:"curVoiceLabelEditMenuItem", caption:"現在ボイスのラベル編集(&L)", exp:"editCurrentVoiceLabel()",  prop:%[ shortcut:(debugEnabled?"Alt+L":void) ] ],
					%[  name:"copyCurrentEnvTextMenuItem",caption:"現在の環境情報をクリップボードにコピー(&T)", exp:"copyCurrentEnvInfoToClipBoard(%[all:1,voicebase:0,chvoice:0])",  prop:%[ shortcut:(debugEnabled?"Alt+T":void) ] ],
					%[  name:"captureCurrentScreenMenuItem", caption:"現在の画面をキャプチャ(&P)", exp:"captureCurrentScreen()",  prop:%[ shortcut:(debugEnabled?"Alt+P":void) ] ],
					"-",
					] ],
				"-",
				] ],*/

			]);
		kag.callHook("onKAGSetupMenu");
		(global.KAGWindow_createCustomMenus incontextof this)() if (typeof global.KAGWindow_createCustomMenus == "Object");
	}
	function createKagMenus()
	{
		
		if(kag.exEventEnabled)menuBarState = 0;//强制隐藏
		else menuBarState  =  1 ; // menuBarMode == 0 の時は設定されないのでここで確定しておく		menuBarMode==0时不设定，所以在这里确定
		// メニュー項目を生成		生成菜单项
		_createMenus();
		(Menu_visible_config incontextof this)();//菜单的显示隐藏设置
		createBookMarkSubMenus();// 因为 设置了numBookMark 所以最后生成
		setBookMarkMenuCaptions();
		// ファンクションキーを更新		更新功能键(F1-F12) 的标题中的 快捷键
		resetShortcutFunctionKeys();
		// SystemArgument系メニューの更新	更新涉及命令行参数 的菜单
		var args = [], info = SystemArgumentInfo;
		for (var i = 0; i < sysArgMenuNameList.count; i++) {
			var tag = sysArgMenuNameList[i], menu;
			if (info[tag] !== void && !isBlank(menu = info[tag].menu) && typeof  menus[menu] == "Object") {	
				args.add(tag);
			}
		}
		initSysArgMenuItem(args*);
		updateFullScrZoomMenu(menus.fullScrResMenu);

		kag.rightClickDefaultName = .rightClickCurrentMenuName = menus.rightClickMenuItem.caption;
		// .autoModeMediumMenuItem.checked = true;
		menus.windowedMenuItem.checked = true;
		//.chNormalMenuItem.checked = true;
		//.ch2ndNoChangeMenuItem.checked = true;

	

		//根据设置的状态启用菜单栏的功能
		if(!menuBarEnable){// 设置未开启功能则不进行之后的操作
			kag.menu.visible = false;
			return;
		}
		// 动态菜单
		createMenuBarHideMenu(); // 创建	
		menuBarState = !isBlank(kag.scflags.menuBarState)?kag.scflags.menuBarState:defaultMenuBarState;//	从存档中 恢复菜单栏状态
		updateMenuBarState(); // 更新状态
		//-----------注册菜单相关事件-------------
		kag.addHook("onMouseMove",this.onMouseMove);
		kag.addHook("onNcMouseMove",this.onNcMouseMove);
		kag.addHook("onNcMouseDown",this.onNcMouseDown);
		kag.addHook("onNcMouseUp",this.onNcMouseUp);
		kag.addHook("onResize", (onWindowResizeHook incontextof this));
		kag.addHook("onAfterChangeScreenMode",(onAfterChangeScreenMode incontextof this));
		// kag.addHook("onDisplayChangedHook", (updateFullScrZoomMenu incontextof this)); // 我觉得不应该在这里做这个
	

		kag.onStartKeyMenu=this.onStartKeyMenu incontextof this; // 菜单专用，所以不是hook也没关系
		kag.onExitMenuLoop=this.onExitMenuLoop incontextof this;
		//系统模式变换
		kag.addHook("onModeChange",(onModeChange incontextof this));
		//存档事件
		kag.addHook("onSaveBookMark",(onSaveBookMark incontextof this));
	}


	function onSaveSystemVariables()
	{	
		with(kag.scflags){
			.menuBarState = menuBarState;
		}
	}
	//----------------------------系统状态变换导致的菜单启用相关----------------------------
	function _setEnable(name,enable){
		if(!isBlank(menus,name)){
			menus[name].enabled = enable;
		}
	}
	function onModeChange(elm){
		with(elm){
			// state 代表 稳定状态，且无模态框显示+消息层显示  modal代表 模态(履历)框显示或消息层不显示 
			_setEnable("autoModeMenuItem",.canAuto);
			_setEnable("skipToNextStopMenuItem",.canSkip);
			_setEnable("rightClickMenuItem",.inStable && !currentDialog);
			_setEnable("showHistoryMenuItem",.inStable && !kag.messageLayerHiding && !currentDialog);
			_setEnable("goBackMenuItem",.state && kag.isHistoryOfStoreAlive(0));
			_setEnable("goToStartMenuItem",.state && kag.startAnchorEnabled);
		
			if(!isBlank(menus,"storeMenu"))//存档
			{
				var st = .state && .canStore && inGameState();	// 允许存档且在游戏稳定状态
				var children = menus.storeMenu.children;
				if(kag.freeSaveDataMode) _setEnable("storeMenu",st);
				else {
					for(var i = children.count - 1; i >= 0; i--)
					{
						var obj = children[i];
						obj.enabled = obj.orgEnabled && st;
					}
				}
			}
			if(!isBlank(menus,"restoreMenu"))//读取存档
			{
				var st = .state && .canRestore;
				var children =  menus.restoreMenu.children;
				if(kag.freeSaveDataMode) _setEnable("restoreMenu",st);
				else for(var i = children.count - 1; i >= 0; i--)
				{
					var obj = children[i];
					obj.enabled = obj.orgEnabled && st;
				}
			}
		}
	}
	//----------------------------------存档相关---------------------------------
	var numBookMarks;
	var showBookMarkDate;
	function createBookMarkSubMenus() 
	{
		var menu = menus.storeMenu;
		// 「栞をたどる」「栞をはさむ」以下にサブメニュー項目を追加  读取进度和保存进度中追加下面的项目
		if(kag.freeSaveDataMode) return; // フリーセーブモードではなにもしない  自由保存模式直接返回
		if(!isBlank(menu) && menu.visible)
		{
			for(var i = 0; i<numBookMarks; i++)
			{
				var item;
				menu.add(item = new KAGMenuItem(kag, (string)i, 0, onBookMarkStore,false));
				item.bmNum = i;
				item.orgEnabled = false;
			}
		}
		menu = menus.restoreMenu;
		if(!isBlank(menu) && menu.visible)
		{
			for(var i = 0; i<numBookMarks; i++)
			{
				var item;
				menu.add(item = new KAGMenuItem(kag, (string)i, 0, onBookMarkRestore,false));
				item.bmNum = i;
				item.orgEnabled = false;
			}
		}
	}
		
	function setBookMarkMenuCaptions()
	{
		// 「栞をたどる」「栞をはさむ」以下のサブメニューに
		// キャプションを設定

		// 栞を挟む
		if(!isBlank(menus.storeMenu ))
		{
			var children = menus.storeMenu.children;
			for(var i = children.count - 1; i >= 0; i--)
			{	
				 if( !isBlank(kag.bookMarks[i])) //存在存档
				{
					// 栞が存在する
					var caption;
					if(showBookMarkDate) caption = kag.bookMarks[i].date + " ";
					caption += SystemLanguage.getScenarioText(, kag.bookMarks[i].lastTextStorage,kag.bookMarks[i].lastTextNum).text;
					var item = children[i];
					item.caption = caption;
					item.enabled = false;
					item.orgEnabled = kag.bookMarks[i].protectedStates;
				}
				else
				{
					// 栞が存在しない
					var item = children[i];
					item.caption = "(未设定)";
					item.enabled = false;
					item.orgEnabled = true;
				}
			}
		}

		// 栞をたどる
		if(!isBlank(menus.restoreMenu ))
		{
			var children = menus.restoreMenu.children;
			for(var i = children.count - 1; i >= 0; i--)
			{
				if( !isBlank(kag.bookMarks[i])) //存在存档
				{
					// 栞が存在する
					var caption;
					if(showBookMarkDate) caption = kag.bookMarks[i].date + " ";
					caption += SystemLanguage.getScenarioText(, kag.bookMarks[i].lastTextStorage,kag.bookMarks[i].lastTextNum).text;
					var item = children[i];
					item.caption = caption;
					item.enabled = false;
					item.orgEnabled = true;
				}
				else
				{
					var item = children[i];
					item.caption = "(未设定)";
					item.enabled = false;
					item.orgEnabled = false;
				}
			}
		}
		// setMenuAccessibleAll();
	}

	// 存档菜单项
	function onRestoreMenuClick(sender)
	{
		if(!kag.freeSaveDataMode) SystemAction.load();
		else loadBookMarkFromFileWithAsk();
	}

	function onStoreMenuClick(sender)
	{
		if(!kag.freeSaveDataMode) SystemAction.save();
		else saveBookMarkToFileWithAsk();
	}
	// 存档子菜单项
	function onBookMarkStore(sender)
	{
		kag.saveBookMarkWithAsk(sender.bmNum);
	}

	function onBookMarkRestore(sender)
	{
		kag.loadBookMarkWithAsk(sender.bmNum);
	}

	function onSaveBookMark(){
		setBookMarkMenuCaptions();
	}


	//--------------------------------自动菜单相关功能-----------------------------
	//----------------设置类变量，config一次设置，不会更改----------
	var menuBarEnable = true; // 是否启用菜单功能
	var menuBarMode = 1; // 是否允许变更动态显示模式，0 固定，无法变更 1 固定，可以变更  
	var menuAutoModeEnabled		= true;// 自己的新变量 是否启用动态状态 (这个动态修改可以临时禁止或启用动态模式的触发)
	var menuBarHideButtonEnabled = true; // 是否启用菜单栏 右端的显示恢复按钮(x + 按钮) 
	var menuBarRightClickEnabled = true; //菜单栏上右击  是否有效      
	// var pseudoMenuEnabled		= false;// 是否启用模拟菜单栏 不建议启用

	var defaultMenuBarState = 1; // 初期状態
	//-----------------------状态类变量，会一直变化--------------------------------
	var menuBarState;  // 現在のメニューの表示状態(0:非表示，1:表示，-1:自動表示）			当前的菜单状态 0隐藏  1显示 -1自动显示
	var _isTempMenuShowing = false;  
	var _usingkey = false;  	// 当前的临时菜单是否是由键盘alt开启的
	property isTempMenuShowing{	// 临时菜单是否正在显示 仅由 changeTempMenuState 控制,非动态模式下为false
		getter { return _isTempMenuShowing;}
	}
	
	// 全屏 无论是否自动都是自动显示：  自动只决定窗口下的模式

	/** 
	* @description: 以当前状态更新 动态模式菜单栏勾选状态 和自动隐藏按钮的标题
	* @return 
	*/	
	function updateMenuBarState() { 
		if (!menuBarMode) return;
		var oriVis = kag.menu.visible; 
		// 非全屏下菜单的模式才会更新菜单栏显示
		if (!kag.fullScreen){
			if(menuBarState == 1 || menuBarState == -1)changeTempMenuState(false);
			kag.menu.visible = (menuBarState > 0);
		}
		
		var list = menus.menuBarHidePopupMenu;
		for (var i = list.count-1; i >= 0; i--)	// 	更新勾选状态
			 with (list[i]) .checked = (.state == menuBarState);	

		if (menus.menuBarHideMenuItem !== void) with (menus.menuBarHideMenuItem) {  //更新 x +按钮的显示状态
			if (kag.fullScreen) .visible = false;// 全屏无此按钮
			else {
				.caption = (menuBarState > 0) ? "x" : "+";	
				.visible = true;
				.rightJustify = true;
				.state = (menuBarState > 0) ? (menuAutoModeEnabled ? -1 : 0) : 1;
			}
		}
		return oriVis != kag.menu.visible;// 是否因菜单 导致窗口大小改变
	}

	// 变更菜单栏当前状态 stat ：指定的状态
	function changeMenuBarState(stat) {
		if (!menuBarMode) return;
		menuBarState = stat;
		var changed = updateMenuBarState();
		if(changed)
			kag.onResize();
	}

	/**
	* @description: 点击菜单栏控制菜单触发的方法,更改菜单的显示隐藏状态
	* @param sender  触发点击的菜单，或者是变更后的状态  1代表显示 -1代表自动显示  0是隐藏
	* @return 无 
	*/
	function toggleMenuBarState(sender) {
		if (!menuBarMode) return;
		//当sender 没有state时 使用这里做判断  ，显示状态则变为自动状态，隐藏和自动状态则变为 显示状态
		var state = (menuBarState <= 0) ? 1 : (menuAutoModeEnabled ? -1 : 0);	
		state = sender.state if (sender !== void && typeof sender.state == "Integer");	//sender 中指定了state则以sender为准
		changeMenuBarState(state);
	}

	/**
	* 创建隐藏菜单的菜单项
	*/
	function createMenuBarHideMenu() {
		var menuBarHidePopupMenu = [
				%[  caption:"常に表示",   group:1, state: 1 ],
				%[  caption:"常に非表示", group:1, state: 0 ]];
		if (menuAutoModeEnabled) {
			menuBarHidePopupMenu.add(%[  caption:"動的に表示", group:1, state:-1 ]);
		}
		var menuBarHideSysMenu = [
				%[  caption:"-" ],
				%[  caption:"menubar", children:menuBarHidePopupMenu ] ];

		menus.menuBarHidePopupMenu = menuBarHidePopupMenu;
		menus.menuBarHideSysMenu =  kag.exSystemMenu = menuBarHideSysMenu;
		kag.addHook("onExSystemMenuSelected",toggleMenuBarState);
		if (menuBarHideButtonEnabled) {
			menus.menuBarHideMenuItem  = new KAGMenuItem(kag, "x", 0, toggleMenuBarState, false);
			menus.menuBarHideMenuItem.state = (menuAutoModeEnabled ? -1 : 0);
			kag.menu.add(menus.menuBarHideMenuItem);
		}
	}

	// 改变菜单临时的显示状态		不会考虑是否全屏幕   菜单栏当前状态等问题，这些需要由高层次接口考虑
	function changeTempMenuState(vis,usekey = false){
		if( isTempMenuShowing == vis || !menuAutoModeEnabled )return;// 需要启用自动模式下 且显示状态和需要设置的不相同
		/*if(pseudoMenuEnabled && vis ){ // 只有显示状态需要显示，隐藏会自动消失
			var popup = new PopupMenuWindow(kag, usekey ? 1: -1, !kag.exEventEnabled);
			if (kag.exEventEnabled) with (popup) {
				._ncCaptionClick = void;
				.menuBarHidePopupMenu = menus.menuBarHidePopupMenu;
				.menuBarRightClickEnabled = menuBarRightClickEnabled;
				.changeMenuBarState   = changeMenuBarState;
				.onNcMouseDown = (onNcMouseDown incontextof popup);
				.onNcMouseUp__ = (onNcMouseUp   incontextof popup);
				.onNcMouseUp   = function(x, y, btn, rg) { onNcMouseUp__(x, y, btn, rg); } incontextof popup;
				.showModal();
			}
			invalidate popup;
		}
		else
		{	
			 kag.menu.visible = vis;
		}*/
		kag.menu.visible = vis;
		_isTempMenuShowing = vis;
		_usingkey = usekey;
	}



	/**
	* 为菜单增加控制最大化最小化的按钮，可以反复调用
	* 最小化・最大化/復帰，閉じるメニューを追加・削除（要 WindowExプラグイン）
	* @param win Windowインスタンス
	* @param min 最小化表示 -1:無効 0:非表示 1:表示
	* @param max 最大化表示 -1:無効 0:非表示 1:表示
	* @param res 復帰表示   -1:無効 0:非表示 1:表示
	* @param cls 閉じる表示 -1:無効 0:非表示 1:表示
	*/
	function setWindowControlMenu(win, min, max, res, cls) {
		if (typeof win.minimize != "Object") return;
		var btns, tag = "__windowControlMenus";
		if (typeof menus[tag] == "undefined") {
			// メニューアイテム生成
			btns = %[
				minimize: new MenuItem(win, ''),
				maximize: new MenuItem(win,  ''),
				restore:  new MenuItem(win,  ''),
				close:    new MenuItem(win, '')
				];
			with (btns) {
				with (.minimize) .icon =  MenuItem.biPopupMinimize;
				with (.maximize) .icon =  MenuItem.biPopupMaximize;
				with (.restore ) .icon =  MenuItem.biPopupRestore;
				with (.close   ) .icon =  MenuItem.biPopupClose;
				
				// クリック処理
				.minimize.onClick = win.minimize;
				.maximize.onClick = win.maximize;
				.close   .onClick = win.close;
				.restore .onClick = function() {
					if (fullScreen) changeFullScreenOrWindow(false);
					else changeFullScreenOrWindow(true);
				} incontextof win;
			}
			menus[tag] = btns;
		}
		btns =  menus[tag];
		with (btns) {
			// 追加
			var first, add = function(item, f) {
				this.add(item);
				return (f === void) ? item : f;
			} incontextof win.menu;
			var reset = function(item) {		//防止反复调用，先移除旧的菜单
				var parent = item.parent;
				if (parent) {
					try {
						if (*(&global.MenuItem.HMENU incontextof parent))
							item.rightJustify = false;
					} catch(e) {
						Debug.message(e.message);
					}
					parent.remove(item);
				}
			} incontextof global;
			reset(.minimize);
			reset(.maximize);
			reset(.restore );
			reset(.close   );
			first = add(.minimize, first) if (min);
			first = add(.maximize, first) if (max);
			first = add(.restore,  first) if (res);
			first = add(.close,    first) if (cls);

			// アイコン設定		设置图标
			.minimize.bmpItem = .minimize.icon if (min);
			.maximize.bmpItem = .maximize.icon if (max);
			.restore .bmpItem = .restore .icon if (res);
			.close   .bmpItem = .close   .icon if (cls);

			// 無効設定		设置无效状态
			.minimize.enabled = (min > 0) if (min);
			.maximize.enabled = (max > 0) if (max);
			.restore .enabled = (res > 0) if (res);
			.close   .enabled = (cls > 0) if (cls);

			// 第一个右对齐，之后的也都会跟着
			first.rightJustify = true if (first !== void);
		}
	}

	function onMouseMove(x, y, shift){	//全屏幕不管是否启用自动模式都会显示
		if(kag.fullScreen && y == 0 && menuBarState){// 全屏且移动到顶端显示, 1 和-1 都是true
			changeTempMenuState(true);
		}else if(isTempMenuShowing)// 否则显示状态隐藏
		{
			changeTempMenuState(false);
		}
	}

	var _ncCaptionClick = false;// 是否右键点击过标题栏
	function onNcMouseDown(x, y, btn, ht){
		_ncCaptionClick = (btn == mbRight && ht == Window.nchtMenu);
		if ( btn == mbMiddle && (ht == Window.nchtCaption || ht == Window.nchtMenu )) {	// 中键点击标题可切换方式
			toggleMenuBarState();
		}
	}
	function onNcMouseUp(x, y, btn, ht){
		if (_ncCaptionClick && btn == mbRight && ht == Window.nchtMenu && menuBarRightClickEnabled) {
			var pop = MenuItem.popupEx(tpmRightButton, void, void, kag, void, menus.menuBarHidePopupMenu);
			if (pop !== void) {
				changeMenuBarState(pop.state);
			}
		}
		_ncCaptionClick = false;
	}
	function onNcMouseMove(x, y, ht){
		if(menuBarState != -1)return;	// 目前需要为自动状态
		changeTempMenuState(true);
	}

	// 按下alt时显示临时菜单
	function onStartKeyMenu(key){
		// 同时按下了其他键  或已经处于显示状态	或 禁止菜单显示状态
		if (key || isTempMenuShowing || kag.menu.visible || menuBarState==0 )	
			return;
		changeTempMenuState(true,true);
	}

	function onExitMenuLoop() {		
		if(!_usingkey)return;	// 只会考虑键盘导致的开启,防止干扰鼠标事件
		changeTempMenuState(false);
	}
	/** 
	* @description: 屏幕模式变更后
	* 更新全屏窗口菜单的勾选状态  更新全屏模式下动态菜单的状态
	* @param isFull	是否全屏
	* @return 
	*/	
	function onAfterChangeScreenMode(){
		if(kag.fullScreen){
			kag.menu.visible = false;
			var min = kag.exEventEnabled ? 1:-1; // 非模拟全屏禁用最小化按钮
			kag.menu.visible =  false;
			updateMenuBarState();
			setWindowControlMenu(kag, min, 0, 1, 1);
			menus.fullScreenMenuItem.checked = true if (typeof menus.fullScreenMenuItem == "Object");
		}
		else{
			kag.menu.visible = menuBarState>0;
			setWindowControlMenu(kag,0,0,0,0);	
			updateMenuBarState();
			menus.windowedMenuItem.checked = true if (typeof menus.windowedMenuItem == "Object");
		}
		updateResizeMenuItems();
	}

}

	
addAfterInitCallback(function() {
	global.SystemMenuManager = new MenuManager();
	SystemMenuManager.createKagMenus();
	kag.addPlugin(SystemMenuManager);
	with (SystemMenuManager) {
		
		//---------TODO 下面这要改-----
		//	//	创建存档的子菜单
		//

		// ウィンドウサイズのメニューにチェックを入れる		检查窗口大小的菜单
		._updateWindowResMenu(.menus.winResMenu);
		.menus.winResMenu.enabled = .menus.windowedMenuItem.checked;
		.menus.disableWindowResizeMenuItem.visible = (typeof kag.registerExEvent != "undefined");
//		.cancelAutoByClickMenuItem.checked = .cancelAutoWhenClick;
	
		//这个是设置菜单的位置  先放着
		/*if (!global.SystemConfig.disableTroubleShootMenuFlatten) {	
			var cnt = .videoOverlayModeMenu.children.count;
			resetSysArgRadioMenuParent("troubleShootMenu", "vomstyle");
		}*/

		// 画面効果メニューにチェックを入れる		勾选画面效果菜单   先放着
		/*.updateEffectButton();
		.effectCheckMenuItem.checked = !.noeffect;*/
		
		
		// SystemConfig.disableDisplayMenuInMoviePlaying = true の時  时
		// ムービー再生時は画面設定を変更できない		播放影片时不能更改画面设置
		.onMovieStatusChanged = function(state, id) {	// TODO 以后可以改成拆开，菜单和callhook分开
			if (SystemConfig.disableDisplayMenuInMoviePlaying) {
					.displayMenu.enabled = !this.isMoviePlaying();
			}
			callHook("onMovieStatusChanged", state, id);
		} incontextof kag;

        //TODO 以后看下是啥不需要了
		// video タグの乗っ取り : volume のデフォルト値を bgmvolume にする	夺取video标签：将volume的默认值设为bgmvolume
		/* Movie.tjs で対応するようにしたので不要になった		因为用Movie.tjs来处理所以不需要了
		.origVideoTagHandler = .tagHandlers.video;
		.tagHandlers.video = function(elm) {
			if (typeof elm.volume == "undefined" && !elm.noautovolume)
				elm.volume = (bgmenable && waveenable ? (bgmvolume * wavevolume / 100) : 0);
			return origVideoTagHandler(elm);
		} incontextof kag;
		  */
		// キーボードフックを登録		注册键盘钩子
		kag.keyDownHook.add(keyFunc);

		// スクリーン変更後処理を登録	注册屏幕更改后处理			   
		setDelayedTrigger("resetScreen", .resetScreen);// 先放着吧
		kag.addHook("onAfterChangeScreenMode", function {
			try {
				invokeDelayedTrigger("resetScreen");
			} catch {}
		} incontextof global);

		
		if (!debugEnabled) return;
		/*.addHook("onModeChangeHook", function {
            try { selectAutoLabelStoreMenuItem.enabled = backToAutoLabelStoreMenuItem.enabled; } catch {}
        } incontextof kag);*/
		
	}
},global);






/** 
 * @description:  对应更新系统设置页的方法，先放着
 * @param name
 * @return 
 */
function systemUpdate(name) {
}
// 考虑要不要加入的函数
//function resetSysArgRadioMenuParent(name, tag, index) { 迁移整个菜单
//clickMenuItem  点击菜单项
//setDefaultSystemArgument 设置默认值

//TODO	临时菜单 导致 resize的问题 可以考虑解决， 使用不同配置的测试  setMenuAccessibleAll 这个也要改下   