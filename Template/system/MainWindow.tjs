//;# MainWindow.tjs - KAG メインウィンドウ
//;# Copyright (C)2001-2006, W.Dee and contributors  改変・配布は自由です

try { Plugins.link("windowEx.dll"); } catch {}	// 插件加载顺序有要求，不要随意更改此位置
// メニュー変更処理用  菜单变更后处理用的

var currentDialog;
var conductorStatus;

var SKIP_NONE = 0; //不快进
var SKIP_CLICK = 1; //废弃
var SKIP_PAGE  = 2; //点击快进
var SKIP_STOP  = 3; //自动快进
var SKIP_CTRL  = 4; //ctrl键快进
var SKIP_FORCE = 5; // 特殊强制快进
var SKIP_FAST = 6; // 无演出快进
class ActionWindow extends Window,ActionBase{
	function ActionWindow(){
		Window(...);
	}
	function finalize(){
		global.Window.finalize(...);
	}
}
class KAGWindow extends ActionWindow
{
	// KAG のウィンドウ クラス
	// KAG の動作のメインな部分はここに記述してある

	// 以下のうち、/*C*/ のつく変数は、末端の perl スクリプトによって
	// 自動的に栞にコピーされるコードが生成される変数

	var scWidth = 640; // 画面横幅								画面宽度
	var scHeight = 480; // 画面縦幅								高度

	var aboutWidth = 320; // 「このソフトについて」ウィンドウの横幅   关于窗口的宽度
	var aboutHeight = 200; // 同縦幅								高度

	var isFirstProcess = true; // 一番最初の process の呼び出しかどうか			是否第一次呼叫process

	var freeSaveDataMode = false; // 栞をメニューバーなどで管理せずに、個別のファイルとして管理する   自定义存档模式
	var saveThumbnail = false; // サムネイルを保存するかどうか										是否保存缩略图
	var thumbnailWidth = 133; // サムネイルの横幅													缩略图宽度
	var thumbnailDepth = 8; // サムネイルのBMPモード。8か24											缩短图bmp模式（色深），8或24
		// サムネイルの フルカラー化およびサイズフリー化のパッチは 缩略图的全色化和尺寸自由化的补，我是抄这个人的
		// ゆん氏からいただきました。
		// この場を借りてお礼申し上げます。

	var snapshotLayer = void; // 画像のスナップショットを一時的に保存するレイヤ							临时保存图像快照的层
	var snapshotLockCount = 0; // ロックカウント													锁定计数

	var lastSaveDataNameGlobal = ""; // 最後に保存したフリーセーブモードでのファイル名					上次保存的自由保存模式下的文件名	
	/*C*/var lastSaveDataName = ""; // 最後に保存したフリーセーブモードでのファイル名						同上（非全局）

	var saveDataLocation = "savedata"; // セーブデータ保存場所										保存路径

	var saveDataID = "00000000-0000-0000-0000-000000000000"; // セーブデータの ID					保存的uuid

	var readOnlyMode = false; // 読み込み専用モード(データをディスクに書かない)						只读模式（不将数据写入磁盘）	
	var dataName = "data"; // セーブデータ名														保存数据名
	var saveDataMode = ""; // データ保存モード( "c" で暗号化 )										数据保存模式（用“c”则加密）

    
	var maxHistoryOfStore = 1; // 通過記録の最大数													通过记录的最大数
	var historyOfStore = []; // 通過履歴データ														通过履历数

	var stablePosibility = false;
		// 栞を保存可能なラベル間で stable になる可能性があるかどうか									在可存档的标签之间是否有可能成为stable状态

	var fullScreened = false; // 現在フルスクリーンかどうか												当前是否全屏

	var isMain = true; // これがメインウィンドウかどうか												这是否是主窗口
	var isStayOnTop = false;
	var askOnClose = true; // 終了時に終了するかをユーザに聞くかどうか									是否询问用户结束时是否结束

	var helpFile = ""; // 「ヘルプ > 目次」で開くファイル												在帮助>目录中打开的文件

	var quakeTimer; // quake 用のタイマ																	震动的定时器
	var defaultQuakeTimeInChUnit = false;																
	/*C*/var quaking = false; // 揺れているか															是否在震动中
	/*C*/var quakeEndTick = 0; // 揺れを終了させる tick													结束震动时间戳
	/*C*/var quakeHorzMax = 0; // 横振幅																横向震动幅度		
	/*C*/var quakeVertMax = 0; // 縦振幅																纵向振幅
	/*C*/var quakePhase = 0;

	var chDefaultAntialiased; // 文字にアンチエイリアスをかけるかどうか									默认是否抗锯齿
	var chDefaultFace = %[]; // 文字のデフォルトのフォント													默认字体
	var chUserFace = %[]; // 用户选择的字体
	function getFontFace(lan = SystemLanguage.mainLan){
		if(isBlank(chUserFace[lan])){
			return chDefaultFace[lan];
		}else{
			return chUserFace[lan];
		}
	}
    var initialMessageLayerVisible = true;

	var historyLayer; // メッセージ履歴レイヤ														履历层
	var backHistoryLayer; // メッセージ履歴レイヤ														履历层
	/*C*/var historyWriteEnabled = true; // メッセージレイヤに文字を出力するか						是否将字符输出到消息层		
	/*C*/var historyEnabled = true; // メッセージ履歴レイヤを表示可能か								是否可以显示消息历史记录层
	var historyShowing = false; // メッセージ履歴レイヤを表示中か									履历层是否显示中

    var selectPrevSkipMode;
    var selectPrevAutoMode;
    
    var selectLayer;           // 選択肢レイヤ													选择分支层
    var selectShowing = false; // 選択肢レイヤが表示中か										选择分支层是否在显示中

    var mapSelectLayer;           // マップ選択肢レイヤ											地图选择支层
    var mapSelectShowing = false; // マップ選択肢レイヤが表示中か								地图选择支层是否在显示中
    
	/*C*/var numCharacterLayers = 0; // 前景レイヤの数											前景层数
	/*C*/var numMessageLayers = 1; // メッセージレイヤの数										消息层数
	/*C*/var numUiLayers = 2; // ui层数

    /*C*/var messageFadeTime = 500; // メッセージレイヤの表示ON/OFF の時間							消息层渐入渐出时间
	var exEventEnabled = false; // registerExEvent されたかどうか		是否用windowEx启用了额外的事件

    var fore = %[]; // 表レイヤ																	表层
	var back = %[]; // 裏レイヤ																	里层
	var _primaryLayer; 	// 	主图层，因为主图层无法移动而置于最后 							

	var sysBase;		//	主图层
	var scPositionX = %[]; // 立ち絵の中心座標(X)													立绘的中心坐标

	var tempLayer = void; // 一時的なレイヤ															临时图层

	var clickWaiting = false; // クリック待ちかどうか													是否等待点击

	var mainConductor; // メインのコンダクタ															主指令控制器
	var extraConductor; // 予備のコンダクタ																预备指令控制器	
	var conductor; // 現在のコンダクタ																	目前的指令控制器
	var usingExtraConductor = false; // 予備のコンダクタを使用中かどうか								预备指令控制器是否在使用中
	var onExtraConductorReturn; // extraConductor から通常のコンダクタに戻るときによぶ関数			从extraConductor返回到普通控制器时调用的函数		

	var tagHandlers; // タグのハンドラ群辞書配列												指令处理器的对应字典

	var saveMacros = true; // マクロを栞に保存するかどうか										是否将宏保存到书签

	var current; // 現在操作中のメッセージレイヤ		现在操作的消息层
	var facemode = true;//	是否同步面部表情到消息层?		
	/*C*/var currentNum; // 現在操作中のメッセージレイヤ番号									现在操作的消息层序号
	/*C*/var currentPage; // 現在操作中のメッセージレイヤのページ(表0/裏1)							现在操作的消息层的页数（0表层/1里层）
	/*C*/var currentWithBack = false; // 裏画面にも文字を描画するかどうか							是否在里消息层进行绘制

	var bgm; // BGM オブジェクト																bgm对象

    var numSEBuffers = 1; // 効果音バッファの数													音效buffer数目
	var se = []; // 効果音バッファオブジェクト													音效buffer的对象数组

	var numVoiceBuffers = 10;
	var voices = []; // ボイス音バッファオブジェクト				语音缓存对象

	// ボイスの再生状態(0～1.0)			声音播放状态（进度）（0到1.0）
	var _lastVoicePlayingRatio = -1; // -1はボイス未再生状態／onVoiceStartで0になり加算されていく			-1为 语音未播放状态/onVoiceStart为0 并被相加
	function resetVoicePlayingRatio() {
		if (_lastVoicePlayingRatio < 0) _lastVoicePlayingRatio = 0;
	}
	property voicePlayingRatio {	// 语音播放的进度比例
		getter() {
			var total = 0;
			var size  = 0;
			var max = Math.max;
			for (var i=0;i<voices.count;i++) {
				var voice = voices[i];
				if (voice.type == 0  && voice.status == "play") {
					total = max(total, voice.totalTime);
					size  = max(size, voice.position);
				}
			}
			var plugs = [];
			callHook("getVoicePlayingObject", plugs); // for speech plugins
			if (plugs.count > 0) {
				var obj;
				while ((obj=plugs.shift()) !== void) {
					total = max(total, obj.totalTime);
					size  = max(size,  obj.position);
				}
			}
			if (total > 0) {
				if (size > total) size = total;
				var r = size / total;
				r = Math.max(r, _lastVoicePlayingRatio);
				return (_lastVoicePlayingRatio = r);
			} else {
				if (_lastVoicePlayingRatio >= 0) _lastVoicePlayingRatio = 1;
			}
			return _lastVoicePlayingRatio >= 0 ? _lastVoicePlayingRatio : 0;
		}
	}

	// 待ち状態(0～1.0)	等待状态（进度）（1-1.0）
	var _lastWaitingRatio;
	property waitingRatio {
		getter() {
			with (mainConductor) {
				if (.waitStartTick !== void && .waitTimeout > 0) {
					_lastWaitingRatio = 1.0;
					var size = System.getTickCount() - .waitStartTick;
					var total = .waitTimeout;
					if (size > total) size = total;
					return size / total;
				}
			}
			return _lastWaitingRatio;
		}
	}

    // システムが使えるSEを返す（ロード時に破壊されない)										返回系统可以使用的音效buffer
    property sysse {
        getter() {
            return se[numSEBuffers];
        }
    }
	// 次のテキスト表示の前に全ボイスをカット		在下一个文本显示之前停止所有声音
	/*C*/var voicecut = false;
    // ボイス再生時に bgm をダウンさせる		播放声音时bgm下降
    /*C*/var bgmdown = false;
    /*C*/var bgmdownlevel = 50; // 下げる率(%)		下降率
	

	property primaryLayer { getter { return sysBase ? sysBase : _primaryLayer; } };
    
	var numMovies = 1; // ムービーオブジェクト数											movie对象的数量
	var movies = []; // ムービーオブジェクト													movie对象数组

    function isMoviePlaying() {																//movie是否正在播放
        for (var i=0;i<numMovies;i++) {
            if (movies[i].canWaitStop) {
                return true;
            }
        }
        return false;
    }
    
	var transCount; // 現在進行中のトランジションの数											现在进行中的渐变数目
    
	var chSpeeds = %[																		//文字显示速度
		fast: 10, // 「高速」文字表示スピード
		normal: 30, // 「普通」文字表示スピード
		slow: 50, // 「遅い」文字表示スピード
		];

	var userChSpeed = 30; // ユーザの選んだ文字表示スピード										用户选择的文字表述速度
	var userCh2ndSpeed = -1; // ユーザの選んだ 既読部分の文字表示スピード							用户已读文字速度
	var chNonStopToPageBreak = false; // ページ末まで一気に読み進むか ( l タグを無視するか )		是否忽略换页等待（忽略l的指令）	
	var ch2ndNonStopToPageBreak = false; // 既読の部分でページ末まで一気に読み進むか				已读部分直接跳过换页
	/*C*/var chUserMode = true; // 文字表示速度は現在ユーザの選んだものか							目前文字显示速度是否为用户选择的速度
	/*C*/var chSpeed = 30; // 現在の文字表示スピード												目前的文字显示速度
	/*C*/var actualChSpeed = chSpeed; // 実際の文字表示スピード										实际的文字显示速度

	/*C*/var beforeNoWaitActualChSpeed; // nowait に入る前の actualChSpeed							进入不等待模式前的实际速度
	/*C*/var beforeNoWaitChUserMode; // nowait に入る前の chUserMode								进入不等待模式前是否为用户选择文字速度

	/*C*/var clickSkipEnabled = true; // クリックスキップが有効か										点击跳过是否有效
	/*C*/var nextSkipEnabled = true; // 次の選択肢(/未読)まで進むが有効か								直到下个选择支前跳过是否启用

    /*C*/var allskip   = false; // 0:既読のみスキップ 1:全てスキップ									0已读跳过 1全部跳过
    /*C*/var afterauto = false; // 選択後オート   1:継続 0:解除											选择支后auto：1继续 0解除
    /*C*/var afterskip = false; // 選択後スキップ 1:継続 0:解除											选择支后跳过：1继续 0解除
    
    var skipMode = 0; // スキップのモード																跳过模式
		// 0=スキップなし, 1=クリック待ち記号まで, 2=改ページ待ち記号まで, 3=次の停止まで  	0=不跳过，1=到点击等待符号，2=到分页等待符号，3=到下一个停止
		// 4=早送り 5==特殊スキップ処理中									4=快进5==特殊跳过处理中  6 无任何演出的瞬间跳过
		//		因为 l 指令被删除  1 快进模式实际已经被放弃
	var skipStyle; //快进模式 0正常 1快速 	2 文本
	/*C*/var noForceSkipUnread; //	不允许未读跳过 false 无法ctrl跳过  true：可以
    // beginskip 中のスキップモード														beginskip中的跳过模式
    var prevSkipMode;
	property skipNoDispOrFast {
		getter() {
			return  (skipMode >= SKIP_STOP && skipStyle > 0);
		}
	}
    var autoMode = false; // 自動読みすすみモードかどうか									是否为自动读取前进模式
	/*C*/var autoModeWaitVoice = 0;  // autoMode でボイス終了を待つか 0:待つ 1:次ボイス時は待つ 2:待たない	自动模式语音切断:0等待 1下条为语音等待 2不等待
	var nextVoiceFlag = false; // 下次语音状态 true 有语音 false 无语音 
    var autoModePageWait = 350; // 自動読みすすみモード時の改ページ時のウェイト						自动读取前进模式时的换页时的等待时间
	var autoModeLineWait = 50; // 自動読みすすみモード時の行クリック待ち時のウェイト   					自动读取前进模式时的换行时的等待时间
		// 上の二つは、ノーウェイトにしたい場合は 0 ではなくて -4 を指定すること				上面的两个是，如果想要不等待的话，不是指定0而是指定-4

    // 加算処理用基準時間																		加法处理用基准时间
    var autoModeAddWait;
	var _debugLevel;
	property debugLevel {
        setter(v) {
            _debugLevel = v;
            if (mainConductor !== void) {
                mainConductor.debugLevel = v;
                extraConductor.debugLevel = v;
            }
        }
        getter() {
			return _debugLevel;
        }
    }
	// 実際にD3Dモードになっているかどうか		是否为d3d模式
	property isD3D { getter() { return (drawDevice instanceof "DrawDeviceD3D"); }};

	function flushAutoPath() {
		// AutoPathを再構築するためのダミー
		try {
			var dummy = [];
			dummy.save(saveDataLocation + "/" + "savecheck");
		} catch(e) {
		}
	}


    /**
     * 自動待ちに追加時間を加算処理する（ボイス用）													自动等待加上追加时间处理（语音用）
     * @param time 加算時間
     */
    function addAutoWait(time=void) {
        if (time !== void) {
            autoModeAddWait = System.getTickCount() + time;
        } else {
            autoModeAddWait = void;
        }
    }

    /**
     * 自動待ち時間の計算を行う																计算自动等待时间
     */
    function calcAutoModePageWait() {
        if (autoModeAddWait !== void) {
            var waittime = autoModeAddWait - System.getTickCount();
            autoModeAddWait = void;
            if (waittime > 0) {
                return autoModePageWait + waittime;
            }
        }
        return autoModePageWait;
    }
    
	var skipKeyRepressed = false; // return あるいは space キー ( f キーなどではない )  			return或space键（不是f键等）
								// が押されると true になる ( スキップ解除時に false    			被按下时为真（跳跃解除时为假）

	var autoModePageWaits = %[
		fast: 400,  // 自動読みすすみモードの改ページ時 ウェイト「短い」				自动读取前进模式的换页时等待时间“短”
		faster: 700,  // 自動読みすすみモードの改ページ時 ウェイト「やや短い」			....
		medium: 1000,  // 自動読みすすみモードの改ページ時 ウェイト「普通」
		slower: 1300, // 自動読みすすみモードの改ページ時 ウェイト「やや遅い」
		slow: 2000, // 自動読みすすみモードの改ページ時 ウェイト「遅い」
		];

	var autoModeLineWaits = %[
		fast: 180,  // 自動読みすすみモードの行末 ウェイト「短い」					自动读取前进模式的换行等待时间“短”
		faster: 240,  // 自動読みすすみモードの行末 ウェイト「やや短い」			....
		medium: 300,  // 自動読みすすみモードの行末 ウェイト「普通」
		slower: 360, // 自動読みすすみモードの行末 ウェイト「やや遅い」
		slow: 500, // 自動読みすすみモードの行末 ウェイト「遅い」
		];

	/*C*/var canCancelSkipByClick = true; // クリックによりスキップ状態のキャンセルができるか				单击是否可取消跳过状态


	var timeOrigin; // resetWait で設定された時間原点													在resetWait中设置的时间原点
	var lastWaitTime; // wait mode=until で実際に待った時間												在wait mode=until中实际等待的时间

	var stableHandlers = []; // システムが安定(クリック待ち/停止)したときに呼ばれる							系统stable状态（等待/停止单击）时调用的函数
	var runHandlers = []; // システムが走り始めたときに呼ばれる												当系统开始运行时调用的函数
	var inStable = true; // 安定しているとき(走行中でないとき) true											稳定时（未运行时）true	
	var inSleep = false; // s タグで停止しているとき true													s标记停止时为真

	var updateBeforeCh = 0; // 文字を描画する前にいったん画面描画に入るかどうかのカウント					在绘制文字之前是否进入画面绘制的计数

	var messageLayerHiding = false; // ユーザによりメッセージレイヤが隠されているか							用户是否隐藏了消息层

	/*C*/var rightClickEnabled = true; // 右クリックが有効か												启用右键单击
	/*C*/var rightClickCall = false; // 右クリックで特定のルーチンを呼ぶか									右键单击可调用特定的脚本
	/*C*/var rightClickJump = false; // 右クリックかで特定のラベルにジャンプするか							右键单击或跳转到特定标签
	/*C*/var rightClickTarget = ""; // 右クリックでの呼び出し先												右键单击调用的目标
	/*C*/var rightClickStorage = ""; // 右クリックでの呼び出し先												右键单击调用的storgae
	/*C*/var rightClickName = "default"; // 右クリックのメニュー表示名										右键单击菜单显示名称
	/*C*/var rightClickCurrentMenuName = ""; // 右クリックのメニューに現在設定されている名前				右键单击菜单中当前设置的名称
	var rightClickDefaultName = ""; // 右クリックのデフォルトのメニュー表示名

	var inSleepBeforeExtraConductor; // extraConductor を使用する直前が inSleep だったか					使用extraConductor之前是否为inSleep

	// 通常のマウスカーソル		一般状态的鼠标光标
	/*C*/var cursorDefault = crArrow;  // 通常のマウスカーソル													一般状态下的鼠标光标
	/*C*/var cursorPointed = crHandPoint;  // ボタン、リンク等をポイントした時のマウスカーソル					点了按钮、链接等时的鼠标光标
	/*C*/var cursorWaitingClick = crArrow;  // クリック待ちのマウスカーソル										单击等待鼠标光标
	/*C*/var cursorDraggable = crSizeAll; // ドラッグ可能な場所用のマウスカーソル								可拖动位置的鼠标光标

	/*C*/var startAnchorEnabled = false; // 「最初に戻る」が使用可能かどうか									“返回开头”是否可用

	/*C*/var storeEnabled = true; // ユーザが「栞をはさむ」メニューにアクセス可能かどうか							用户是否可以访问“保存存档”菜单
	/*C*/var restoreEnabled = true; // ユーザが「栞をたどる」メニューにアクセス可能かどうか							用户是否可以访问“查找书签”菜单
    /*C*/var currentStorage = ""; // 現在のラベル																	现在的剧本
    /*C*/var currentLabel = ""; // 現在のラベル																		现在的标签
	/*C*/var currentPageName = ""; // 現在のページ名																现在的页面名
	var currentRecordName = ""; // 現在の記録名 ( trail_ストレージ_ラベル )											当前记录名称（trail_存储_标签）		
	var currentTextNum = 0; // 当前剧本的记录位置	

	var numBookMarks = 10; // メニューに用意する栞のサブメニュー項目の数											菜单中准备书签的子菜单项目的数量
	var showBookMarkDate = false; // メニューに栞をはさんだ日付時刻を表示するか										是否在菜单上显示书签中的日期时间

    var bookMarkDateSecond = false; // 日付に秒までふくめるか														是否在日期中包含秒

	var bookMarks = []; // 存档标签

	var showFixedPitchOnlyInFontSelector = false; // フォント選択で固定ピットフォントのみを表示するか				在字体选择中仅显示等宽字体	

	var flags = %[]; // フラグ(ユーザ)												用户使用变量(不会放入存档中,只是开放用于用户使用)
	var pflags = %[]; // 「保存可能なラベル」を通過した時点でのフラグ(ユーザ)			存档变量(用户)通过可保存的标签时(真正放入存档文件的变量，用户变量放入此变量时才能够完成存储)
	var pcflags = %[]; // 〃 (コア)																				存档变量（核心）
	var sflags = %[]; // システム変数領域(ユーザ)																	系统变量(用户)
	var scflags = %[]; // システム変数領域(コア)																	系统变量（核心）
	var tflags = %[]; // 一時フラグ																				临时变量

	var tempBookMarks = []; // 一時的に保存した栞																	临时保存存档

	var clickCount = 0; // 左クリックカウント																		点击次数
	var lastMouseDownX; // 最後にクリックされた X 座標																最后点击x坐标
	var lastMouseDownY; // 最後にクリックされた Y 座標																最后点击y坐标

	var mouseKeyEnabledCount = 0; // マウスキーが有効かどうか													鼠标键是否有效							

	var kagPlugins = []; // KAG プラグイン																		插件

	var keyDownHook = []; // キーが押されたときに呼び出される物														按键时呼叫的
	var leftClickHook = []; // 右クリックされたときに呼び出される物													右击时呼叫的
	var rightClickHook = []; // 左クリックされたときに呼び出される物												左击时呼叫的
	var mouseMoveHook = []; // マウス移動で呼び出される物								鼠标移动时调用函数	

	var padKeyMap; // パッドボタン -> ハンドラ(キーコード)。コンストラクタ内で設定									手柄按钮-》处理器（虚拟键码），构造函数内设置
	var padKeyMapReverse; // キーコード -> パッドボタン。コンストラクタ内で設定										虚拟键码-》手柄  构造函数内设置


	var holdPeriodEventQueue = [];	// 保留にされたムービーのピリオドイベントキュー									挂起视频的周期事件队列
	var isLeavePeriodEvent = false;	// ムービーのピリオドイベントを保留にするかどうか								是否保留视频的周期事件
	var isWaitPeriodEvent = false;	// ムービーのピリオドイベント待ち状態かどうか									是否等待影片的周期事件
	var waitedPeriodEventStorageName = void;	// ピリオドイベント待ちをコールしたストレージ名						调用等待周期事件的storage名称


    // ------------------------------------------------------ 回想再生処理								回放重播处理

    var recollectionBookmark = 5000; 
    var recollectionEndLabel; // 回想終了を示すラベル													回想重播的标志
    var recollectionStorage;  // 回想終了時の遷移先ストレージ											回想重播的结束时移动的storage			
    var recollectionTarget;   // 回想終了時の遷移先ターゲット											回想重播的结束时移动的目标标签

    /**
     * 回想中かどうか			是否在回想中
     */
    property isRecollection {
        getter() {
            return recollectionEndLabel !== void;
        }
    }

	 // プレイ時間		游玩时间
    var _playTime;
    var _playStartTime = (new Date()).getTime();

    function clearPlayTime(initTime = 0) {
        _playTime = initTime;
        _playStartTime = (new Date()).getTime();
    }
    
	property borderStyle {
		getter { return super.borderStyle; }
		setter(v) {     super.borderStyle = v; if (typeof this.resetExSystemMenu == "Object") this.resetExSystemMenu(); }	// borderStyle变化时 系统菜单会消失所以要重置
	}

    /**
     * 回想モード実行を開始する			开始回想模式
     */
    function startRecollection(elm) {
        if (elm.no !== void) {
            var num = (int)elm.no;
            // ロード処理中も isRecollection を有効にするためとりあえず設定
            recollectionEndLabel = true;
            if (loadBookMark(recollectionBookmark + num)) {
                // ロード処理で消されてるのでもう一度設定
                recollectionEndLabel = "*kaisouEnd" + num;
                recollectionStorage  = elm.doneStorage;
                recollectionTarget   = elm.doneTarget;
            } else {
                process(elm.doneStorage, elm.doneTarget);
            }
        } else if (elm.storage !== void || elm.target !== void) {
            process(elm.storage, elm.target);
            recollectionEndLabel = "*kaisouEndStorage";
            recollectionStorage  = elm.doneStorage;
            recollectionTarget   = elm.doneTarget;
        }
    }

    /**
     * 回想モード実行を終了する			回想结束时的跳转
     */
    function endRecollection() {
        // 回想終了処理
        if (isRecollection) {
            var ret = -1;
            if (recollectionStorage != '' || recollectionTarget != '') {
                // 実行を登録アドレスに移す
                if (recollectionStorage != '') {
                    conductor.loadScenario(recollectionStorage);
                }
                if (recollectionTarget != '') {
                    conductor.goToLabel(recollectionTarget);
                }
                inSleep = false;
                notifyRun();
                if (conductor.status != conductor.mRun) conductor.run();
                ret = 0;
            } else {
                // 実行停止
                stablePosibility = true;
                cancelSkip();
                isSleep = true;
                notifyStable();
            }
            stopRecollection();
            return ret;
        }
        return 0;
    }
    
    function stopRecollection() {
        recollectionEndLabel = void;
        recollectionStorage = void;
        recollectionTarget  = void;
    }
    
	//------------------------------------------------------ ダイアログレイヤ処理 -- 对话层处理

	var currentDialogAbsolute = 9000000;
	var currentDialogFocusedRestore; // フォーカス状態を記録しておく		记录聚焦状态

	function handleOpenDialog() {
		if (currentDialog !== void) {
			stopAllTransitions();
			cancelSkip();
			with (currentDialog) {
				.enabled = true;
				.focus();
				.setMode();
				.onOpen();
			}
		}
    }
	 function handleCloseDialog() {
		if (!this isvalid) return;
		if (currentDialog !== void) {
			with (currentDialog) {
				.removeMode();
				.visible = false;
			}
			invalidate currentDialog;
			currentDialog = void;

			var restore = currentDialogFocusedRestore;
			if (typeof restore == "Object" && (restore == null || isvalid restore)) {
				try   { focusedLayer = restore; }
				catch { focusedLayer = null; }
			}
		}
		onModeChange() if (this isvalid);
	}

	function openDialog(dialog) {
		if(dialog === currentDialog)return;
		if (currentDialog !== void) {
            closeDialog();
        }

		callHook("onOpenDialog", dialog);
        mainConductor.interrupted = true;
        extraConductor.interrupted = true;
        onModeChange();
		currentDialog = dialog;
		currentDialogFocusedRestore = focusedLayer;
		with (dialog) {
			.absolute = currentDialogAbsolute;
			.enabled = false;
			.visible = true;
		}

        global.openDialogTrigger = new AsyncTrigger(handleOpenDialog, '');
        global.openDialogTrigger.cached = true;
        global.openDialogTrigger.trigger();
		add(global.openDialogTrigger);
    }
	//	关闭对话框
    function closeDialog() {
        if (currentDialog !== void) {
            if (mainConductor.interrupted) {
                mainConductor.interrupted  = false;
            }
            if (extraConductor.interrupted) {
                extraConductor.interrupted = false;
            }
			global.closeDialogTrigger = new AsyncTrigger(handleCloseDialog, '');
			global.closeDialogTrigger.cached = true;
			global.closeDialogTrigger.trigger();
        }
    }


    
	//------------------------------------------------------ コンストラクタ --

	function KAGWindow(ismain = true, width = 0, height = 0)
	{
		// コンストラクタ
		// 引数 : ismain : メインウィンドウとして作成されるのかどうか 是否为主窗口
		super.Window(); // 親クラスのコンストラクタを呼ぶ

		// コンフィギュレーション  配置
		isMain = ismain;
		if(ismain)
		{
			(KAGWindow_config incontextof this)();
			(KAGWindow_config_override incontextof this)()
				if typeof global.KAGWindow_config_override != "undefined";
		}

		userChSpeed = chSpeed = actualChSpeed = chSpeeds.normal;
		autoModePageWait = autoModePageWaits.medium;
		autoModeLineWait = autoModeLineWaits.medium;

		askOnClose = false if !ismain;

		// saveDataLocation がフルパスでないようならば System.exePath を 如果saveDataLocation不是完整路径，则添加System.exePath
		// 付け加える
		if(saveDataLocation.indexOf(":") == -1)
			saveDataLocation = System.exePath + saveDataLocation;

		// メニューアイテムの作成			生成菜单	TODO 看看去掉这个
		/*if(ismain) (KAGWindow_createMenus incontextof this)();
		if(typeof this.rightClickMenuItem != "undefined")
			rightClickDefaultName = rightClickCurrentMenuName = rightClickMenuItem.caption;

		if(typeof this.autoModeMediumMenuItem != "undefined")
			autoModeMediumMenuItem.checked = true;
		if(typeof this.windowedMenuItem != "undefined")
			windowedMenuItem.checked = true;
		if(typeof this.chNormalMenuItem != "undefined")
			chNormalMenuItem.checked = true;
		if(typeof this.ch2ndNoChangeMenuItem != "undefined")
			ch2ndNoChangeMenuItem.checked = true;

		if(ismain) (Menu_visible_config incontextof this)();

		createBookMarkSubMenus();	*/

		// ウィンドウ外見の調整    调整窗口外观
		if(ismain)
		{
			caption = System.title;
			if (typeof this.registerExEvent != "undefined") {	// windowEx 加载成功的话
				borderStyle = bsSizeable;
				registerExEvent();				// 注册额外的事件
				exEventEnabled = true;
				setWindowsClickEventHook();	//注册额外消息 menuselect 和modecancel
				if (typeof       global.getSystemMouseCursor == "Object") {	//设置鼠标光标样式
					cursorPointed     = getSystemMouseCursor("Hand",        cursorPointed);
//					cursorWaitingAuto = getSystemMouseCursor("AppStarting", cursorWaitingAuto);
				}
			} else {
				// 拡張イベントなし		无扩展事件
				borderStyle = bsSingle;
			}
		}
		else
		{
			borderStyle = bsDialog;
		}

		// ウィンドウサイズの調整						调整窗口大小
		if(width != 0 && height != 0)
		{
			// 与えられたサイズを適用
			scWidth = width;
			scHeight = height;
		}
		setInnerSize(scWidth, scHeight);
		minWidth = scWidth\4;
		minHeight = scHeight\4;
		// quake 用タイマの作成								生成震动用的定时器
		quakeTimer = new Timer(onQuakeTimerInterval, '');
		add(quakeTimer);
		quakeTimer.interval = 50;


		add(_primaryLayer = new Layer(this, null));
		with (_primaryLayer) {
			.name = "primary Layer";
			.setSize(scWidth, scHeight);
			.fillRect(0,0,.width,.height,0);
			.type = ltOpaque;
			.visible = true;
			//.hasImage = false;
			.onMouseDown = function (x, y, btn) {
				if(window.callHook("onMouseDown",x, y, button))return;
				switch (btn) {
				case mbLeft:  window.onPrimaryClick();      break;
				case mbRight: window.onPrimaryRightClick(); break;
				}
				return (global.Layer.onMouseDown incontextof this)(...);
			} incontextof _primaryLayer;
		}

		// ベースになるレイヤ		非d3d模式下 为primary生成一个子层作为sysbase层
		if (!isD3D) {
			_primaryLayer.hasImage = false;
			sysBase = new Layer(this, _primaryLayer);
			with (sysBase) {
				.setSize(scWidth, scHeight);
				.name = "system base layer";
				.fillRect(0,0,scWidth, scHeight,0);
				.type = ltOpaque;
				.visible = true;
			}
			add(sysBase);
		} else {
			sysBase = null;
		}

		// タグハンドラ/コンダクタを作成		生成主指令处理器和预备指令处理器
		tagHandlers = getHandlers();

		mainConductor = new MainConductor(this, tagHandlers);
		add(mainConductor);
		conductor = mainConductor;
		extraConductor = new DelayConductor(this, tagHandlers);
		add(extraConductor);
		// 指定指令控制器的debug级别
        debugLevel = _debugLevel;


		// 背景レイヤの作成						生成背景层
		fore.messages = [];
		back.messages = [];
		fore.layers = [];
		back.layers = [];
		fore.uiLayers = [];
		back.uiLayers = [];

        fore.base = new BaseLayer(this, primaryLayer, "fore-background");//背景层的表层是主图层
        add(fore.base);
		fore.base.visible = 1; // z 之后这个不是主图层，不会默认显示
		fore.base.absolute = 1;
        fore.base.setImageSize(scWidth, scHeight);
        fore.base.setSizeToImageSize();
        back.base = new BaseLayer(this, primaryLayer, "back-background");
        add(back.base);
		back.base.absolute = 1;
        back.base.setImageSize(scWidth, scHeight);
		back.base.setSizeToImageSize();
        fore.base.setCompLayer(back.base);
		back.base.setCompLayer(fore.base);
		fore.base.freeImage();
		back.base.freeImage();
	
		fore.base.setDefaultCursor(cursorDefault);
		back.base.setDefaultCursor(cursorDefault);

		// ui图层 注意ui图层和base图层是同级层  TODO 以后考虑专门做一个ui图层的类
		fore.ui = new UiLayer(this, primaryLayer, "fore-ui");
		fore.ui.type = ltAlpha;
        add(fore.ui);
		fore.ui.absolute = 10;
        fore.ui.setImageSize(scWidth, scHeight);
        fore.ui.setSizeToImageSize();
        back.ui = new UiLayer(this, primaryLayer, "back-ui");
		back.ui.type = ltAlpha;
        add(back.ui);
		back.ui.absolute = 10;
        back.ui.setImageSize(scWidth, scHeight);
		back.ui.setSizeToImageSize();

        fore.ui.setCompLayer(back.ui);
		back.ui.setCompLayer(fore.ui);
		fore.ui.fillRect( 0, 0, scWidth, scHeight, 0);
		back.ui.fillRect( 0, 0, scWidth, scHeight, 0);
		fore.ui.visible = true; 


        // 舞台レイヤ 背景レイヤの上			生成舞台层
        fore.stage = new StageLayer(this, fore.base, "表-舞台", "stage");
        add(fore.stage);
        fore.stage.setImageSize(scWidth, scHeight);
        fore.stage.setSizeToImageSize();
        fore.stage.absolute = 100;
        back.stage = new StageLayer(this, back.base, "裏-舞台", "stage");
        add(back.stage);
        back.stage.setImageSize(scWidth, scHeight);
        back.stage.setSizeToImageSize();
        back.stage.absolute = 100;
        fore.stage.setCompLayer(back.stage);
		back.stage.setCompLayer(fore.stage);
		fore.stage.freeImage();
		back.stage.freeImage();
        
        // イベントレイヤ メッセージレイヤの下      事件层  消息层之下
        fore.event = new StageLayer(this, fore.base, "表-事件", "event");
        add(fore.event);
        fore.event.setImageSize(scWidth, scHeight);
        fore.event.setSizeToImageSize();
        fore.event.absolute = 6 * 100000 - 100;
        back.event = new StageLayer(this, back.base, "裏-事件", "event");
        add(back.event);
        back.event.setImageSize(scWidth, scHeight);
        back.event.setSizeToImageSize();
        back.event.absolute = 6 * 100000 - 100;
        fore.event.setCompLayer(back.event);
		back.event.setCompLayer(fore.event);
		fore.event.freeImage();
		back.event.freeImage();
        
		// メッセージ履歴レイヤの作成
        historyLayer = new HistoryLayer(this, fore.ui);
		
        backHistoryLayer = new HistoryLayer(this, back.ui);

        historyLayer.name = "fore history layer";
        backHistoryLayer.name = "back history layer";
		historyLayer.setCompLayer(backHistoryLayer);
		backHistoryLayer.setCompLayer(historyLayer);
		add(historyLayer);
		add(backHistoryLayer);

        // 選択肢レイヤの作成
        selectLayer = new SelectLayer(this, fore.base);
        selectLayer.name = "选项层";
        add(selectLayer);

        // マップ選択肢レイヤの作成
        mapSelectLayer = new MapSelectLayer(this, fore.base);
        mapSelectLayer.name = "地图选项层";
        add(mapSelectLayer);
        
		// 前景レイヤの作成
		allocateCharacterLayers(numCharacterLayers);

		// メッセージレイヤの作成			生成消息层
		allocateMessageLayers(numMessageLayers, false);
		allocateUiLayers(numUiLayers);

		current = fore.messages[0];
		currentNum = 0; 
		currentPage = 0; //现在操作的是表消息层
		currentWithBack = false;
		if(initialMessageLayerVisible)
		{
			fore.messages[0].visible = true;
			back.messages[0].visible = true;
		}
		
		if(typeof this.chAntialiasMenuItem != "undefined")//todo 菜单相关的去掉
			chAntialiasMenuItem.checked = chDefaultAntialiased;


		// BGM オブジェクトを作成	生成bgm对象
		bgm = new BGM(this);
		add(bgm);

		// 効果音オブジェクトを作成		生成效果音对象
        for(var i = 0; i < numSEBuffers+1; i++)
            add(se[i] = new SESoundBuffer(this, i));
		
		// ボイスオブジェクトを生成				生成语音对象
		for(var i = 0, cnt = numVoiceBuffers; i < cnt; i++) {
			add(voices[i] = new VoiceSoundBuffer(this, i));
		}
		initLoopVoice();
		setupSoundGain() if (typeof this.setupSoundGain == "Object");
		// ムービーオブジェクトを作成		生成视频对象
		if(ismain)
		{
			for( var i = 0; i < numMovies; i++)
				add(movies[i] = new Movie(this,i));
		}

		// デフォルトのハンドラを追加	添加默认的处理器
		stableHandlers.add(defaultStableHandler);
		runHandlers.add(defaultRunHandler);

		// システム変数を反映	//从数据文件中读取系统配置 
		if(ismain)
		{
			loadSystemVariables();
			setSystemStateFromSystemVariables();	
		}

		// メッセージレイヤのクリア		清空消息层
		clearMessageLayers(false);

		// コンソール表示状態もついでに復帰		控制台显示状态也顺便恢复
		if (debugEnabled) with (Debug.console) try {
			var vis   = +scflags.consoleVisible;
			var place =  scflags.consolePlacement;
			.visible = vis;
			if (vis && typeof place == "Object") {
				var x, y, w, h;
				with (place) x=.left, y=.top, w=.width, h=.height;
				// .setPos(x, y, w, h);
				.left =x,.top=y,.width = w,.height=h;
			}
		} catch {}


		
		var desktop,screen;
		with (System) {
			// モニタ情報の取得		取得显示器信息
			desktop = %[   x:.desktopLeft,   y:.desktopTop,
							   w:.desktopWidth,  h:.desktopHeight ];
			screen  = %[   x: 0,             y: 0,
							   w:.screenWidth,   h:.screenHeight  ];
			// 使用WindowEx插件时 则使用该插件
			if (typeof .getMonitorInfo != "undefined") {
				var info = .getMonitorInfo(true, left,top ,scWidth ,scHeight );
				if (typeof info == "Object") {
					(Dictionary.assign incontextof desktop)(info.work,    true);
					(Dictionary.assign incontextof screen )(info.monitor, true);
				}
			}
		}

		var windowLeft,windowTop,max,forcefull;
		// 位置を復帰			恢复位置
		with (scflags) {
			windowLeft = .windowLeft   if (.windowLeft    !== void);
			windowTop = .windowTop    if (.windowTop     !== void);
			max = .windowMaximized;
			stayOnTop = isStayOnTop = .isStayOnTop;
		}
		
		
		// 调整缩放状态
		var numer= scflags.zoomNumer, denom = scflags.zoomDenom;
		numer =1 if(isBlank(numer) || numer ==0);
		denom =1 if(isBlank(denom) || denom ==0);
		var zoom = numer / denom;
		var _innerWidth = scWidth * zoom , _innerHeight = scHeight * zoom;     // 缩放后大小
		var screenWidth = screen.w, screenHeight = screen.h;
		if (_innerWidth > screenWidth || _innerHeight >= screenHeight) { // 大于屏幕 
			zoom = numer = denom;	// 先恢复缩放为无缩放
			if (scWidth > screenWidth || scHeight > screenHeight ) {	// 如果仍大于
				// 3/4～1/4 まで縮小できるか試す
				for (numer=3, denom=4; numer > 1; numer--) {
					zoom = (numer / denom);
					if (scWidth*zoom < screenWidth && scHeight*zoom < screenHeight) break;
				}
				forcefull = true;
			}
		}
		setZoom(numer, denom);
		// 居中调整
		if(isBlank(windowLeft) && isBlank(windowTop)) with (desktop) {
			var ox = 0, oy = 0;
			if (typeof   System.getSystemMetrics == "Object") {
				// 边框计算
				var gsm = System.getSystemMetrics;
				ox = gsm("CXSIZEFRAME");
				oy = gsm("CYSIZEFRAME") + gsm("CYCAPTION");
			}
			windowLeft = .x + (.w - innerWidth)\2 - ox;
			windowTop = .y + (.h - innerHeight)\2 - oy;
		}
		windowResizeable = scflags.windowResizeable;
		//	调整窗口位置
		var mw = innerWidth\3, mh = innerHeight\3; // 位置修正的高宽
		with (desktop) {
			windowLeft = .x+.w - innerWidth if (windowLeft + mw > .x+.w);	// 右边没有漏出1/3 则重设
			windowLeft = .x        if (windowLeft + innerWidth - mw < .x );// 左边
			windowTop = .y + .h - innerHeight if (windowTop + mh > .y+.h); // 下面
			windowTop = .y if (windowTop <.y ); //标题栏藏起来的话就麻烦了
		}
		setPos(windowLeft, windowTop);
		maximize() if (max && typeof this.maximize != "undefined");
		
		// パッドボタンハンドラの作成	生成手柄按键映射
		createPadKeyMap();

		if(ismain)
		{
			visible = true;
			if( forcefull || //画面尺寸比窗口尺寸小的情况下试着全屏
				(scflags.fullScreen !== void && +scflags.fullScreen) )//上次启动时是全屏的情况下试着全屏  
				changeFullScreenOrWindow(true);
			saveSystemVariables();
		}

	}

	//------------------------------------------------------------- finalize --

	function finalize()
	{
		// finalize メソッド

		// プラグインの無効化
		for(var i = 0; i < kagPlugins.count; i++) invalidate kagPlugins[i];

		// 前景、メッセージレイヤを無効化
		for(var i = 0; i< fore.layers.count; i++) invalidate fore.layers[i];
		for(var i = 0; i< back.layers.count; i++) invalidate back.layers[i];
		for(var i = 0; i< fore.messages.count; i++) invalidate fore.messages[i];
		for(var i = 0; i< back.messages.count; i++) invalidate back.messages[i];
		for(var i = 0; i< fore.uiLayers.count; i++) invalidate fore.uiLayers[i];
		for(var i = 0; i< back.uiLayers.count; i++) invalidate back.uiLayers[i];
        // 舞台・イベントレイヤを無効化
        invalidate fore.stage;
        invalidate back.stage;
        invalidate fore.event;
        invalidate back.event;
		invalidate historyLayer;
		invalidate backHistoryLayer;
		// snapshotLayer を無効化
		invalidate snapshotLayer if snapshotLayer !== void;

		// tempLayer を無効化
		invalidate tempLayer if tempLayer !== void;

		// スーパークラスの finalize を呼ぶ
		super.finalize(...);
	}

	//-------------------------------------------------- onCloseQuery/close --

    function onCloseYes() {
        shutdown();
    }

	function onCloseQuery()
	{
		saveSystemVariables();
        if(!askOnClose) { super.onCloseQuery(true); return; }
        if (global.currentDialog === void) {
            askYesNo("??", "confirm", onCloseYes);
        }
        super.onCloseQuery(false);
    }

	function close()
	{
		// ウィンドウを閉じる
		saveSystemVariables();
		super.close(...);
	}

	function shutdown()
	{
		// ウィンドウを閉じるが、終了確認を行わない
		// このメソッド内で close をすると、様々な
		// オブジェクトが無効化されてしまい、この
		// 関数から戻った先でエラーが発生する。
		// そのため、いったん AsyncTrigger を介して、
		// 全てのメソッドから帰ったあとにシャットダウン
		// 処理を行う。
		global.shutdownTrigger =
			new AsyncTrigger(handleShutdown, '');
		global.shutdownTrigger.cached = true;
		global.shutdownTrigger.trigger();
		if(conductor.status == conductor.mRun)
			conductor.interrupt();
			// コンダクタが走行中の時は
			// コンダクタに中断を伝える
	}

	function handleShutdown()
	{
		// shutdown() からのシャットダウン要求を
		// 実際に処理するメソッド
		var askOnClose_save = askOnClose;
		askOnClose = false;
		close();
		if(this isvalid) askOnClose = askOnClose_save;
	}

	function closeByScript(elm)
	{
		// ウィンドウを閉じる
		// ちょっと面倒くさいとをやっているのは
		// shutdown と同じ理由
		// 「いいえ」が選択されてウィンドウが閉じなかった場合は
		// 'not_closed' トリガが発行され、実行は再開する。
		var askOnClose_save = askOnClose;
		if(elm.ask !== void && !(+elm.ask)) askOnClose = false;
		global.shutdownTrigger =
			new AsyncTrigger(handleCloseByScript, '');
		global.shutdownTrigger.cached = true;
		global.shutdownTrigger.trigger();

		// closeByScript は、このハンドラが終わった直後に
		// 「終了しますか？」のダイアログを表示する。
		// 終了する場合はそのまま終了する。
		// 終了しない場合は 'not_closed' トリガが発行され、
		// 実行は継続する。
		conductor.wait(%[
			not_closed : askOnClose_save
			? (function
			{
				// 実際にこれが呼ばれることはないが、一応
				askOnClose = true;
			} incontextof this)
			: (function
			{
			} incontextof this)
			]);
	}

	function handleCloseByScript()
	{
		// shutdown() からのシャットダウン要求を
		// 実際に処理するメソッド
		close();
		if(this isvalid) // いいえ が選択された場合
			conductor.trigger('not_closed');
	}

	//------------------------------------------------------ プラグイン処理 --
	/*插件的事件回调，
	method 事件名称
	func 回调的函数，需要两个参数，一个是插件返回的函数，一个是给的参数
	arg 参数
	*/
	function forEachEventHook(method, func, arg*) 
	{
		// すべてのプラグインオブジェクトの method にたいして
		// func を実行する
		// func の引数には各要素と arg が渡される
		if(!kagPlugins.count)return;
		
		var array = [];
		array.assign(kagPlugins); // いったんコピーし、コピーした物に対して実行する
		var arraycount = array.count;
		for(var i =0; i<arraycount; i++)
		{
			var obj = array[i];
			if(typeof obj[method] != "undefined")
				func(obj[method], arg*);
		}
		
	}

	function addPlugin(plugin)
	{
		// プラグインオブジェクトを追加
		kagPlugins.add(plugin);
	}

	function removePlugin(plugin)
	{
		// プラグインオブジェクトを削除
		kagPlugins.remove(plugin);
	}

	//---------------------------------------------------------- hook处理 --
	var hookMap = %[ keyDown:this.keyDownHook, leftClick:this.leftClickHook, rightClick:this.rightClickHook, mouseMove:this.mouseMoveHook ];
	function callHook(tag, *)
	{
		// 文字列を渡されたときはテーブルから参照		传递字符串时从表中引用
		var array = (typeof tag == "String" && tag != "") ? hookMap[tag] : tag;
		if (typeof array != "Object" || array.count <= 0) return false;

		// 順番に呼び出し	按顺序调用
		var processed = false, tmp = [];
		tmp.assign(array);
		for (var i = 0, cnt = tmp.count; i < cnt; i++) {
			var func = tmp[i];
			processed |= func(*) if (typeof func == "Object");
		}
		return !!processed;
	}
	//	注册钩子，每个键对应一个数组，可注册多个钩子
	function addHook(tag, func) {
		var array = tag;
		if (typeof tag == "String" && tag != "") {
			array = hookMap[tag];
			array = hookMap[tag] = [] if (array === void);
		}
		array.add(func) if (typeof array == "Object");
	}
	function removeHook(tag, func) {
		var array = (typeof tag == "String" && tag != "") ? hookMap[tag] : tag;
		array.remove(func, true) if (typeof array == "Object");
	}


	//------------------------------------------ パッドのキーマッピング作成 --

	var initialPadKeyMap = %[
		// パッド入力とそれに対応する動作のマッピング。
		// 標準では十字キーはキーボードのカーソルキーにマッピング、
		// ボタン1 は Return、ボタン2 は ESC、ボタン3 は メッセージ履歴の表示
		// にマッピングされる。
		// 関数を指定した場合はボタンを押したときにはその関数が呼ばれる。
		// 必要に応じて Config.tjs 中で書き換える。
		VK_PADLEFT =>		VK_LEFT,
		VK_PADRIGHT =>		VK_RIGHT,
		VK_PADUP =>			VK_UP,
		VK_PADDOWN =>		VK_DOWN,
		VK_PAD1 =>			VK_RETURN,
		VK_PAD2 =>			VK_ESCAPE,
		VK_PAD3 =>			showHistoryByKey, //#'R',
		];

	function createPadKeyMap()
	{
		// パッド入力とそれに対応する動作のマッピング。
		// 標準では十字キーはキーボードのカーソルキーにマッピング、
		// ボタン1 は Return、ボタン2 は ESC、ボタン3 は メッセージ履歴の表示
		// にマッピングされる。
		// 関数を指定した場合はボタンを押したときにはその関数が呼ばれる。
		/*
			手柄输入及其对应动作的映射。
			标准情况下，十字键映射到键盘上的光标键。
			按钮1被映射到enter，按钮2被映射到ESC，按钮3被映射到消息历史的显示。
			指定函数的情况下，按下按钮时称为该函数
		*/
		padKeyMap = %[
			VK_PADLEFT =>		VK_LEFT,
			VK_PADRIGHT =>		VK_RIGHT,
			VK_PADUP =>			VK_UP,
			VK_PADDOWN =>		VK_DOWN,
			VK_PAD1 =>			VK_RETURN,
			VK_PAD2 =>			VK_ESCAPE,
			VK_PAD3 =>
				function(ev) {
					showHistoryByKey(this);
				},
			];

		// padKeyMapReverse を作成
		padKeyMapReverse = %[];
		var ar = [];
		ar.assign(padKeyMap);
		for(var i = 0; i < ar.count; i += 2)
		{
			if(typeof(ar[i+1]) != "Object")
			{
				padKeyMapReverse[ar[i+1]] = ar[i];
			}
		}
	}

	function getKeyState(key)
	{
		// System.getKeyState 関数と同等だが、パッドのキーに関しても
		// 反応を返す
		var sg = System.getKeyState;
		var state = sg(key);
		if(state) return true;
		var pad_key = padKeyMapReverse[key];
		if(pad_key !== void)
		{
			// キーコード -> パッドのキーコードの変換が見つかった
			return sg(pad_key);
		}
		return false;
	}

	//-------------------------------------------------------------- action --

	function action(ev)
	{
        if(ev.type == 'onKeyDown' && ev.target === this)
		{
            // パッド入力に対応する処理
			var handler = padKeyMap[ev.key];
			if(handler !== void)
			{
				// ハンドラが見つかった
				if(typeof(handler) == "Object")
				{
					// ハンドラは関数
					(handler incontextof this)(ev);
				}
				else
				{
					// ハンドラはキーコード
					postInputEvent('onKeyDown', %[key: handler]);
					postInputEvent('onKeyUp', %[key: handler]);
				}
			}
		}
	}

	//------------------------------------------------------ tempLayer 関連 --

	property temporaryLayer
	{
		// ワークエリアとして一時的に使用できるレイヤを返す
		getter()
		{
			if(tempLayer === void)
			{
				tempLayer = new KAGLayer(this, primaryLayer);
				tempLayer.name = "temporary layer";
			}
			with (tempLayer) {
				.type = ltAlpha;
				.face = dfAuto;
			}
			return tempLayer;
		}
	}
	
	var _lastScreenRect;
	/**
	 * 仮想フルスクリーン用にプライマリレイヤを調整する
	 * @param x 合成用画面の位置
	 * @param y 合成用画面の位置
	 * @param w 合成用画面の横幅
	 * @param h 合成用画面の縦幅
	 * @param プライマリスクリーンの塗りつぶし指定(ズームアウト時ぬっておかないと色が消える)
	 */
	function setScreenRect(x, y, w, h, fill) {
		if (isD3D) {
			drawDevice.setScreenRect(x, y, scWidth, scHeight);
			drawDevice.setPrimarySize(w, h);
			_lastScreenRect = [] if (_lastScreenRect === void); 
			_lastScreenRect[0] = x;
			_lastScreenRect[1] = y;
			_lastScreenRect[2] = w;
			_lastScreenRect[3] = h;
		} else {
			sysBase.setPos(x, y, scWidth, scHeight);
			with (_primaryLayer) {
				.hasImage = true;
				.setSize(w, h);
				.fillRect(0, 0, w, h, 0);
			}
		}
	}
	function getScreenRect() {
		if (isD3D) {
			return _lastScreenRect;
		} else {
			return [ 0, 0, _primaryLayer.width, _primaryLayer.height ];
		}
	}
	//    
	/** 
	* @description: 重设主图层位置
	* @param z	缩放比例
	* @param w	主图层宽度
	* @param h	主图层宽度高度
	* @return 
	*/
	function resetPrimaryPos(z = 0, w, h) {
		if (z > 0) {
			var x = Math.round((innerWidth  - w) / (z*2));	// 偏移量和宽度 也要做相应的缩放
			var y = Math.round((innerHeight - h) / (z*2));
			w = Math.ceil(innerWidth  / z);
			h = Math.ceil(innerHeight / z);
			setScreenRect(x, y, w, h);
		} else {
			setScreenRect(0, 0, scWidth, scHeight);
		}
		//TODO 查看视频的逻辑
		/*if (movieRestoreTimer !== void) with (movieRestoreTimer) {
			if (.enabled) {
				// 再ディレイ
				.enabled = false;
				.enabled = true;
				return;
			}
		}
		onMoviePrimaryPosChanged(primaryLeft, primaryTop);*/
	}

	/** 
	* @description: 是否处于最大化状态，包括 win + -> 的半屏最大化
	* @return 
	*/
	function isMaximizedMode() {
		if (typeof this.maximized != "undefined") {
			var  max =     this.maximized;
			if (!max) {
				// [XXX] Windows+Left/Right で画面半分最大化された場合にはmaximized=falseが返るため
				//       NormalRectとWindowRectを比較して対応
				var normal  = (typeof this.getNormalRect == "Object") ? getNormalRect() : void;
				var current = (typeof this.getWindowRect == "Object") ? getWindowRect() : void;
				if (normal && current) max = (
					(normal.x != current.x) ||
					(normal.y != current.y) ||
					(normal.w != current.w) ||
					(normal.h != current.h));
			}
			return max;
		}
		return false;
	}

	var _zoomNumer, _zoomDenom;
	property origZoomNumer { setter(v) { super.zoomNumer = v; } getter { return tempZoomed ? _zoomNumer : super.zoomNumer; } }
	property origZoomDenom { setter(v) { super.zoomDenom = v; } getter { return tempZoomed ? _zoomDenom : super.zoomDenom; } }
	property tempZoomed    { getter { return _zoomNumer !== void; } }
	function setZoom(numer, denom, resize = true) {
		if (super.fullScreen) return;
		var zn = super.zoomNumer;
		var zd = super.zoomDenom;

		super.setZoom(numer, denom);

		var z = zoomNumer / zoomDenom;
		var w = scWidth  * z;
		var h = scHeight * z;
		if (resize) {
			setInnerSize(w, h);	// 重置窗口大小
			resetPrimaryPos();
			_zoomNumer = _zoomDenom = void;
		} else {
			resetPrimaryPos(z, w, h);
			if (!tempZoomed) {
				_zoomNumer = zn;
				_zoomDenom = zd;
			}
		}
	}

	var _inResizeProcess = false;	// 是否处于重置大小的事件中
	function onResize() {
		if (!isD3D) {
			try { drawDevice.recreate(); } catch {}
		}
		if(callHook("onResize")) // 事件拦截则不处理 ，目前仅用于动态菜单
			return super.onResize();
		if (!minimized && !_inResizeProcess ) { // 非最小化，非已进行中,尝试改变内部区域的大小
			_inResizeProcess = true;
			var numer = innerWidth, denom = scWidth;
			var max = isMaximizedMode(true);
			if (max) {
				var flat = (innerWidth/innerHeight > scWidth/scHeight);
				var zoom = System.getArgument("-fszoom");
				
				switch (zoom) {
				case "outer": flat = !flat; break;
				case "no":    numer = denom = 1; flat = false; break;
				case "middle": // TODO 加上缩放比例的指定
					var per = System.getArgument("-mzpercent");
					per = (per == "") ? 50 : (+per);
					if (per < 0) {
						numer = -per;
						denom = 100;
					} else {
						per = 100 if (per > 100);
						var iw = innerWidth, ih = innerHeight;
						var sw =    scWidth, sh =    scHeight;
						if (flat) iw <-> ih, sw <-> sh;
						numer = (int)(iw + (ih - iw) * per / 100);
						denom = (int)(sw + (sh - sw) * per / 100);
					}
					flat = false;
					break;
				// inner 不用做任何操作,且默认inner
				}
				if (flat) numer = innerHeight, denom = scHeight;	//非扁型窗口
			}
			setZoom(numer, denom, !max);
			_inResizeProcess = false;
		}
		return super.onResize();
	}

	var _windowResizeable = true; // 是否可调整窗口大小
	property windowResizeable {	// 这个属性基本只能由菜单控制
		getter { return _windowResizeable; }
		setter(v) {
			_windowResizeable = v;
			disableResize = !v if (exEventEnabled);
		}
	}
	function onResizing(rect) {
		if (_resizeSnapshot === void) onMoveSizeBegin();
		if (!windowResizeable) {
			// getWindowRect 可以换成这个方法
			with (_resizeSnapshot.window) {
				rect.x = .x;
				rect.y = .y;
				rect.w = .w;
				rect.h = .h;
			}
			return true;
		}
		if (isMaximizedMode()) return false;// 最大化模式不调整
		var w, h, dw, dh;
		with (_resizeSnapshot) dw=.dw, dh=.dh;
		with (rect) {
			// 获取client的大小
			w = .w - dw;
			h = .h - dh;
			var narrow;		// 是否为窄窗口  窄窗口代表以左右宽度为基准放大，否则以上下高度为基准
			switch (.type) {
			case 1: case 2: narrow = true;  break;	// 左右拉伸
			case 3: case 6: narrow = false; break;	// 上下
			default: narrow = (w / h) > (scWidth / scHeight); break;
			}
			if (narrow) h = w * scHeight \ scWidth;	// narrow 为真 以宽度对其
			else    w = h * scWidth  \ scHeight;	// 否则以高度对齐
			w += dw;
			h += dh;
			.x = .x + (.w - w) * ((2-.type%3)==0?0:1/(2-.type%3)); 
			.y = .y + (.h - h) * ((2-.type\3)==0?0:1/(2-.type\3)); 
			.w = w;
			.h = h;
		}
		callHook("onResizing", rect);
		return true; 	
	}

	var _resizeSnapshot = void;
	function onMoveSizeBegin() {
		_resizeSnapshot = %[
		window:      getWindowRect(),
		client:      getClientRect(),
		innerWidth:  innerWidth,
		innerHeight: innerHeight
			];
		with (_resizeSnapshot) {	//减去内部大小
			.dw = .window.w  - .innerWidth;
			.dh = .window.h - .innerHeight;
		}
	}
	function onMoveSizeEnd() {
		setZoom(innerWidth, scWidth) if (!isMaximizedMode());
		callHook("onMoveSizeEnd", _resizeSnapshot);
		_resizeSnapshot = void;
	}

	property stayOnTop {
		getter{ return isStayOnTop;}
		setter(v){ super.stayOnTop = isStayOnTop = v;}
	}

	property fullScreenMode { getter { return 3;} }

	function isPseudoMode() {//是否为模拟模式	约可以等效于是否启用额外事件
		if (pseudoFullScreened) return true;
		return exEventEnabled;	 // 启用额外事件则为模拟 否则不是
	}

	var _pseudoFullScreen;
	property pseudoFullScreened { getter { return (_pseudoFullScreen !== void); } }

	var _lastWindowSize;
	property fullScreen {	// 直接操作此属性不会更改 fullScreened,请使用 changeFullScreenOrWindow 方法
		getter { return super.fullScreen || pseudoFullScreened; }
		setter(v) {
			if (!fullScreen == !v) return;
			this.disableMove = false;	// 不知道为啥就是有这个属性  插件属性，如果取不到可以不用
			if (typeof this.screenModeChangedTrigger == "undefined") {
				add(   this.screenModeChangedTrigger = new AsyncTrigger(this, "screenModeChanged"));
				with (      screenModeChangedTrigger) .cached = true, .mode = atmAtIdle, .trigged = false;
			}
			var trig =      screenModeChangedTrigger;
			with (trig) {
				.maximize = .callResize = .windowPos = void;
				if (.trigged) throw new Exception("Cant set fullScreen, changed trigger not completed.");
			}

			// 钩子
			callHook("onPrepareChangeScreenMode", v);
			//onMovieScreenChanging(v);// TODO 以后 上面的钩子看下 
			if (v) {	// 全屏
				_lastWindowSize = %[		// 用于记录窗口位置，重启时恢复,仅在模拟全屏时记录
							window: ((typeof this.getNormalRect == "Object") ? getNormalRect() :
										%[ x:left, y:top, w:width, h:height ]) ];  
				if (exEventEnabled) {	// 启用额外事件则启用模拟全屏模式
					var max = (typeof this.maximized != "undefined") ? maximized : false;
					_pseudoFullScreen =	%[	x:left, y:top, w:width, h:height,max:max, bs:borderStyle]; // 用于记录模拟全屏前 窗口的状态
					visible = false;
					trig.maximize = true;	// 指定最大化
					if (max) showRestore();	// 最大化时先恢复
					borderStyle = bsNone;
				} else {	// 否则普通全屏模式
					setInnerSize(scWidth, scHeight);
					resetPrimaryPos();
					trig = void;
					super.fullScreen = true;
				}
			} else {	// 窗口化
				super.fullScreen = false; // 模拟模式也是false 无所谓
				if (pseudoFullScreened) with (_pseudoFullScreen) {
					visible = false;
					setPos (.x, .y);
					setSize(.w, .h);
					borderStyle   = .bs;
					trig.callResize = true;
					trig.maximize = .max;	// 恢复最大化
					showRestore();
					_pseudoFullScreen = void;
				} else {
					setZoom(origZoomNumer, origZoomDenom);
				}
				_lastWindowSize = void;
			}
			if (trig !== void) with (trig) {
				.trigged = true;	// 表示准备触发
				.trigger();
			} else
				callHook("onAfterChangeScreenMode");
		}
	}

	/** 
	* @description: 	全屏和窗口化变更时触发的方法
	* @param maximize	代表最大化
	* @param callResize	代表恢复大小触发onresize方法
	* @return 无
	*/
	function screenModeChanged() {
		with (screenModeChangedTrigger) {
			if ( .maximize  ) maximize();	// 最大化
			else if (.callResize) onResize();	// 恢复大小
			this.disableMove = (borderStyle == bsNone);
			.maximize = .callResize = .windowPos = void;
			.trigged = false;
		}
		visible = true if !visible;
		// フック
		callHook("onAfterChangeScreenMode");
	}
	

	var menuBarEnable;   // メニューバー有効		菜单栏是否有效


	//------------------------------------------------ メニューアイテム関連 -- TODO 菜单相关的事件触发

	function onExitMenuItemClick(sender)
	{
		close();
	}

	function onRightClickMenuItemClick(sender)
	{
		onPrimaryRightClick(); // 右クリックの動作
	}

	function onShowHistoryMenuItemClick(sender)
	{
		if(historyLayer.visible) hideHistory(); else showHistory();
	}

	function onSkipToNextStopMenuItemClick(sender)
	{
        if (skipMode) cancelSkip(); else skipToStop();
        setMenuAccessibleAll();
	}

	function onAutoModeMenuItemClick(sender)
	{
		if(autoMode) cancelAutoMode(); else enterAutoMode();
        setMenuAccessibleAll();
	}

	function onAutoModeWaitMenuClick(sender)
	{
		sender.checked = true;
		autoModePageWait = sender.wait;
		autoModeLineWait = sender.lwait;
	}

	function onBackStartMenuItemClick(sender)
	{
		goBackHistory(historyOfStore.count-1);
	}

	function onGoToStartMenuItemClick(sender)
	{
		goToStartWithAsk();
	}

    function onAllSkipMenuItemClick(sender)
    {
		sender.checked = true;
        allskip = sender.skip;
		saveSystemVariables();
    }
    
	function onChSpeedMenuItemClick(sender)
	{
		sender.checked = true;
		userChSpeed = sender.speed;
		setUserSpeed();
		saveSystemVariables();
	}

	function onChNonStopToPageBreakItemClick(sender)
	{
		chNonStopToPageBreak = ! chNonStopToPageBreak;
		if(typeof this.chNonStopToPageBreakItem != "undefined")
			chNonStopToPageBreakItem.checked = chNonStopToPageBreak;
			saveSystemVariables();
	}

	function onCh2ndNonStopToPageBreakItemClick(sender)
	{
		ch2ndNonStopToPageBreak = ! ch2ndNonStopToPageBreak;
		if(typeof this.ch2ndNonStopToPageBreakItem != "undefined")
			ch2ndNonStopToPageBreakItem.checked = ch2ndNonStopToPageBreak;
			saveSystemVariables();
	}

	function onCh2ndSpeedMenuItemClick(sender)
	{
		sender.checked = true;
		userCh2ndSpeed = sender.speed;
		setUserSpeed();
		saveSystemVariables();
	}

	function onChAntialiasMenuItemClick(sender)
	{
		chDefaultAntialiased = !chDefaultAntialiased;
		if(typeof this.chAntialiasMenuItem != "undefined")
			chAntialiasMenuItem.checked = chDefaultAntialiased;
		setMessageLayerUserFont();
		saveSystemVariables();
	}

	function onChChangeFontMenuItem(sender)
	{
		selectFont();
		saveSystemVariables();
	}

	/** 
	* @description: 	变更全屏的模式，会关联存储用的fullScreened变量以及会触发钩子，所以请勿直接使用fullScreen属性
	* @param isfull		是否全屏
	* @return 
	*/
	function changeFullScreenOrWindow(isfull) //需要感知全屏变化请使用 onAfterChangeScreenMode 钩子
	{
		if ( !fullScreened == !isfull) return;
		try { 
			fullScreen   =   isfull; 
			fullScreened = isfull;
		}
		catch(e) {
			Debug.notice((isfull ? "full screen " : "window") + " mode 's changing is failed : " + e.message);
		}
		saveSystemVariables();
	}


	function onWindowedMenuItemClick(sender)
	{
		if(fullScreened)
		{
			try
			{
				fullScreen = false;
			}
			catch(e)
			{
				Debug.notice("无法切换到窗口模式 : " + e.message);
			}
			fullScreened = fullScreen;
			if(fullScreened)
				fullScreenMenuItem.checked = true;
			else
				windowedMenuItem.checked = true;
		}
		saveSystemVariables();
	}
	//切换全屏，并设置菜单按钮的对应状态
	function onFullScreenMenuItemClick(sender)
	{
		if(!fullScreened)
		{
			try
			{
				fullScreen = true;
			}
			catch(e)
			{
				Debug.notice("无法切换到全屏 : " + e.message);
			}
			fullScreened = fullScreen;
			if(fullScreened)
				fullScreenMenuItem.checked = true;
			else
				windowedMenuItem.checked = true;
		}
		saveSystemVariables();
	}

	function onHelpIndexMenuItemClick(sender)
	{
		// ヘルプファイルを開く
		System.shellExecute(Storages.getLocalName(System.exePath) + helpFile);
	}

	function onHelpAboutMenuItemClick(sender)
	{
		// 「このソフトについて」ウィンドウを表示
		var win = new global.KAGWindow(false, aboutWidth, aboutHeight);
		win.setPos(left + ((width - win.width)>>1), top + ((height - win.height)>>1));
		win.process('about.ks' ,,, true); // about.ks を immediate で表示
		win.showModal(); // モード付きで表示
		invalidate win;
	}

    // シナリオ実行ダイアログ呼び出し
    function onExecDialogMenuItemClick(sender)
    {
        execDialog();
    }
    
	function onReloadScenarioMenuItemClick(sender)
	{
		saveBookMark(1000, false);
		loadBookMark(1000);
	}

	function onShowConsoleMenuItemClick(sender)
	{
		Debug.console.visible = true;
	}

	function onShowContollerMenuItemClick(sender)
	{
		Debug.controller.visible = true;
	}
	// 设置菜单是否可用，只有autoEnable设置为true的菜单才会被设置
	function internalSetMenuAccessibleAll(menu, state)
	{
		// autoEnable が true のすべてのメニュー項目の accessible に値 state を
		// 設定する
		if(typeof menu.autoEnable != "undefined" && menu.autoEnable)
			menu.accessible = state;
		if(typeof menu.stopRecur == "undefined" || !menu.stopRecur) //stopRecur 这个成员在本版本中未定义，应该是是否停止搜索子菜单的意思
		{
			var children = menu.children;
			for(var i = children.count -1; i >= 0; i--)
				internalSetMenuAccessibleAll(children[i], state); // 再帰
		}
	}
	//返回是否可存档
	function canStore()
	{
		return storeEnabled && !isRecollection && isHistoryOfStoreAlive(0);
	}

	function canRestore()
	{
		return restoreEnabled && !isRecollection;
	}
	function onModeChange(){
		var elm = %[];
		with(elm){
			.inStable = inStable;
			.autoMode = autoMode;
			.skipMode = skipMode;
			.modal = historyLayer.visible || messageLayerHiding || currentDialog;
        	.state = inStable && !.modal;
			.canSkip = !.modal && (inStable || skipMode) && !inSleep && nextSkipEnabled && (allskip || getCurrentRead()); //auto 时可以skip
			.canAuto = !.modal && (inStable || autoMode) && !inSleep && !skipMode;		//但是skip时无法进行auto
			.canStore =  canStore();
			.canRestore =  canRestore();
			.selectShowing =  selectShowing || mapSelectShowing;
		}
		callHook("onModeChange", elm);
        // internalSetMenuAccessibleAll(menu, state);
	}
	function setMenuAccessibleAll()	// TODO 待迁移
	{
		// メニュー項目の使用可/不可を設定する

		// autoEnable が true のすべてのメニュー項目の accessible の
		// 値を設定する
        var modal = historyLayer.visible || messageLayerHiding || currentDialog;
        var state = inStable && !modal;
        internalSetMenuAccessibleAll(menu, state);

        // その他のメニューの使用可/不可
        var canSkip = !modal && (inStable || skipMode) && !inSleep && nextSkipEnabled && (allskip || getCurrentRead());
        //dm("canSkip:" + canSkip);
        if(typeof this.skipToNextStopMenuItem != "undefined")//快进
            skipToNextStopMenuItem.enabled = canSkip;

		if(typeof this.rightClickMenuItem != "undefined")//隐藏消息层
            rightClickMenuItem.enabled = inStable && !historyLayer.visible && !currentDialog;

		if(typeof this.showHistoryMenuItem != "undefined")//显示履历层
            showHistoryMenuItem.enabled = inStable && !messageLayerHiding && global.currentDialog===void &&
				historyEnabled;

        var canAuto = !modal && (inStable || autoMode) && !inSleep && !skipMode; //启用自动模式
        if(typeof this.autoModeMenuItem != "undefined")
            autoModeMenuItem.enabled = canAuto;

		if(typeof this.goBackMenuItem != "undefined")//后退
			goBackMenuItem.enabled = state && isHistoryOfStoreAlive(0);//这里有问题

		if(typeof this.goToStartMenuItem != "undefined")//回到开头
			goToStartMenuItem.enabled = state && startAnchorEnabled;

		if(typeof this.storeMenu != "undefined")//存档
		{
			var st = state && canStore();
			var children = storeMenu.children;
			if(freeSaveDataMode) storeMenu.enabled = st;
			for(var i = children.count - 1; i >= 0; i--)
			{
				var obj = children[i];
				obj.enabled = obj.orgEnabled && st;
			}
		}

		if(typeof this.restoreMenu != "undefined")//读取存档
		{
			var st = state && canRestore();
			var children = restoreMenu.children;
			if(freeSaveDataMode) restoreMenu.enabled = st;
			for(var i = children.count - 1; i >= 0; i--)
			{
				var obj = children[i];
				obj.enabled = obj.orgEnabled && st;
			}
		}


    }

	//----------------------------------------------- マウスキーを有効にする --

	function enableMouseKey()
	{
		// マウスキーを有効にする
		if(mouseKeyEnabledCount == 0)
		{
			useMouseKey = true;
			mouseCursorState = mcsVisible;
		}
		mouseKeyEnabledCount++; // 参照カウンタ方式
	}

	function disableMouseKey()
	{
		// マウスキーを無効にする
		mouseKeyEnabledCount --;
		if(mouseKeyEnabledCount == 0) useMouseKey = false;
	}

	//----------------------------------------------------- システム変数関連 --
	// 读入系统变量
	function loadSystemVariables()
	{
		// システム変数の読み込み
		try
		{
			var fn = saveDataLocation + "/" + dataName +
				"sc.ksd";
			if(Storages.isExistentStorage(fn))
			{
				scflags = Scripts.evalStorage(fn);
				scflags = %[] if scflags === void;
			}
			else
			{
				scflags = %[];
			}

			var fn = saveDataLocation + "/" + dataName +
				"su.ksd";
			if(Storages.isExistentStorage(fn))
			{
				sflags = Scripts.evalStorage(fn);
				sflags = %[] if sflags === void;
			}
			else
			{
				sflags = %[];
			}
		}
		catch(e)
		{
			throw new Exception("无法读取系统变量，"
				"或者系统变量数据损坏(" + e.message + ")");
		}
	}
	//用scflags设置系统的信息
	function setSystemStateFromSystemVariables()
	{
		// システム変数に基づいてシステムを設定	基于系统变量相关进行设置
		// (フルスクリーン関連をのぞく)   除去全屏相关
		if(scflags.autoModePageWait !== void)  //自动模式等待时间设置
		{
			if(typeof this.autoModeWaitMenu !== "undefined")
			{
				var children = autoModeWaitMenu.children;
				for(var i = children.count-1; i >= 0; i--)
				{
					var item = children[i];
					if(typeof item.wait !== "undefined" && item.wait == scflags.autoModePageWait)
					{
						item.checked = true;
						break;
					}
				}
			}
		}

		if(scflags.userChSpeed !== void)//表示速度设置
		{
			if(typeof this.chSpeedMenu !== "undefined")
			{
				var children = chSpeedMenu.children;
				for(var i = children.count-1; i >= 0; i--)
				{
					var item = children[i];
					if(typeof item.speed !== "undefined" && item.speed == scflags.userChSpeed)
					{
						item.checked = true;
						break;
					}
				}
			}
		}

		if(scflags.userCh2ndSpeed !== void)//已读表示速度设置
		{
			if(typeof this.chSpeedMenu !== "undefined")
			{
				var children = ch2ndSpeedMenu.children;
				for(var i = children.count-1; i >= 0; i--)
				{
					var item = children[i];
					if(typeof item.speed !== "undefined" && item.speed == scflags.userCh2ndSpeed)
					{
						item.checked = true;
						break;
					}
				}
			}
		}

        if (scflags.allskip !== void) {	//应该是快进模式的设置，但是menus没有加进去这个菜单
            allskip = scflags.allskip;
            if (typeof this.allskipMenu !== "undefined") {
                var children = allskipMenu.children;
                for(var i = children.count-1; i >= 0; i--) {
                    var item = children[i];
                    if(typeof item.skip !== "undefined" && item.skip == allskip) {
                        item.checked = true;
                        break;
                    }
                }
            }
        }
		voicecut = scflags.voicecut if scflags.voicecut !== void;// 语音切断
		bgmdown = scflags.bgmdown if scflags.bgmdown !== void;
        bgmdownlevel = scflags.bgmdownlevel if scflags.bgmdownlevel !== void;
        afterauto = scflags.afterauto if scflags.afterauto !== void;//选择支后auto是否继续
        afterskip = scflags.afterskip if scflags.afterskip !== void;//选择支后快进是否继续
        
		lastSaveDataNameGlobal = scflags.lastSaveDataNameGlobal if scflags.lastSaveDataNameGlobal !== void;//上次保存的自由保存模式下的文件名	

		bookMarks = scflags.bookMarks if scflags.bookMarks !== void;//存档
		autoModeWaitVoice = scflags.autoModeWaitVoice if scflags.autoModeWaitVoice !== void;// 自动模式语音等待
		autoModePageWait = scflags.autoModePageWait if scflags.autoModePageWait !== void;//自动模式换页等待时间
		autoModeLineWait = scflags.autoModeLineWait if scflags.autoModeLineWait !== void;//自动模式换行等待时间
		userChSpeed = scflags.userChSpeed if scflags.userChSpeed !== void;//表示速度
		userCh2ndSpeed = scflags.userCh2ndSpeed if scflags.userCh2ndSpeed !== void;//已读速度

		setUserSpeed();	//设置速度

		chNonStopToPageBreak = scflags.chNonStopToPageBreak if scflags.chNonStopToPageBreak !== void;//是否直接快进到换页
		if(typeof this.chNonStopToPageBreakItem != "undefined")
			chNonStopToPageBreakItem.checked = chNonStopToPageBreak;

		ch2ndNonStopToPageBreak = scflags.ch2ndNonStopToPageBreak if scflags.ch2ndNonStopToPageBreak !== void;//已读是否直接快进到换页
		if(typeof this.ch2ndNonStopToPageBreakItem != "undefined")
			ch2ndNonStopToPageBreakItem.checked = ch2ndNonStopToPageBreak;

		chDefaultAntialiased = scflags.chDefaultAntialiased if scflags.chDefaultAntialiased !== void;//是否抗锯齿
		if(typeof this.chAntialiasMenuItem != "undefined")
			chAntialiasMenuItem.checked = chDefaultAntialiased;
		chDefaultFace = scflags.chDefaultFace if scflags.chDefaultFace !== void;//字体
		chUserFace = scflags.chUserFace if scflags.chUserFace !== void;//字体
		setMessageLayerUserFont();
		bgm.restoreSystemState(scflags);//bgm读取信息

		resetAllVoiceSpeed();

        for(var i = 0; i<numSEBuffers+1; i++)
		{
			se[i].restoreSystemState(scflags); //音效读取信息
		}
		callHook("onRestoreSystemState",scflags);
	}

	function clearSystemVariables()
	{
		// システム変数のクリア
		(Dictionary.clear incontextof sflags)();
	}

	function saveSystemVariables()
	{
		// システム変数の保存
		if(!isMain) return;

		// プラグインを呼ぶ		呼叫插件
		forEachEventHook('onSaveSystemVariables',
			function(handler, f) { handler(); } incontextof this);

		// フルスクリーン
		scflags.fullScreen = fullScreened;
		scflags.isStayOnTop = isStayOnTop;
		scflags.zoomNumer = origZoomNumer;
		scflags.zoomDenom = origZoomDenom;
		//	记录窗口位置
		scflags.windowResizeable = windowResizeable;
		scflags.windowMaximized  = false;
		var rect;
		if (!isBlank(this,"maximized") ) {
			scflags.windowMaximized  = maximized;	
			if (_pseudoFullScreen !== void) with (_pseudoFullScreen) {	// 用无边框全屏前窗口位置记录
				rect = .rect;
				scflags.windowMaximized = .max;
			} else if (typeof this.getNormalRect != "undefined")
				rect = getNormalRect();
		} else if (fullScreened && typeof _lastWindowSize == "Object") {
			rect = _lastWindowSize.window; 
		}
		if (rect !== void) {
			scflags.windowLeft   = rect.x;
			scflags.windowTop    = rect.y;
		} else {
			scflags.windowLeft   = left;
			scflags.windowTop    = top;
		}

		with (Debug.console) {
			scflags.consoleVisible = .visible;
			scflags.consolePlacement = %[left:.left,top:.top,width:.width,height:.height];
			
		}


		// 文字表示速度
		scflags.autoModeWaitVoice = autoModeWaitVoice;
		scflags.autoModePageWait = autoModePageWait;
		scflags.autoModeLineWait = autoModeLineWait;
		scflags.userChSpeed = userChSpeed;
		scflags.userCh2ndSpeed = userCh2ndSpeed;
		scflags.chDefaultAntialiased = chDefaultAntialiased;
		scflags.chDefaultFace = chDefaultFace;
		scflags.chUserFace = chUserFace;
		scflags.chNonStopToPageBreak = chNonStopToPageBreak;
		scflags.ch2ndNonStopToPageBreak = ch2ndNonStopToPageBreak;

		// ブックマーク名
		scflags.bookMarks = bookMarks; // (コピーではなくて)参照で十分    注意并非是复制 参照时请注意

		scflags.lastSaveDataNameGlobal = lastSaveDataNameGlobal;
	
		scflags.voicecut = voicecut;
        scflags.bgmdown = bgmdown;
        scflags.bgmdownlevel = bgmdownlevel;
        // 全てスキップ
        scflags.allskip = allskip;

        scflags.afterauto = afterauto;
        scflags.afterskip = afterskip;
        
		// ファイルに書き込む
		if(!readOnlyMode)
		{
			var fn = saveDataLocation + "/" + dataName +
				"sc.ksd";
			(Dictionary.saveStruct incontextof scflags)(fn, saveDataMode);

			var fn = saveDataLocation + "/" + dataName +
				"su.ksd";
			(Dictionary.saveStruct incontextof sflags)(fn, saveDataMode);
		}
	}

	//------------------------------------------------------- ゲーム変数関連 --
	//清空参数的字典，把当前系统状态存入参数的字典
	function internalStoreFlags(f)
	{
		// f に現在の状態を記録する

		// KAGWindow に関するもの
		(Dictionary.clear incontextof f)(); // クリア
		// ここの [start_store_vars] から [end_store_vars] で囲まれた部分は   这里的[start_store_vars]到[end_store_vars] 包围的部分能被文件尾的
		// 末端の perl スクリプトによって自動的に処理されるので、このマークを消したり	perl脚本自动处理，不要编辑这些注释
		// このマークの間を編集したりしないこと。
		// [start_store_vars]
		f.storeTime = (new Date()).getTime(); // 日付を保存
		f.playTime = _playTime + pcflags.storeTime - _playStartTime;
		f.lastTextNum = currentTextNum;
		f.lastTextStorage = Storages.chopStorageExt(mainConductor.curStorage);
		f.lastSaveDataName = lastSaveDataName;
		f.quaking = quaking;
		f.quakeEndTick = quakeEndTick;
		f.quakeHorzMax = quakeHorzMax;
		f.quakeVertMax = quakeVertMax;
		f.quakePhase = quakePhase;
		f.historyWriteEnabled = historyWriteEnabled;
		f.historyEnabled = historyEnabled;
		f.numCharacterLayers = numCharacterLayers;
		f.numMessageLayers = numMessageLayers;
		f.currentNum = currentNum;
		f.currentPage = currentPage;
		f.currentWithBack = currentWithBack;
		f.chUserMode = chUserMode;
		f.chSpeed = chSpeed;
		f.actualChSpeed = actualChSpeed;
		f.beforeNoWaitActualChSpeed = beforeNoWaitActualChSpeed;
		f.beforeNoWaitChUserMode = beforeNoWaitChUserMode;
		f.clickSkipEnabled = clickSkipEnabled;
		f.nextSkipEnabled = nextSkipEnabled;
		f.canCancelSkipByClick = canCancelSkipByClick;
		f.rightClickEnabled = rightClickEnabled;
		f.rightClickCall = rightClickCall;
		f.rightClickJump = rightClickJump;
		f.rightClickTarget = rightClickTarget;
		f.rightClickStorage = rightClickStorage;
		f.rightClickName = rightClickName;
		f.rightClickCurrentMenuName = rightClickCurrentMenuName;
		f.cursorDefault = cursorDefault;
		f.cursorPointed = cursorPointed;
		f.cursorWaitingClick = cursorWaitingClick;
		f.cursorDraggable = cursorDraggable;
		f.startAnchorEnabled = startAnchorEnabled;
		f.storeEnabled = storeEnabled;
		f.restoreEnabled = restoreEnabled;
        f.currentStorage  = currentStorage;
        f.currentLabel    = currentLabel;
		f.currentPageName = currentPageName;
		// [end_store_vars]

		// bgm
		f.bgm = bgm.store();

		// 効果音
		f.se = [];
		for(var i = 0; i<numSEBuffers; i++)
		{
			f.se[i] = se[i].store();
		}

		// メッセージレイヤ
		f.foreMessageLayers = [];
		f.backMessageLayers = [];
		for(var i = 0; i < numMessageLayers; i++)
		{
			f.foreMessageLayers[i] = fore.messages[i].store();
			f.backMessageLayers[i] = back.messages[i].store();
		}

		// 前景レイヤ
		f.foreCharacterLayers = [];
		f.backCharacterLayers = [];
		for(var i = 0; i < numCharacterLayers; i++)
		{
			f.foreCharacterLayers[i] = fore.layers[i].store();
			f.backCharacterLayers[i] = back.layers[i].store();
		}

        // 舞台レイヤ・イベントレイヤ
        f.foreStageLayer = fore.stage.store();
        f.backStageLayer = back.stage.store();
        f.foreEventLayer = fore.event.store();
        f.backEventLayer = back.event.store();
        
		// 背景レイヤ
		f.foreBaseLayer = fore.base.store();
		f.backBaseLayer = back.base.store();

		// ウィンドウキャプション
		f.caption = caption;

		// コンダクタ
		f.mainConductor = mainConductor.store();
		if(!saveMacros) f.mainConductor.macros = void;
			// マクロ情報を void で上書きすると栞中のマクロ情報は無効になる

		// メッセージ履歴
		f.historyData = historyLayer.store();

		// ムービー
		if( isMain )
		{
			f.movies = [];
			for( var i = 0; i < numMovies; i++)
				f.movies[i] = movies[i].store();
		}
		loopVoiceInfo.onStore(f);
        callHook("onStore",f);
		// storeHook			存档的插件回调
		forEachEventHook('onStore',
			function(handler, f) { handler(f.flags, f.options); } incontextof this,
			%[flags:f, options:void]);
	}
	//将系统当前状态存入pcflags  将用户变量存入 通过标签自动 存储变量
	function storeFlags()// 变量存入，代表下次存档文件 使用的是这时存入的内容
	{
		// pcflags, pflags に値を書き込む

		// flags -> pflags
		(Dictionary.assignStruct incontextof pflags)(flags);

		internalStoreFlags(pcflags);
	}

	function internalRestoreFlags(f, clear = true, elm = void)
	{
		// f から情報を読み出す
		// clear が true ならばメッセージレイヤをクリアする
		// se, bgm がそれぞれ true ならばその情報も反映させる
		// backlay が true の場合は、表画面にロードすべきものを裏画面にロードする

		// KAGWindow に関するもの
		// ここの [start_restore_vars] から [end_restore_vars] で囲まれた部分は
		// (略)
		// [start_restore_vars]
		currentTextNum = f.lastTextNum = currentTextNum;
		lastSaveDataName = f.lastSaveDataName if f.lastSaveDataName !== void;
		quaking = f.quaking if f.quaking !== void;
		quakeEndTick = f.quakeEndTick if f.quakeEndTick !== void;
		quakeHorzMax = f.quakeHorzMax if f.quakeHorzMax !== void;
		quakeVertMax = f.quakeVertMax if f.quakeVertMax !== void;
		quakePhase = f.quakePhase if f.quakePhase !== void;
		historyWriteEnabled = f.historyWriteEnabled if f.historyWriteEnabled !== void;
		historyEnabled = f.historyEnabled if f.historyEnabled !== void;
		numCharacterLayers = f.numCharacterLayers if f.numCharacterLayers !== void;
		numMessageLayers = f.numMessageLayers if f.numMessageLayers !== void;
		currentNum = f.currentNum if f.currentNum !== void;
		currentPage = f.currentPage if f.currentPage !== void;
		currentWithBack = f.currentWithBack if f.currentWithBack !== void;
		chUserMode = f.chUserMode if f.chUserMode !== void;
		chSpeed = f.chSpeed if f.chSpeed !== void;
		actualChSpeed = f.actualChSpeed if f.actualChSpeed !== void;
		beforeNoWaitActualChSpeed = f.beforeNoWaitActualChSpeed if f.beforeNoWaitActualChSpeed !== void;
		beforeNoWaitChUserMode = f.beforeNoWaitChUserMode if f.beforeNoWaitChUserMode !== void;
		clickSkipEnabled = f.clickSkipEnabled if f.clickSkipEnabled !== void;
		nextSkipEnabled = f.nextSkipEnabled if f.nextSkipEnabled !== void;
		canCancelSkipByClick = f.canCancelSkipByClick if f.canCancelSkipByClick !== void;
		rightClickEnabled = f.rightClickEnabled if f.rightClickEnabled !== void;
		rightClickCall = f.rightClickCall if f.rightClickCall !== void;
		rightClickJump = f.rightClickJump if f.rightClickJump !== void;
		rightClickTarget = f.rightClickTarget if f.rightClickTarget !== void;
		rightClickStorage = f.rightClickStorage if f.rightClickStorage !== void;
		rightClickName = f.rightClickName if f.rightClickName !== void;
		rightClickCurrentMenuName = f.rightClickCurrentMenuName if f.rightClickCurrentMenuName !== void;
		cursorDefault = f.cursorDefault if f.cursorDefault !== void;
		cursorPointed = f.cursorPointed if f.cursorPointed !== void;
		cursorWaitingClick = f.cursorWaitingClick if f.cursorWaitingClick !== void;
		cursorDraggable = f.cursorDraggable if f.cursorDraggable !== void;
		startAnchorEnabled = f.startAnchorEnabled if f.startAnchorEnabled !== void;
		storeEnabled = f.storeEnabled if f.storeEnabled !== void;
		restoreEnabled = f.restoreEnabled if f.restoreEnabled !== void;
        currentStorage = f.currentStorage if f.currentStorage !== void;
        currentLabel = f.currentLabel if f.currentLabel !== void;
		currentPageName = f.currentPageName if f.currentPageName !== void;
		// [end_restore_vars]

        
		// ムービー
		if( isMain )
		{
			for( var i = 0; i < numMovies; i++)
				movies[i].restore(f.movies[i]);
		}

		// 背景レイヤ
		var backlay = elm != void && elm.backlay != void && +elm.backlay;
		if(backlay)
		{
			back.base.restore(f.foreBaseLayer);
		}
		else
		{
			fore.base.restore(f.foreBaseLayer);
			back.base.restore(f.backBaseLayer);
		}

        if (backlay) {
            back.stage.restore(f.foreStageLayer);
            back.event.restore(f.foreEventLayer);
        } else {
            fore.stage.restore(f.foreStageLayer);
			back.stage.restore(f.backStageLayer);
            fore.event.restore(f.foreEventLayer);
			back.event.restore(f.backEventLayer);
        }
        
		// メッセージレイヤ
		allocateMessageLayers(numMessageLayers);
		if(backlay)
		{
			for(var i = 0; i < numMessageLayers; i++)
			{
				back.messages[i].restore(f.foreMessageLayers[i]);
			}
		}
		else
		{
			for(var i = 0; i < numMessageLayers; i++)
			{
				fore.messages[i].restore(f.foreMessageLayers[i]);
				back.messages[i].restore(f.backMessageLayers[i]);
			}
		}

		if(clear)
		{
			for(var i = 0; i < numMessageLayers; i++)
			{
				fore.messages[i].clear();
				back.messages[i].clear();
			}
			historyLayer.restore(f.historyData);
			backHistoryLayer.restore(f.historyData);
		}

		// 前景レイヤ
		allocateCharacterLayers(numCharacterLayers);
		if(backlay)
		{
			for(var i = 0; i < numCharacterLayers; i++)
			{
				back.layers[i].restore(f.foreCharacterLayers[i]);
			}
		}
		else
		{
			for(var i = 0; i < numCharacterLayers; i++)
			{
                try {
                    fore.layers[i].restore(f.foreCharacterLayers[i]);
                } catch (e) {
                    dm("图像读取失败");
                } 
                try {
                    back.layers[i].restore(f.backCharacterLayers[i]);
                } catch (e) {
                    dm("图像读取失败");
                } 
            }
		}

		// quake 関連
		restoreQuake();

		// bgm
		if(elm === void || elm.bgm === void || +elm.bgm)
		{
			bgm.restore(f.bgm);
		}
		// 効果音
		if(elm === void || elm.se === void || +elm.se)
		{
			for(var i = 0; i<numSEBuffers; i++)
			{
				se[i].restore(f.se[i]);
			}
		}

		// ウィンドウキャプション
		caption = f.caption;
		System.title = caption;

		// current の設定し直し
		current = (currentPage?back:fore).messages[currentNum];

		// 右クリックメニュー名
		if(typeof this.rightClickMenuItem != "undefined")
			rightClickMenuItem.caption = rightClickCurrentMenuName;
		loopVoiceInfo.onRestore(f);
		loopVoiceTrigger.trigger();
		callHook("onRestore",f,clear,elm);
		// restoreHook
		forEachEventHook('onRestore',
			function(handler, f) { handler(f.flags, f.clear, f.options); } incontextof this,
			%[flags:f, clear:clear, options:elm]);

	}
	//从存档中恢复系统状态
	function restoreFlags()
	{
		// pcflags, pflags から情報を読み出す

		// ロード時、ムービーのピリオドイベント情報をクリアする
		purgeMoviePeriod();

		// スナップショットの破棄
		freeSnapshot();

		// トランジション、自動移動の停止
		stopAllTransitions();

		// クリック待ち記号を隠す
		hideClickGlyphs();

		// メッセージ履歴を隠す
		hideHistory();

        // 選択肢を隠す
        hideSelect();
        hideMapSelect();
        
		// スキップのキャンセル
		cancelSkip();

		// pflags -> flags
		(Dictionary.assignStruct incontextof flags)(pflags);

		// 栞管理関連
		stablePosibility = false;

		// コンダクタ
		currentRecordName = "";
		mainConductor.restore(pcflags.mainConductor);
		extraConductor.clear();
		setConductorToMain();

		// 読み込み
		internalRestoreFlags(pcflags,false);

		// メニュー関連
		// setMenuAccessibleAll();
		onModeChange();

        // 回想中止
        stopRecollection();
        
		// 実行開始
		processGo();
	}

	function clearVariables()
	{
		// ゲーム変数のクリア
		(Dictionary.clear incontextof flags)();
	}

	//--------------------------------------------------------- 通過記録管理 --
	
	function pushHistoryOfStore()
	{
		// 辞書配列を作成
		var dic = %[];
		// user と core を記録
		dic.id = saveDataID;
		dic.user = %[];
		(Dictionary.assignStruct incontextof dic.user)(pflags);
		dic.core = %[];
		(Dictionary.assignStruct incontextof dic.core)(pcflags);

		historyOfStore.push(dic);
		// はみ出た分を削除
		/*if(historyOfStore.count > maxHistoryOfStore)
			historyOfStore.count = maxHistoryOfStore;*/
	}

	//通过记录是否可用
	function isHistoryOfStoreAlive(num)
	{
		// 通過記録が利用可能かどうかを返す
		return historyOfStore.count>num;
	}

    function goBackYes(num = historyOfStore.count-1) {
		if(num<0)throw new Exception("there is not enough history to go back!",Scripts.getTraceString());
        // user と core を pflags, pcflags に戻す
        (Dictionary.assignStruct incontextof pflags)(historyOfStore[num].user);
        (Dictionary.assignStruct incontextof pcflags)(historyOfStore[num].core);
        
        historyOfStore.count = num; // 因为是回到存入履历之前的地方，接下来的操作会再次存入一个记录，所以记录少一个
        historyLayer.visible = false;
        // データを元に、栞をたどる動作をする
        restoreFlags();
    }

    function goBackHistory(num,ask = true)
	{
		// 通過記録をたどり、戻る

		if(!isHistoryOfStoreAlive(num))
			return false;

		var result;
		if(ask)
		{
			var prompt = "do you want go back to「"+ historyOfStore[num].core.currentPageName + "」?";
            askYesNo(prompt, "yes", goBackYes,void,num);
		}
		else
		{
            goBackYes(num);
		}
	}

	//--------------------------------------------------------------- 栞管理 --

	
	//设置菜单上的存档按钮的名称，加上时间，为空改为未设定字样 TODO 待迁移
	function setBookMarkMenuCaptions()
	{
		// 「栞をたどる」「栞をはさむ」以下のサブメニューに
		// キャプションを設定

		// 栞を挟む
		if(typeof this.storeMenu !== "undefined")
		{
			var children = storeMenu.children;
			for(var i = children.count - 1; i >= 0; i--)
			{	
				 if( !isBlank(bookMarks[i])) //存在存档
				{
					// 栞が存在する
					var caption;
					if(showBookMarkDate) caption = bookMarks[i].date + " ";
					caption += bookMarks[i].name;
					var item = children[i];
					item.caption = caption;
					item.enabled = false;
					item.orgEnabled = bookMarks[i].protectedStates;
				}
				else
				{
					// 栞が存在しない
					var item = children[i];
					item.caption = "(未设定)";
					item.enabled = false;
					item.orgEnabled = true;
				}
			}
		}

		// 栞をたどる
		if(typeof this.restoreMenu !== "undefined")
		{
			var children = restoreMenu.children;
			for(var i = children.count - 1; i >= 0; i--)
			{
				if( !isBlank(bookMarks[i])) //存在存档
				{
					// 栞が存在する
					var caption;
					if(showBookMarkDate) caption = bookMarks[i].date + " ";
					caption += bookMarks[i].name;
					var item = restoreMenu.children[i];
					item.caption = caption;
					item.enabled = false;
					item.orgEnabled = true;
				}
				else
				{
					var item = restoreMenu.children[i];
					item.caption = "(未设定)";
					item.enabled = false;
					item.orgEnabled = false;
				}
			}
		}
		// setMenuAccessibleAll();
		onModeChange();
	}

	function setBookMarkProtectedState(num, s)
	{
		// n 番の栞の保護フラグを設定する
		// s = true ならば栞に書き込み保護をする
		bookMarks[num].protectedStates = s;
		setBookMarkMenuCaptions();
	}

	
	function getBookMarkPageName(num)
	{
		// 栞番号 num のブックマーク名を得る
		if(!isBlank(bookMarks[num]))
			return bookMarks[num].name;
		return "(未設定)";
	}

	function getBookMarkStorage(num)
	{
        // 栞番号 num のストレージ名を得る
		if(!isBlank(bookMarks[num]))
			return bookMarks[num].storage;
		return "";
	}

	function getBookMarkFileName(tag,hasImage)                   { return saveDataLocation + "/" + dataName + tag + (hasImage?".bmp":".kdt"); }
	function getBookMarkFileNameBySystem(tag,hasImage = true)           { return getBookMarkFileName("_"+tag,hasImage); }
	//根据存档编号返回文件名
	function getBookMarkFileNameAtNum(num)
	{
		if(num >= 999) // 999 番以降は特殊なデータに用いるので
			return getBookMarkFileName(num,false); 
		else
			return getBookMarkFileName(num,saveThumbnail); 
	}

	function lockSnapshot()
	{
		// スナップショットをロックする
		// 初めてスナップショットがロックされた時点での画面を保存する
		if(snapshotLockCount == 0)
		{
			if(snapshotLayer === void)
                snapshotLayer = new Layer(this, primaryLayer);
            snapshotLayer.name = "for screen shot";
            snapshotLayer.setImageSize(scWidth, scHeight);
			snapshotLayer.face = dfAlpha;
			snapshotLayer.piledCopy(0, 0, kag.fore.base, 0, 0, scWidth, scHeight);
		}
		snapshotLockCount ++;
	}

	function unlockSnapshot()
	{
		// スナップショットのロックを解除する
		if(snapshotLockCount == 0)
			throw new Exception("snapshotLockCount下溢");
		snapshotLockCount --;
		if(snapshotLockCount == 0)
		{
			if(snapshotLayer !== void)
				invalidate snapshotLayer, snapshotLayer = void;
		}
	}
	//计算bmp文件大小的方法，bmp只有256色和8se模式，所以可以简单计算
	function calcThumbnailSize()
	{
		// サムネイルのサイズを計算する
		// 横幅は 133 に
		var ratio = scHeight / scWidth;
		var w = thumbnailWidth;
		var h = (int)(w * ratio);

		// サムネイル用ビットマップのサイズを計算				54是bmp固定的文件头
		// サムネイル用画像は 256 色 BMP または 24bit フルカラー BMP
		var size;
		if (thumbnailDepth == 8)
		  size = ((((w - 1) >> 2) + 1) << 2) * h + 1024 + 54;
		else
		  size = (((w * 3 + 3) >> 2) << 2) * h + 54;	//256色用的多所以说一下， +3 >>2 << 2 这里是保证4字节对齐 *3是关键的，因为 8*8*8 =256，三位存储一个像素

		return %[width : w, height : h, size : size];
	}
	//强制舍弃锁定的截图
	function freeSnapshot()
	{
		// スナップショットを強制的に破棄し、snapshotLockCount を 0 に設定する
		snapshotLockCount = 0;
		if(snapshotLayer !== void)
			invalidate snapshotLayer, snapshotLayer = void;
	}
	// 需要存档的数据即pcFlags和pFlags 存档为文件， fn为文件名 savehist为是否保存历史
	function saveBookMarkToFile(fn)
	{
		// ファイル fn に栞を保存する
		if(readOnlyMode) return false;
	
		// セーブデータをまとめる
		var data = %[];
		data.id = saveDataID;
		data.core = pcflags;
		data.user = pflags;
		data.history = historyOfStore;
		if(saveThumbnail)
		{
			// サムネイルを保存
			lockSnapshot();
			try
			{
				// サムネイルのサイズまで縮小
				var size = calcThumbnailSize();
				var tmp = new Layer(this, primaryLayer);
				try
				{
					tmp.setImageSize(size.width, size.height);
					tmp.face = dfAlpha;
					tmp.stretchCopy(0, 0, size.width, size.height, snapshotLayer,
						0, 0, snapshotLayer.imageWidth, snapshotLayer.imageHeight, stLinear);
					/*
					// サムネイル画像をセピア調にして保存する場合はコメントアウトを解除
					tmp.doGrayScale();
					tmp.adjustGamma(
									1.3, 0, 255,  // R gamma, floor, ceil
									1.0, 0, 255,  // G gamma, floor, ceil
									0.8, 0, 255); // B gamma, floor, ceil
					*/
					try
					{
						// サムネイルを保存
						tmp.saveLayerImage(fn, "bmp" + thumbnailDepth);

						// データを保存
						var mode = saveDataMode;
						mode += "o" + size.size; // モード文字列に 書き込みオフセットを指定
						(Dictionary.saveStruct incontextof data)(fn, mode);
					}
					catch(e)
					{
						invalidate tmp;
						unlockSnapshot();
						System.inform("can't save file(can't open file,"
							"or write is forbidden)");
						return false;
					}
				}
				catch(e)
				{
					invalidate tmp;
					throw e;
				}
				invalidate tmp;
			}
			catch(e)
			{
				unlockSnapshot();
				throw e;
			}
			unlockSnapshot();
		}
		else
		{
			// 通常のファイルに保存
			try
			{
				(Dictionary.saveStruct incontextof data)(fn, saveDataMode);
			}
			catch(e)
			{
				System.inform("can't save file(can't open file,"
					"or write is forbidden)");
				return false;
			}
		}

		return true;
	}
	/*保存系统数据到编号为n的存档上  num是编号 savehist为 是否保存历史数据
		还会更新存档的名称数据，以及更新菜单栏显示 */
	function saveBookMark(num)
	{
		// 栞番号 num に栞を保存する
		if(readOnlyMode) return false;
		if(!isBlank(bookMarks[num]) && bookMarks[num].protectedStates) return false;
		var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num));
		if(ret)
		{
			getBookMarkInfoFromData(pcflags, num);
		}
		callHook("onSaveBookMark",num);
		return ret;
	}

	function getBookMarkInfoFromData(dic, num)	
	{
		// 辞書配列 dic から栞のページ名と日付を読み出し、
		if(isBlank(dic)){
			bookMarks[num] = %[];
			return;
		}
		if(isBlank(bookMarks[num]))bookMarks[num] = %[];
		bookMarks[num].storage = dic.currentStorage;		
		bookMarks[num].name = dic.currentPageName;
		bookMarks[num].playTime = dic.playTime;
		bookMarks[num].lastTextNum = dic.lastTextNum;
		bookMarks[num].lastTextStorage = dic.lastTextStorage;
		var date = new Date();
		date.setTime(dic.storeTime);
		if (bookMarkDateSecond) {
			date = "%04d/%02d/%02d %02d:%02d:%02d".sprintf(
				date.getYear(), date.getMonth() + 1, date.getDate(),
				date.getHours(), date.getMinutes(), date.getSeconds() );
		} else {
			date = "%04d/%02d/%02d %02d:%02d".sprintf(
				date.getYear(), date.getMonth() + 1, date.getDate(),
				date.getHours(), date.getMinutes() );
		}
		bookMarks[num].date = date;
		setBookMarkMenuCaptions();
		saveSystemVariables();
		
	}
	/** 
	* @description: 重新读取存档文件，重新加载其中信息并更新 
	* @param num	存档编号
	* @return 
	*/
	function updateBookMarkInfo(num)
	{
		var data = readBookMarkFromFile(getBookMarkFileNameAtNum(num));
		getBookMarkInfoFromData(data.core, num) if ( !isBlank(data,"core"));
	}
	
	function readBookMarkFromFile(fn)
    {
		if (Storages.isExistentStorage(fn)) {
			var modestr = saveThumbnail ? ("o" + calcThumbnailSize().size) : void;
			return Scripts.evalStorage(fn, modestr);
		}
		else return void; 
		//throw new Exception("the file is not exist,maybe data is be broken!");
	}
	function beginLoadBookMark(){
		fore.base.freeImage();
		hideUiLayer();
	}

	function loadBookMarkFromFile(fn, loaduser = true)
	{
		// ファイル fn から栞を読み込む
		// loaduser が false の時は user を読み込まない
		try
		{
			var data;

			data = readBookMarkFromFile(fn); 
		
			if(isBlank(data))return false;
		
			if(data.id != saveDataID)
			{
				System.inform("他のシステムのデータを読み込もうとしました", "エラー");
				return false;
			}

			pcflags = data.core;
			pcflags = %[] if pcflags === void;
			if(loaduser)
			{
				pflags = data.user;
				pflags = %[] if pflags === void;
			}
			else
			{
				(Dictionary.assignStruct incontextof pflags)(flags);// 读取系统档时从 flags 赋值
			}
			historyOfStore = data.history;
			historyOfStore = [] if historyOfStore === void;
		}
		catch(e)
		{
			System.inform("无法读取存档，"
				"存档损坏，或存档格式错误"
				"(" + e.message + ")", "错误");
			return false;
		}

		restoreFlags();
		clearPlayTime(pcflags.playTime);
		return true;
	}

	function loadBookMark(num, loaduser = true)	// 回到开头和重新加载剧本 时第二参数为false
	{
		// 栞番号 num からデータを読み出す
		return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);
	}

	function saveBookMarkWithAsk(num)
	{
		// 栞番号 num に栞を設定する
		// そのとき、設定するかどうかをたずねる
		if(readOnlyMode) return false;
		if(!isBlank(bookMarks[num]) && bookMarks[num].protectedStates) return false;
		var prompt = "存档 ";
		if(num < numBookMarks) prompt += (num + 1);
		if(!isBlank(bookMarks[num])) 
			prompt += "将「" + bookMarks[num].name + "」";
		prompt += "保存在「"+ pcflags.currentPageName + "」吗？";

        askYesNo(prompt, "yes", saveBookMark, void, num);
        return true;
	}

	function loadBookMarkWithAsk(num)
	{
		// 栞番号 num から栞を読み出す
		// そのとき、読み出すかどうかをたずねる
		if(num < numBookMarks && isBlank(bookMarks[num]))
			return false;
		var prompt = "存档 ";
		if(num < numBookMarks) prompt += (num + 1);
		prompt += "读取存档「"+ bookMarks[num].name + "」吗?";

        askYesNo(prompt, "yes", loadBookMark, void, num);
        return true;
	}

	function saveBookMarkToFileWithAsk()
	{
		// 任意のファイルに栞を保存する
		// currentPageName をファイル名として適合するように
		// 変形する
		var invalid = "\\/:,;*?\"<>!.";
		var valid = "￥／：，；＊？”＜＞！．";

		var initialname = saveDataLocation + "/";
		var through = false;
		var orgname = currentPageName;

		if(lastSaveDataNameGlobal != "")
		{
			try
			{
				initialname = Storages.extractStoragePath(lastSaveDataNameGlobal);
			}
			catch(e)
			{
				initialname = saveDataLocation + "/";
			}
		}

		if(orgname == "")
		{
			// 栞の見出しがないので
			if(lastSaveDataName == "")
				orgname = System.title; // System.title を代わりに使う
			else
				initialname = lastSaveDataName, through = true;
		}

		if(!through)
		{
			var length = orgname.length;
			for(var i = 0; i < length; i++)
			{
				var ch = orgname[i];
					var ind = invalid.indexOf(ch);
				if(ind != -1)
					initialname += valid[ind];
				else if(#ch >= 32)
					initialname += ch;
			}
		}

		// 保存するファイル名を得る
		var selectdata = %[
			title:"保存存档",
			filter: [saveThumbnail ?
					"带有缩略图的存档(*.bmp)|*.bmp" :
					"存档(*.kdt)|*.kdt"],
			filterIndex : 1,
			name : initialname,
			initialDir : "",
			defaultExt : saveThumbnail?"bmp":"kdt",
			save : true,
		];
		if(Storages.selectFile(selectdata))
		{
			// 保存
			saveBookMarkToFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);
			lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);
		}
	}

	function loadBookMarkFromFileWithAsk()
	{
		// 任意のファイルから栞を読み込む
		var initialdir = "";
		if(lastSaveDataNameGlobal == "")
			initialdir = saveDataLocation + "/";

		var selectdata = %[
			title:"读取存档",
			filter: [saveThumbnail ?
					"带有缩略图的存档(*.bmp)|*.bmp" :
					"存档(*.kdt)|*.kdt"],
			filterIndex : 1,
			name : lastSaveDataNameGlobal,
			initialDir : initialdir,
			defaultExt : saveThumbnail?"bmp":"kdt",
			save : false,
		];
		if(Storages.selectFile(selectdata))
		{
			loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);
			lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);
		}
	}


	function copyBookMark(from, to)
	{
		// 栞番号 from から栞番号 to に栞をコピーする
		if(readOnlyMode) return false;
		if(!isBlank(bookMarks[to]) && bookMarks[to].protectedStates) return;


		var fn = getBookMarkFileNameAtNum(from);

		if(!Storages.isExistentStorage(fn)) return; //ファイルがない

		var data = Scripts.evalStorage(fn);

		fn = getBookMarkFileNameAtNum(to);

		(Dictionary.saveStruct incontextof data)(fn, saveDataMode);
		getBookMarkInfoFromData(data.core, to);
	}

	function eraseBookMark(num)
	{
		// 栞を消す
		// num < numBookMarks の時にしか動作しないようになったので注意
		if(num < numBookMarks)
		{
			if(!bookMarks[num].protectedStates) 
			{
				delete bookMarks[num];
				setBookMarkMenuCaptions();
			}
		}
	}

	function tempDisableStore(elm)
	{
		if(elm.store == void)
			storeEnabled = true;
		else
			storeEnabled = !(+elm.store);

		if(elm.restore == void)
			restoreEnabled = true;
		else
			restoreEnabled = !(+elm.restore);
		onModeChange();
	}

	function setStoreEnabled(enabled)
	{
		// 栞メニューの有効/無効の設定
		storeEnabled = enabled;
		restoreEnabled = enabled;
		// setMenuAccessibleAll();
		onModeChange();
	}

	function setStartAnchorEnabled(enabled)
	{
		// 「最初に戻る」の有効/無効の設定
		startAnchorEnabled = enabled;
		if(enabled){
			storeFlags();
			saveBookMark(999); // 999 番に保存
		}
		// setMenuAccessibleAll();
		onModeChange();
	}

	function goToStart()
	{
		// 最初に戻る
		if(!startAnchorEnabled) return;
		loadBookMark(999, false); // 栞を読み込む
	}

	function goToStartWithAsk()
	{
		// 最初に戻る(確認あり)
        askYesNo("是否回到开始?", "确认", goToStart);
	}

	function tempSave(num)
	{
		// tempBookMarks[num] に現在の状態を保存する
		tempBookMarks[num] = %[];
		internalStoreFlags(tempBookMarks[num]);
	}

	function tempLoad(num, elm)
	{
		// tempBookMarks[num] から状態を読み込む
		internalRestoreFlags(tempBookMarks[num], false, elm);
	}

	function restoreBookMark(num, ask = true)
	{
		// KAG 2.x 互換用
		if(ask)
			return loadBookMarkWithAsk(num);
		else
			return loadBookMark(num);
	}

	function storeBookMark(num, ask = true)
	{
		// KAG 2.x 互換用
		if(ask)
			return saveBookMarkWithAsk(num);
		else
			return saveBookMark(num);
	}

	//------------------------------------------------- 未読/既読/ラベル記録 --
	//当前是否已读	autoRecordPageShowing和autoLabelMode都为false时总为已读true  
	function getCurrentRead()
	{
        // 回想中は常に既読
        if (isRecollection) {
            return true;
        }
		// 节省存储的办法，要求分支时，必须加标签
		return !isBlank(sflags,currentRecordName) && sflags[currentRecordName] >= currentTextNum;
		// 简单强大但需要存储的方法
		//  return !isBlank(scflags[currentRecordName+"_"+currentTextNum]);
	}

	// 自动记录标签通过的情况下，记录当前的标签名称
	function setRecordLabel(storage, label)
	{
		if(label != '')
		{
			if(label[0] == '*') label = label.substring(1);
			if(label[1] == '-') return; // ローカルラベル
		}
		currentRecordName = 'trail_' + Storages.chopStorageExt(
			Storages.extractStorageName(storage)) + '_' + label;
	}

	function markAsRead(){
		// 节省存储的办法，要求分支时，必须加标签
		sflags[currentRecordName]  = currentTextNum if(sflags[currentRecordName]<currentTextNum);
		// 简单强大但需要存储的方法
		//  sflags[currentRecordName+"_"+currentTextNum] = true;
	}

	//------------------------------------------- システム全体に関係するもの --

	function setTitle(title)
	{
		// タイトルを設定
		if(isMain) System.title = title;
		caption = title;
	}

	function setCursor(elm)
	{
		// マウスカーソルの設定
		var conv = function(variable, value)
		{
			if(value !== void)
			{
				if(!(typeof value == "String" &&
					(value.indexOf('.cur')!=-1 || value.indexOf('.ani')!=-1) ))
						value = +value;
				this[variable] = value;
			}
		} incontextof this;

		conv('cursorDefault', elm['default']); 
		conv('cursorPointed', elm.pointed);
		conv('cursorWaitingClick', elm.click);
		conv('cursorDraggable', elm.draggable);
		fore.base.setDefaultCursor(cursorDefault);
		back.base.setDefaultCursor(cursorDefault);
	}

	//---------------------------------------------------- トリガ管理(TJS用) --

	function waitTrigger(elm)
	{
		// elm.name で示されたトリガを待つ
		if((elm.canskip !== void && +elm.canskip) && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ動作中
				if(elm.onskip !== void) Scripts.eval(elm.onskip);
				return 0; // すぐに返る
			}
			conductor.wait(%[
				click : function(arg)
				{
					if(arg !== void) Scripts.eval(arg);
				} incontextof this,
				click_arg : elm.onskip,
				elm.name => function
				{
				} incontextof this
				]);
		}
		else
		{
			conductor.wait(%[
				elm.name => function
				{
				} incontextof this
				]);
		}
		return -2;
	}

	function trigger(name)
	{
		// name で示したトリガを発動する
		conductor.trigger(name);
	}

	//------------------------------------------------------- メッセージ履歴 --

	function showHistory()// todo 以后去掉
	{
		// メッセージ履歴レイヤを表示する
		historyLayer.parent = fore.ui; // メッセージ履歴レイヤの親も再設定
        historyLayer.absolute = 4000000;
		historyLayer.dispInit();
		historyShowing = true;
		if(typeof this.showHistoryMenuItem != "undefined")
			showHistoryMenuItem.checked = true;
		setMenuAccessibleAll();
	}

	function hideHistory()
	{
		// メッセージ履歴レイヤを非表示にする
		historyShowing = false;
		historyLayer.visible = false;
		// setMenuAccessibleAll();  // 这个将来只会用在恢复存档时，这里就不改了
	}

	function setHistoryOptions(elm)
	{
		// elm からメッセージ履歴レイヤのオプションを設定する
		historyWriteEnabled = +elm.output if elm.output !== void;
		historyEnabled = +elm.enabled if elm.enabled !== void;

		historyLayer.setOptions(elm); // その他のオプション
		// setMenuAccessibleAll();
		onModeChange();
	}

    //------------------------------------------------------- 選択肢 --

    function setSelectOptions(elm)
	{
        selectLayer.setOptions(elm);
	}

    function addSelect(elm) {
        selectLayer.addSelect(elm);
    }

    /**
     * 選択肢の表示
     */
	function showSelect()
	{
        selectLayer.start(fore.base, 1000000);
        selectShowing = true;
	}

    function hideSelect() {
        selectLayer.done();
        selectShowing = false;
    }
    
    function afterSelect() {
        if (afterauto && selectPrevAutoMode) {
            enterAutoMode();
        }
        if (afterskip && selectPrevSkipMode) {
            skipMode = selectPrevSkipMode;
            actualChSpeed = 0;
        }
        // setMenuAccessibleAll();
		onModeChange();
    }

    function doneSelect()
	{
        hideSelect();
        afterSelect();
    }

    //------------------------------------------------------- マップ選択肢 --

    /**
     * マップ選択肢初期化
     */
    function initMapSelect()
    {
        mapSelectLayer.init();
	}

    /**
     * マップ選択肢オプション
     */
    function setMapSelectOptions(elm)
	{
        mapSelectLayer.setOptions(elm);
	}

    /**
     * ボタン登録
     */
    function addMapSelectButton(elm) {
        mapSelectLayer.addButton(elm);
    }

    /**
     * 場所登録
     */
    function addMapSelectPosition(elm) {
        mapSelectLayer.addPosition(elm);
    }

    /**
     * 選択肢登録
     */
    function addMapSelect(elm) {
        mapSelectLayer.addSelect(elm);
    }
    
    function showMapSelect()
	{
        mapSelectLayer.start(fore.base, 1000000);
        mapSelectShowing = true;
	}

    function hideMapSelect()
	{
        mapSelectLayer.done();
        mapSelectShowing = false;
    }
    
    function doneMapSelect()
	{
        hideMapSelect();
        afterSelect();
    }
    
	//-------------------------------------------------------------- process --
	//关闭对话框  自动已读 重设文字速度	  （首次执行）设置存档变量  通知系统不稳定状态的回调 开始执行
	function process(file, label,countPage, immediate = false) //todo 这里去掉了第三个参数,以后检查下引用
	{
        closeDialog();

        // 指定ファイル、指定ラベルから実行を開始する

		setUserSpeed();

		if(file != '')
		{
			if (!usingExtraConductor) {
				loopVoiceInfo.clear();
			}
			// ファイルを読み込み
            conductor.loadScenario(file);
		}

		if(label != '')
		{
			// ラベルに移動する
			conductor.goToLabel(label);
		}

		if(isFirstProcess)	//第一次执行则设置 存档变量
		{
			storeFlags(); // 一番最初の状態をストア
			isFirstProcess = false;
		}

		dm("start processing");
		inSleep = false;
		notifyRun();
		if(conductor.status != conductor.mRun) conductor.run(immediate); // 実行開始
    }

	function processGo()
	{
        // コンダクタを現在位置から実行開始させる
		dm("start processing");
		inSleep = false;
		notifyRun();
		conductor.run(false); // 実行開始
	}

	function processCall(file, label)
	{
		// 指定ファイル、指定ラベルを呼ぶ
		if(file != '')
		{
			// ファイルを読み込み
			conductor.loadScenario(file);
		}

		inSleep = false;
		notifyRun();
		conductor.callLabel(label); // 実行開始
		dm("start processing");
		if(conductor.status != conductor.mRun) conductor.run();
	}

	//------------------------------------------------- conductor event コンダクタのイベント ----------------

	function onConductorScenarioLoad(name)
	{
        prevSkipMode = void;
		/*
		//在读入新剧本文件之前调用。
		name是要读取的脚本文件。
		如果在返回值中返回字符串，则将其作为脚本代替文件使用，因此可以在这里写过滤器。
		如果返回true，则读取通常的脚本文件。*/
        // コンダクタが新しいシナリオファイルを読み込む前によばれる。
		// name は読み込もうとしたシナリオファイル。
		// 戻り値に文字列を返すと、それをシナリオとして
		// ファイルの代わりに使うようになるので、ここにフィルタを書くこ
		// とができる。
		// true を返すと通常のシナリオファイル読み込みとなる。
		return true;
	}


	function onConductorScenarioLoaded(name)
	{
        return true;
	}

	//读到标签时的回调  
	/*
		如果使用主指令控制器，记录当前标签的存储名, 如果不是自动标签，还会增加标签已读计数，检查是否已读状态，并可能取消快进
		如果带有标签名 会检查是否设置了到下一个为止进行存储，并进行操作
		存储当前的系统状态
		自动记录通过履历为1时，这这里会自动nextRecordHistory 为true，下一个标签时仍会存储
	*/
	function onConductorLabel(label, page)
	{	
        // コンダクタがラベルを通過した
		if(!usingExtraConductor)
		{
            setRecordLabel(conductor.curStorage, label);// 设置 记录当前记录名称
		}
		setUserSpeed();
		if(!usingExtraConductor) 
		{
            
			if(!(allskip || getCurrentRead()) && skipMode != 4)
				cancelSkip(); // 未読なのでスキップを停止
			currentStorage = conductor.curStorage;
            currentLabel = label;
		}
		if(page !== void && page !== '')
		{
			if(page[0] == '&') page = Scripts.eval((page.substring(1)));
			currentPageName = page;
		}
		/*if(page !== void)// autolabel会进入此处理，=== 与 == 并不一样请注意
		{
			pushHistoryOfStore();	// 存入旧存档数据到履历
			stablePosibility = false; // 每遇到一个标签记为不可存储，直到遇到下一个可存储点
			dm(conductor.curStorage + " : 标签/页 : " + label + "/" + currentPageName);
			if(usingExtraConductor) 
				throw new Exception("in the right click /extraCondutor  sub routing program cann't add scenario tag that can save bookmark");
			storeFlags(), storeLabelPassed = true, setMenuAccessibleAll(); // 把新的变量放入 
			if(recordHistoryOfStore == 1) // 1 : 保存可能なラベルごと
				setToRecordHistory();
		}*/

        if (label.substring(0,12) == "*kaisouBegin") {

            // 回想用の記録処理を行う
            var num = (int)label.substring(12);
            saveBookMark(recollectionBookmark + num);

        } else if (label.substring(0,10) == "*kaisouEnd") {//TODO 回想模式的设置

            // 回想終了
            if (label == recollectionEndLabel) {
                endRecollection();
            }
            
        }
		return true;
	}

	function onConductorJump(elm)
	{
		return true;
	}

	function onConductorCall(elm)
	{
		return true;
	}

	function onConductorReturn(elm)
	{
		if(conductor === extraConductor)//使用预备指令处理器	说明为右击呼叫中
		{
			// extraConductor サブルーチン用のコンダクタから呼ばれている
			if(conductor.callStackDepth == 1)
			{
				// つまり、最終の return が実行されたと言うこと
				dm("come back from extraConductor subprogram ...");
				var run;
				if(elm.storage !== void || elm.target !== void) run = true; else run = false;
				returnExtraConductor(run);
				if(elm.storage !== void) conductor.loadScenario(elm.storage);
				if(elm.target !== void) conductor.goToLabel(elm.target);
				setRecordLabel(currentStorage = conductor.curStorage, currentLabel = conductor.curLabel);
				if(run)
				{
					notifyRun();
					conductor.run();
				}
				isLeavePeriodEvent = false;
				if(elm.storage !== void || elm.target !== void)	// return时直接jump则废弃所有视频的事件
				{	// returnで元の位置以外に戻る時はピリオドイベントをクリアする。
					holdPeriodEventQueue.clear();
					isWaitPeriodEvent = false;
				}
				if( isWaitPeriodEvent == true )//否则继续触发这些事件
				{	// [wp]でピリオドイベント待ちをしている時のみ、トリガーする
					fireMoviePeriodFromQueue();
				}
				return false; // return は実行しない
			}
		}
		return true;
	}
	//清空视频的等待事件
	function purgeMoviePeriod()
	{
		isLeavePeriodEvent = false;
		holdPeriodEventQueue.clear();
		isWaitPeriodEvent = false;
		waitedPeriodEventStorageName = void;
	}
	function fireMoviePeriodFromQueue()//触发视频的等待事件
	{
		var retVal = false;
		if( holdPeriodEventQueue.count > 0 )
		{
			if( waitedPeriodEventStorageName == conductor.curStorage && conductor == mainConductor )
			{
				for( var i = 0; i < holdPeriodEventQueue.count; i++ )
				{
					conductor.trigger( holdPeriodEventQueue[i] );
					retVal = true;
				}
			}
			holdPeriodEventQueue.clear();
		}
		return retVal;
	}

	function onConductorAfterReturn()
	{	
		// コンダクタが return タグを実行した後
		if(!usingExtraConductor)
		{	dm("afterReturn method:"+conductor.curStorage+" "+ conductor.curLabel);
			setRecordLabel(currentStorage = conductor.curStorage, currentLabel = conductor.curLabel);
		}
		setUserSpeed();
		if(!usingExtraConductor)
		{
            if(!(allskip || getCurrentRead()) && skipMode != 4)
                cancelSkip(); // 未読なのでスキップを停止
		}
    }

	function onConductorBeforeTag(tag, elm)
	{
		return void;
	}

	function onConductorScript(script, scriptname, lineofs)
	{
		// iscript タグ
		try
		{
			Scripts.exec(script, scriptname, lineofs);
		}
		catch(e)
		{
			throw new ConductorException("the iscript block in " + lineofs + " lines of " + scriptname +
				" occured error.\n( open console to check detail )\n" + e.message);
		}
		return true;
	}

    var unknownHandler;
    
	function onConductorUnknownTag(tagname, elm)
	{
        var ret;
        if (unknownHandler === void || (ret = unknownHandler(tagname,elm)) === void) {
            // 不明なタグがあった場合
            throw new Exception("tag/macro \"" + tagname + "\" doesn't exist");
        } else {
            return ret; // この戻り値は、各タグハンドラが返す物とおなじ
        }
	}

	//----------------------------------------------------------- stable/run ------------
	// 给插件们通知系统进入稳定状态的回调
	function notifyStable()
	{
		// システムが安定(クリック待ち/停止)したときに、ハンドラを呼ぶ
		if(!inStable)
		{
			inStable = true;
			var handlers = stableHandlers;
			for(var i = handlers.count-1; i>=0; i--)
				handlers[i]();

			// stableHook
			forEachEventHook('onStableStateChanged',
				function(handler, f) { handler(f.stable); } incontextof this,
				%[stable:true]);
        }
	}
	// 系统开始执行时调用   设置状态为不稳定状态，执行各个处理器  执行插件的回调	 自动模式下还会隐藏鼠标
	function notifyRun()
	{
		// システムが走り始めたときに、ハンドラを呼ぶ		系统开始执行时 调用处理器
		if(inStable)
		{
			inStable = false;			
			var handlers = runHandlers;
			for(var i = handlers.count-1; i>=0; i--)
				handlers[i]();

			// runHook
            forEachEventHook('onStableStateChanged',
				function(handler, f) { handler(f.stable); } incontextof this,
				%[stable:false]);
            
			if(autoMode) hideMouseCursor();
		}
	}
	// 默认的稳定状态处理器 重置菜单状态
	function defaultStableHandler()
	{
		// デフォルトの stable ハンドラ
		// setMenuAccessibleAll();
		onModeChange();
	}
	// 默认的运行状态处理器 隐藏履历层 隐藏换页换行等待标志 显示消息层 重置菜单状态
	function defaultRunHandler()
	{
		// デフォルトの run ハンドラ
		// hideHistory();
		showMessageLayerByUser();
		// setMenuAccessibleAll();
		onModeChange();
	}

	//----------------------------------------------------------- 文字列入力 --

	var inputTemp;
	function inputString(elm)
	{
		// 文字列を入力する
		var name = elm.name;
		var initial = Scripts.eval(name);
		var res = System.inputString(elm.title, elm.prompt, initial);
		if(res !== void)
		{
			// name に res を代入する
			inputTemp = res;
			Scripts.eval(("(" + name + ") = kag.inputTemp"));
		}
	}

	//-------------------------------------------------- extraConductor 処理 --
	// 使用预备指令处理器处理剧本   会先锁定选择层，保存消息层状态
	function callExtraConductor(storage, label, onreturn)
	{
		// extraConductor を使ってサブルーチンを呼び出す
		onExtraConductorReturn = onreturn;
		inSleepBeforeExtraConductor = inSleep; // inSleep 保存
		storeMessageLayerSelProcessLock(); // メッセージレイヤの storeSelProcessLock を呼ぶ
        selectLayer.lockFocus();	//禁止选择层聚焦
        mapSelectLayer.lockFocus();
        conductor = extraConductor; // コンダクタを切り替える	切换指令处理器
		(Dictionary.assign incontextof extraConductor.macros)(mainConductor.macros);
			// マクロはコピー
		usingExtraConductor = true;
		if(storage == '')
		{
			// ストレージ指定がないので現在のストレージを読み込ませる
			storage = mainConductor.curStorage;
		}

		// 呼び出す
		conductor.clearCallStack();
		processCall(storage, label);
	}
	//右击菜单恢复时的回调方法
	function returnExtraConductor(run)
	{
		// extraConductor のサブルーチンから戻る
		// run が true の場合は 待機状態の復帰は行わない

		conductor.sleep(); // 停止
		conductor.interrupt();
			// interrupt は コンダクタのイベント内でコンダクタの実行を
			// 停止させるためのメソッド
		conductor = mainConductor; // コンダクタを切り替え
		(Dictionary.assign incontextof mainConductor.macros)(extraConductor.macros);
			// マクロはコピー
		usingExtraConductor = false;
		if(!run)
		{	
			inSleep = inSleepBeforeExtraConductor; // inSleep 復帰
			notifyStable();
		}
        mapSelectLayer.unlockFocus();
        selectLayer.unlockFocus();
        restoreMessageLayerSelProcessLock(); // メッセージレイヤの restoreSelProcessLock を呼ぶ
		cancelSkip();
		if(onExtraConductorReturn !== void) onExtraConductorReturn();
		onModeChange();	// 因为上面的调用会导致systemhook的currentstate改变，所以这里调用
	}

	//------------------------------------------------------- 右クリック処理 --
	//右击事件的设置
	function setRightClickOptions(elm)
	{
		// 右クリックのオプションを設定する
		rightClickEnabled = +elm.enabled if elm.enabled !== void;
		if(elm.call !== void)
		{
			rightClickCall = +elm.call;
			if(rightClickCall) rightClickJump = false;
		}
		if(elm.jump !== void)
		{
			rightClickJump = +elm.jump;
			if(rightClickJump) rightClickCall = false;
		}
		rightClickTarget = elm.target if elm.target !== void;
		rightClickStorage = elm.storage if elm.storage !== void;
		if(elm.name !== void)
		{
			if(typeof this.rightClickMenuItem != "undefined")
			{
				rightClickName = elm.name;
				if(rightClickName == "default")
					rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickDefaultName;
				else
					rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickName;
			}
		}
	}
	//call式呼叫右击菜单 使用预备指令处理器
	function callRightClickSubRoutine()
	{
		isLeavePeriodEvent = true;

		// 右クリックサブルーチンを呼ぶ
		if(typeof this.rightClickMenuItem != "undefined")
		{
			rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickDefaultName;
		}

		callExtraConductor(rightClickStorage, rightClickTarget, restoreFromRightClick);

		lockMessageLayerSelProcess(); // 選択肢ロック
	}
	//设置菜单上的右击菜单  呼叫右击结束后使用
	function restoreFromRightClick()
	{
		// 右クリックサブルーチンから抜けるときに呼ばれる
		if(typeof this.rightClickMenuItem != "undefined")
		{
			if(rightClickName == "default")
				rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickDefaultName;
			else
				rightClickMenuItem.caption = rightClickCurrentMenuName = rightClickName;
		}
	}

	function setConductorToMain()
	{
		// restore の時に呼ばれ、コンダクタを main に切り替える
		if(usingExtraConductor)
		{
			extraConductor.sleep();
			extraConductor.interrupt();
			conductor= mainConductor;
			usingExtraConductor = false;
		}
	}
	//jump式鼠标右击	不使用预备指令处理器
	function jumpToRightClickTarget()
	{
		process(rightClickStorage, rightClickTarget);
	}
	//	鼠标右击事件
	function onPrimaryRightClick()
	{
		// プライマリレイヤで右クリックされたときに呼ばれる
		if(!callHook(rightClickHook))
		{
			if(getKeyState(VK_LBUTTON))//左击同时右击进入自动模式
			{
				enterAutoMode();
				return;
			}
			if(!rightClickEnabled) return;
			if(inStable)
			{
				if(rightClickJump)
					jumpToRightClickTarget();
				else if(rightClickCall && conductor == mainConductor)
					callRightClickSubRoutine();
				else
					switchMessageLayerHiddenByUser();
			}
			onModeChange();
			// setMenuAccessibleAll();
		}
	}

	//------------------------------------------------------- 前景レイヤ処理 --
	/**
	*分配前景层
	* num 数量 reorder 是否重排序  level重排序的起始高度
	*/
    function allocateCharacterLayers(num, reorder=true, level=0) 
	{
		// 前景レイヤ数を num に設定する
		if(fore.layers.count > num)
		{
			// レイヤが減る
			for(var i = num; i<fore.layers.count; i++)
			{
				invalidate fore.layers[i];
				invalidate back.layers[i];
			}
			fore.layers.count = num;
			back.layers.count = num;
		}
		else if(fore.layers.count < num)
		{
            // レイヤが増える
            if (reorder) {
                for(var i = fore.layers.count; i<num; i++)
                {
                    fore.layers[i] = new CharacterLayer(this, fore.base, "表前景レイヤ" + i, i, level);
                    back.layers[i] = new CharacterLayer(this, back.base, "裏前景レイヤ" + i, i, level);
                    fore.layers[i].setCompLayer(back.layers[i]);
                    back.layers[i].setCompLayer(fore.layers[i]);
                }
                reorderLayers(true, false);
            } else {
                // 該当レベルで最大の index 値をさがす
                var foreindex = (level + 1) * 100000;
                var backindex = (level + 1) * 100000;
                for (var i=0; i<fore.layers.count;i++) {
                    if (fore.layers[i].level == level && fore.layers[i].absolute > foreindex) {
                        foreindex = fore.layers[i].absolute;
                    }
                    if (back.layers[i].level == level && back.layers[i].absolute > backindex) {
                        backindex = back.layers[i].absolute;
                    }
                }
                foreindex += 100;
                backindex += 100;
                
                for(var i = fore.layers.count; i<num; i++) {
                    fore.layers[i] = new CharacterLayer(this, fore.base, "表前景レイヤ" + i, i, level);
                    back.layers[i] = new CharacterLayer(this, back.base, "裏前景レイヤ" + i, i, level);
                    fore.layers[i].setCompLayer(back.layers[i]);
                    back.layers[i].setCompLayer(fore.layers[i]);
                    fore.layers[i].absolute = foreindex;
                    back.layers[i].absolute = backindex;
                    foreindex += 100;
                    backindex += 100;
                }
            }
        }
		numCharacterLayers = num;
	}

	//------------------------------------------------- メッセージレイヤ処理 --消息层处理
	//重新分配消息层
	function allocateMessageLayers(num, setdefaultfont = true)
	{
		// メッセージレイヤ数を num に設定する
		if(fore.messages.count > num)
		{
			// レイヤが減る
			for(var i = num; i<fore.messages.count; i++)
			{
				if(current == fore.messages[i] || current == back.messages[i])
					current = fore.messages[0], currentNum = 0, currentPage = 0;
				invalidate fore.messages[i];
				invalidate back.messages[i];
			}
			fore.messages.count = num;
			back.messages.count = num;
		}
		else if(fore.messages.count < num)
		{
			// レイヤが増える
			for(var i = fore.messages.count; i<num; i++)
			{
				fore.messages[i] = new MessageLayer(this, fore.ui, "fore message layer" + i, i, true);
				back.messages[i] = new MessageLayer(this, back.ui, "back message layer" + i, i, true);
				fore.messages[i].setCompLayer(back.messages[i]);
				back.messages[i].setCompLayer(fore.messages[i]);
				fore.messages[i].clear();
				back.messages[i].clear();
			}
			reorderUiLayer(false, true);
			if(setdefaultfont) setMessageLayerUserFont();
		}
		numMessageLayers = num;
	}
	//重新分配ui层
	function allocateUiLayers(num)
	{
		// メッセージレイヤ数を num に設定する
		if(fore.uiLayers.count > num)
		{
			// レイヤが減る
			for(var i = num; i<fore.uiLayers.count; i++)
			{
				if(current == fore.uiLayers[i] || current == back.uiLayers[i])
					current = fore.uiLayers[0], currentNum = 0, currentPage = 0;
				invalidate fore.uiLayers[i];
				invalidate back.uiLayers[i];
			}
			fore.uiLayers.count = num;
			back.uiLayers.count = num;
		}
		else if(fore.uiLayers.count < num)
		{
			// レイヤが増える
			for(var i = fore.uiLayers.count; i<num; i++)
			{
				fore.uiLayers[i] = new DialogLayer(this, fore.ui, "fore ui layer" + i, i, true);
				back.uiLayers[i] = new DialogLayer(this, back.ui, "back ui layer" + i, i, true);
				fore.uiLayers[i].setCompLayer(back.uiLayers[i]);
				back.uiLayers[i].setCompLayer(fore.uiLayers[i]);
			}
			reorderUiLayer(true, false);
		}
		numUiLayers = num;
	}

	function setCurrentMessageLayer(elm)
	{
		// 現在のメッセージレイヤを設定
		currentNum = elm.layer == 'message'? currentNum :+elm.layer.substr(7);;
		currentPage = elm.page == 'back'?1: 0;;
		if(currentPage) current = back.messages[currentNum]; 
		else current = fore.messages[currentNum];
		currentWithBack = +elm.withback if elm.withback !== void;
	}

	//清空消息层 参数为真则清空当前使用的是哪个消息层的信息
	function clearMessageLayers(resetcurrent)
	{
		// すべてのメッセージレイヤのクリア
		// ct タグから呼ばれる
		// resetcurrent が true の場合は現在のメッセージレイヤを
		// 表0に設定する

		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].clear(true);
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].clear(true);
		if(resetcurrent)
		{
			currentNum = 0;
			currentPage = 0;
			current = fore.messages[0];
			currentWithBack = false;
		}
	}
	function hideUiLayer(base=fore){
		historyLayer.visible = false;
		var layers = base.messages;
		for(var i = layers.count-1; i >= 0; i--)
			layers[i].visible = false;
		layers = base.uiLayers;
		for(var i = layers.count-1; i >= 0; i--)
			layers[i].visible = false;
	}

	function lockMessageLayerSelProcess()
	{
		// すべてのメッセージレイヤに 選択とprocessを禁止させる
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(true);
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(true);
		messages = fore.uiLayers;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(true);
		messages = back.uiLayers;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(true);
	}

	function unlockMessageLayerSelProcess()
	{
		// すべてのメッセージレイヤの選択を許可する
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(false);
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(false);
		messages = fore.uiLayers;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(false);
		messages = back.uiLayers;
		for(var i = messages.count-1; i >= 0; i--) messages[i].setSelProcessLock(false);
	}
	//设置消息层默认的字体和抗锯齿  TODO  增加名称层字体设置
	function setMessageLayerUserFont()
	{
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--){
			messages[i].antialiased = chDefaultAntialiased;
			messages[i].redraw();
		}
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--){
			messages[i].antialiased = chDefaultAntialiased;
			messages[i].redraw();
		}
	}
	// 存储消息层的锁定点击状态
	function storeMessageLayerSelProcessLock()
	{
		// すべてのメッセージレイヤの storeSelProcessLock を呼び出す
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].storeSelProcessLock();
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].storeSelProcessLock();
	}

	function restoreMessageLayerSelProcessLock()
	{
		// すべてのメッセージレイヤの restoreSelProcessLock を呼び出す
		var messages;
		messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].restoreSelProcessLock();
		messages = back.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].restoreSelProcessLock();
	}
	//显示（隐藏）消息层，会同时显示（隐藏）选择层 
	function setMessageLayerHiddenState(b)
	{
		var layers;
		layers = fore.messages;
        for(var i = layers.count-1; i >= 0; i--) layers[i].setHiddenStateByUser(b);
        layers = fore.layers;
		for(var i = layers.count-1; i >= 0; i--) layers[i].setHiddenStateByUser(b);

        selectLayer.setHiddenStateByUser(b);
        //mapSelectLayer.setHiddenStateByUser(b);
        
		// プラグインを呼ぶ
		forEachEventHook('onMessageHiddenStateChanged',
			function(handler, f) { handler(f.hidden); } incontextof this,
			%[hidden:b]);
	}

    // メッセージレイヤ状態を同期	同步里层状态
    function syncMessageLayer() {
        var messages = back.messages;
        for(var i = messages.count-1; i >= 0; i--) messages[i].assignComp();
    }
	//用户隐藏消息层 会同时隐藏选择层,同时控制菜单的勾选状态
	function hideMessageLayerByUser()
	{
        // メッセージレイヤを一時的に隠す
		if(messageLayerHiding) return;
		setMessageLayerHiddenState(true);
		messageLayerHiding = true;
		fore.base.cursor = cursorWaitingClick;
		if(autoMode)cancelAutoMode();
		if(skipMode)cancelSkip();
		// setMenuAccessibleAll();
		onModeChange();
	}
	//用户显示消息层 会同时显示选择层,同时控制菜单的勾选状态
	function showMessageLayerByUser()
	{
        // 一時的に隠されていたメッセージレイヤを元に戻す
		if(!messageLayerHiding) return;
        setMessageLayerHiddenState(false);
		if(typeof this.rightClickMenuItem !== "undefined")
			rightClickMenuItem.checked = false;
		messageLayerHiding = false;
		conductor.trigger('message'); // 'message' を送る
		if(clickWaiting)
			fore.base.cursor = cursorWaitingClick;
		else
			fore.base.cursor = cursorDefault;
		// setMenuAccessibleAll();
		onModeChange();
	}

	function switchMessageLayerHiddenByUser()
	{
		// メッセージレイヤの非表示/表示を切り替える
		if(messageLayerHiding) showMessageLayerByUser(); else hideMessageLayerByUser();
	}

	function hideMessageLayerByScenario(elm)
	{
		// シナリオからメッセージを一時的に隠す
		hideMessageLayerByUser();
		conductor.wait(%[ // コンダクタを待ちに
			message : function
			{
				// やることなし
			} incontextof this
			]);
		return -2; // break
	}

    function setCurrentMessageLayerVisibleFast(page, visible) {
        var base = page == 0 ? fore : back;
        base.messages[currentNum].visible = visible;
        forEachEventHook('onCurrentMessageVisibleChanged',
                         function(handler, f) { handler(f.hidden, f.page); } incontextof this,
                         %[hidden:!visible, page:page]);
    }
    
    /**
     * 現在のメッセージ窓の表示状態の変更  变更目前消息层可见状态
     * @param visible	是否可见
     * @return 処理の待ちが必要な場合は true を返す	需要等待处理的情况返回为true
     */
    function setCurrentMessageLayerVisible(visible) {

        var fadeTime = messageFadeTime * drawspeed;
        
        if (fore.messages[currentNum].visible != visible) {
            if (!skipMode && fadeTime > 0) {

                // 裏は先に消しておく。そうしないと msgvisible がとんでしまって  先设置里层，否则里层fadeDone完成会触发msgvisible
                // せっかくの待ちが解除される
                back.messages[currentNum].visible = visible;
                
                // 処理待ち
                var layer = fore.messages[currentNum];
                layer.setVisibleTime(visible, fadeTime);

                conductor.wait(%[
                click : function(layer) {
                    updateBeforeCh = 1;
                    layer.fadeDone();
                } incontextof this,
                'click_arg' => layer,
                msgvisible : function() {
                    updateBeforeCh = 1;
                } incontextof this
                    ]);

                forEachEventHook('onCurrentMessageVisibleChanged',
                                 function(handler, f) { handler(f.hidden, f.page); } incontextof this,
                                 %[hidden:!visible, page:0]);
                
                return true;
            } else {
                fore.messages[currentNum].visible = visible;
                forEachEventHook('onCurrentMessageVisibleChanged',
                                 function(handler, f) { handler(f.hidden, f.page); } incontextof this,
                                 %[hidden:!visible, page:0]);
                back.messages[currentNum].visible = visible;
            }
        }
        return false;
    }

	function selectFont()
	{
		try {
			var flags = fsfSameCharSet | fsfNoVertical | fsfTrueTypeOnly | fsfUseFontFace;
			// if(showFixedPitchOnlyInFontSelector) flags |= fsfFixedPitch;
			var currentFont = chUserFace[SystemLanguage.mainLan]||chDefaultFace[SystemLanguage.mainLan];
			var dlg = new MyFontSelectDialog(primaryLayer, currentFont, flags,"字体选择","请选择字体");//TODO 提示语句做成不一样的
			var r = dlg.open(kag);
			invalidate dlg;
			if(!isBlank(r)){
				chUserFace[SystemLanguage.mainLan] = r;
				setMessageLayerUserFont();
			}else r = currentFont;
			return r;
		} catch {}
	}

	function mapPrerenderedFont(storage)// deprecated 目前没做这种方法，没效果
	{
		// レンダリング済みフォントを現在の操作対象のレイヤに選択
		// されているフォントにマッピングする
		current.font.mapPrerenderedFont(storage);
	}

    //------------------------------------------------- レイヤを正しい順序に --

    // 指定したレイヤを指定したレベルに移動する	
	//将base的第n层移动到第newLevel的高度，同时调整其他层的高度
    function toLevel(n, newlevel, base) {
        if (base === void) {
            base = fore;
        }
        if (n === void) {
            return;
        }
        n = +n;
        newlevel = +newlevel;
        if (n < base.layers.count) {
            
            var level = base.layers[n].level;
            if (level == newlevel) {
                return;
            }
            var index = base.layers[n].absolute;
            // もともといたレベルの調整
            for (var i = 0; i<base.layers.count; i++) {
                if (i != n && base.layers[i].level == level) {	//对于指定的所有和n的level一样的层
                    if (base.layers[i].absolute > index) {	//如果比当前的n层z轴高
                        base.layers[i].absolute -= 100;	//则降低高度
                    }
                }
            }
            // 新規レベルの一番上にもっていく
            var newindex = (newlevel + 1) * 100000;
            for (var i = 0; i<base.layers.count; i++) {	
                if (i != n && base.layers[i].level == newlevel && base.layers[i].absolute > newindex) {//对于指定的所有和n的newLevel一样的层，如果其高度比新高度高
                    newindex = base.layers[i].absolute;		//则新高度指定为该高度
                }
            }
            newindex += 100;
            //dm("等级设定:" + newlevel + ":" + newindex);
            base.layers[n].absolute = newindex;
            base.layers[n].level = newlevel;
        }
    }
    
    // 同じレベルのレイヤの中で最前列に移動		将base层的第n层移动到最高层
    function toFront(n, base) {
        if (base === void) {
            base = fore;
        }
        if (n !== void && n < base.layers.count) {
            var level = base.layers[n].level;
            var index = base.layers[n].absolute;
            var maxindex = index;
            for(var i = 0; i<base.layers.count; i++) {
                if (i != n && base.layers[i].level == level) {
                    if (base.layers[i].absolute > maxindex) {
                        maxindex = base.layers[i].absolute;
                    }
                    if (base.layers[i].absolute > index) {
                        base.layers[i].absolute -= 100;
                    }
                }
            }
            base.layers[n].absolute = maxindex;
        }
    }

    // レイヤを最後列に		将base层的第n层移动到最低层
    function toBack(n, base) {
        if (base === void) {
            base = fore;
        }
        if (n !== void && n < base.layers.count) {
            var level = base.layers[n].level;
            var index = base.layers[n].absolute;
            var minindex = index;
            for(var i = 0; i<base.layers.count; i++) {
                if (i != n && base.layers[i].level == level) {
                    if (base.layers[i].absolute < minindex) {
                        minindex = base.layers[i].absolute;
                    }
                    if (base.layers[i].absolute < index) {
                        base.layers[i].absolute += 100;
                    }
                }
            }
            base.layers[n].absolute = minindex;
        }
    }
	/**
	重新排列层的顺序
	舞台层总是固定为100
	ch为true则会调整，前景层高度相同的层仍会保持一致
	事件层总是固定为 699900
	msg为true则会重新排列消息层， 消息层总会按存在数组内顺序由低到高排列
	履历层总会固定为 4000000
	*/
    function reorderLayers(ch=true, msg=true)
	{
        // ステージレイヤ
        fore.stage.absolute = 100;
        back.stage.absolute = 100;

        // レイヤを正しい順序に並び替える
        if (ch) {
            var indexes = %[];
            for(var i = 0; i<fore.layers.count; i++)
            {
                var level = fore.layers[i].level;
                var index = indexes[level];
                if (index === void) {
                    index = (level + 1) * 100000;
                }
                fore.layers[i].absolute = index;
                back.layers[i].absolute = index;
                index += 100;
                indexes[level] = index;
            }
        }
        // イベントレイヤ
        fore.event.absolute = 6 * 100000 - 100;
        back.event.absolute = 6 * 100000 - 100;
	}
	/** 
	* @description: 	重新对ui层排序
	* @param ui		是否重排ui层
	* @param msg	是否重排消息层
	* @return void
	*/	
	function reorderUiLayer(ui,msg){
		var index = 1000000;
		if(ui)for(var i = 0; i<fore.messages.count; i++)
		{
			fore.messages[i].absolute = index;
			back.messages[i].absolute = index;
			index += 1000;
		}
		if(msg)for(var i = 0; i<fore.uiLayers.count; i++)
		{
			fore.uiLayers[i].absolute = index;
			back.messages[i].absolute = index;
			index += 1000;
		}
		historyLayer.absolute = 4000000;
		backHistoryLayer.absolute = 4000000;
	}

	//--------------------------------------------- 属性->レイヤオブジェクト --
	//从字典中取得层
	function getLayerFromElm(elm, prefix = '')
	{
		// elm に指定されている page と layer 属性から、該当する
		// オブジェクトを返す
		// prefix には、属性名の前につけるプレフィクスを指定する
		var base;
		if(elm[prefix + 'page'] == 'back') base = back; else base = fore;
		var layer = elm[prefix + 'layer'];
		if(layer == 'base') return base.base; // 背景
		if( layer == 'uibase') return base.ui; // ui背景
		if(layer == 'stage') return base.stage; // 舞台
		if(layer == 'event') return base.event; // イベント
		if(layer == 'history')return base == fore ?historyLayer:backHistoryLayer;
		if(layer[0] == 'm')
		{
			// message? ( ? = 数値 )
			// ここではあまり厳密にエラーチェックはしない
			if(layer == 'message') return base.messages[currentNum];
			return base.messages[+layer.substr(7)];
		}
		if(layer.indexOf("ui") == 0)		// ui层
		{
			return base.uiLayers[+layer.substr(2)];
		}
		return base.layers[+layer];	// 前景层
	}
	//与上面的方法类似,但是不会检查page 属性，backlay 为 true 为里层、false 为表层
	function getLayerPageFromElm(elm, backlay)
	{
		// getLayerFromElm と似ているが、page 属性まではみない。
		// backlay が true のときは裏、false の時は表のレイヤを返す。
		// elm.layer が void の時は背景レイヤを帰す
		var base = backlay?back:fore;
		var layer = elm.layer;
		if(layer === void || layer == 'base') return base.base; // 背景
		if( layer == 'uibase') return base.ui; // ui背景
		if(layer == 'stage') return base.stage; // 舞台
		if(layer == 'event') return base.event; // イベント
		if(layer == 'history')return base == fore ?historyLayer:backHistoryLayer;
        if(layer[0] == 'm')
		{
			if(layer == 'message') return base.messages[currentNum];
			return base.messages[+layer.substr(7)];
		}
		if(layer.indexOf("ui") == 0)		// ui层
		{
			return base.uiLayers[+layer.substr(2)];
		}
		return base.layers[+layer];
	}

	function getMessageLayerObjectFromElm(elm)
	{
		// elm の layer 属性の示すメッセージレイヤを返す
		var page = elm.page;
		var layer = elm.layer;
		if(page === void && layer === void) return current;
		var base;
		if(page == 'back') base = back; else base = fore;
		if(layer === void || layer == 'message') return base.messages[currentNum];
		return base.messages[+layer.substr(7)];
	}


	//----------------------------------------------------- レイヤコピー関連 --

	function backupLayer(elm, toback)
	{
		// レイヤの表←→裏間のコピーを行う
		// toback = true の場合は表→裏、false の場合は裏→表
		if(elm.layer !== void)
		{
			// レイヤ指定がある
			getLayerPageFromElm(elm, toback).assignComp(); // 対のレイヤの内容をコピー
		}
		else
		{
			// レイヤ指定が無いので全部のレイヤをコピー
			var base = toback ? back:fore;
			base.base.assignComp();
			base.ui.assignComp();
            base.stage.assignComp();
            base.event.assignComp();
			(toback ? backHistoryLayer:historyLayer).assignComp();
            var layers = base.layers, messages = base.messages,uiLayers = base.uiLayers;
			for(var i = layers.count-1; i >= 0; i--) layers[i].assignComp();
			for(var i = uiLayers.count-1; i >= 0; i--) uiLayers[i].assignComp();
			for(var i = messages.count-1; i >= 0; i--) messages[i].assignComp();

			forEachEventHook('onCopyLayer',
				function(handler, f) { handler(f.toback); } incontextof this,
				%[toback:toback]);
		}
	}
	/**
	 * レイヤの全消去
	 */
	function clearLayers(base) {
		updateBeforeCh = 1;
		base.base.freeImage();
		base.event.freeImage();
		base.stage.freeImage();
        for(var i = base.messages.count-1; i >= 0; i--) {
            base.messages[i].clear(true);
            base.messages[i].visible = false;
        }
		for(var i = base.layers.count-1; i >= 0; i--) {
            // base.layers[i].clear(true);
            base.layers[i].visible = false;
        }
        // 選択肢窓消去
		hideUiLayer(base);
		hideSelect();
		hideMapSelect();
		callHook("onClear", base);
	}

	function copyLayer(elm)
	{
		// elm に従って同種のレイヤ間のコピーを行う
		var src = getLayerFromElm(elm, 'src');
		var dest = getLayerFromElm(elm, 'dest');
		dest.assign(src);
	}
	// ----------------------------------------
	// ループボイス処理用
	// ----------------------------------------

	var loopVoiceInfo;
	var loopVoiceTrigger;
	var loopVoiceSuspend; // ループボイス一時停止
	
	function initLoopVoice() {
		loopVoiceInfo = new LoopVoiceInfo();
		loopVoiceTrigger = new AsyncTrigger(updateLoopVoice, '');
		loopVoiceTrigger.cached = true;
		add(loopVoiceTrigger);
	}
	
	/**
	 * ループボイス再開指定
	 * @param name 角色名
	 */
	function updateLoopVoice() {
		if (loopVoiceSuspend)return;
		foreach(loopVoiceInfo.list, function(id, info) {
			var voiceBuffer = getPlayingVoiceTrack(info.name, true);
			if (voiceBuffer === void || !voiceBuffer.canWait()) {
				playVoice(info.name, getPlayVoiceFilename(info.name, info.voice), info.pan, info.type, true, false, info.noflip, info.fade);
			}
		} incontextof this);
	}

	/**
	 * ループボイスを一時無効化
	 */
	function suspendLoopVoice() {
		stopAllVoice(void, -1); // ループ情報を残しつつ全停止
		loopVoiceSuspend = true;
	}

	/**
	 * ループボイスを有効化
	 */
	function restartLoopVoice() {
		loopVoiceSuspend = false;
		loopVoiceTrigger.trigger();
	}
	// ------------------------------------------------
	// テキストスピーチ処理用		speech 插件的部分目前还没精力和需求去整合，就先放在这
	// ------------------------------------------------

	// 基本的にプラグインに処理を丸投げ
	function checkTextSpeech(name, text) {
		return callHook("onEntryTextSpeech", name, text, false);
	}
	function entryTextSpeech(name, text, play) {
		var state = callHook("onEntryTextSpeech", name, text, play);
		if (state && !hasCurrentVoice) {
			// 読み上げ処理があるとしてcurrentVoiceに細工を入れる
			currentVoice = [] if (currentVoice === void);
			currentVoice.add(%[ speech:text, name:name, voice:"*speech*" ]);
		}
	}
	function extractTextSpeech(type) {
		// テキストが先行で取得できなかった場合の遅延スピーチ用
		var cv = currentVoice ? currentVoice[0] : void;
		if (cv && cv.voice == "*speech*") {
			var speech = callHook("onExtractTextSpeech", type);
			if (speech != "" && cv.speech === void) cv.speech = speech;
		}
	}
	function stopTextSpeech {
		callHook("onStopTextSpeech");
	}

	
	//动画相关联--------------------------------------------------- アニメーション関連 --

	/** 
	* @description: 在actionBase 的onActionComplete 处调用此方法
	* @param layer 进行动画的对象
	* @param name	动画名称
	* @return  无
	*/
	function onAnimationStopped(obj,name)	//TODO fatal:layer的name有可能重复
	{
		// アニメーションが停止した
		if(isBlank(conductor))return;
		conductor.trigger('anim:'+ name);
	}

	function waitAnimation(elm)
	{
		// アニメーションの停止をまつ
		var layer = getLayerFromElm(elm);
		var name = +elm.name;
		if(!layer.canWaitAnimStop(name)) return 0; // アニメーションの停止を待つ
		conductor.wait(%[
			'anim:' + layer.name + ':' + name => function
			{
			} incontextof this
			]);
		return -2;
	}

	//渐变相关联--------------------------------------------------- トランジション関連 --

	function onLayerTransitionCompleted(layer, dest, src)
	{
		// レイヤでトランジションが終了したときに呼ばれる
		conductor.trigger('trans'); // 'trans' を送る
    }
	//等待转换结束
	function waitTransition(elm)
	{
        // トランジションを待つ
		if(transCount == 0) return 0; // トランジションを待てない
		if((elm.canskip === void || +elm.canskip) && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ動作中
				stopAllTransitions();
				return 0; // トランジションを停止させてすぐに返る
			}
			conductor.wait(%[
				click : function
				{
					updateBeforeCh = 1;
					stopAllTransitions(); // すべてのトランジションは停止
				} incontextof this,
				trans : function
				{
					updateBeforeCh = 1;
				} incontextof this
				]);
		}
		else
		{
			conductor.wait(%[
				trans : function
				{
					updateBeforeCh = 1;
				} incontextof this
				]);
		}
		return -2;
	}
	//停止所有转换
	function stopAllTransitions()
	{
        // すべてのトランジションを停止させる
		var layers, messages,uiLayers;
		fore.base.stopTransition();
		fore.ui.stopTransition();
        fore.stage.stopTransition();
        fore.event.stopTransition();
        layers = fore.layers, messages = fore.messages,uiLayers = fore.uiLayers;
		for(var i = layers.count-1; i >= 0; i--) layers[i].stopTransition();
		for(var i = messages.count-1; i >= 0; i--) messages[i].stopTransition();
		for(var i = uiLayers.count-1; i >= 0; i--) uiLayers[i].stopTransition();
        back.base.stopTransition();
        back.ui.stopTransition();
        back.stage.stopTransition();
        back.event.stopTransition();
        layers = back.layers, messages = back.messages,uiLayers = back.uiLayers;
		for(var i = layers.count-1; i >= 0; i--) layers[i].stopTransition();
		for(var i = messages.count-1; i >= 0; i--) messages[i].stopTransition();
		for(var i = uiLayers.count-1; i >= 0; i--) uiLayers[i].stopTransition();
		transCount = 0; // 一応
	}

	function callExchangeInfo()
	{
		// すべての背景レイヤをのぞく表レイヤに対して
		// exchangeInfo を呼ぶ
        fore.stage.exchangeInfo();
        fore.event.exchangeInfo();
        var layers = fore.layers;
		for(var i = layers.count-1; i >= 0; i--) layers[i].exchangeInfo();
    }
	function callExchangeUiInfo(){
		var messages = fore.messages,uis = fore.uiLayers;
		for(var i = messages.count-1; i >= 0; i--)
			messages[i].exchangeInfo();
		for(var i = uis.count-1; i >= 0; i--)
			uis[i].exchangeInfo();
		historyLayer.exchangeInfo();
	}
	//所有层复制为里层
	function callAssignTransSrc()
	{
		// すべての背景レイヤをのぞく表レイヤに対して
		// assignTransSrc を呼ぶ
        fore.event.assignTransSrc();
        fore.stage.assignTransSrc();
        var layers = fore.layers;
		for(var i = layers.count-1; i >= 0; i--) layers[i].assignTransSrc();
        forEachEventHook('onCopyLayer',
				function(handler, f) { handler(f.toback); } incontextof this,
				%[toback:false]);
    }
	/** 
	* @description: 渐变结束后调用，将所有显示到前面的表层用里层信息设置
	* @return 
	*/	
	function callAssignUiTransSrc()
	{
        var layers = fore.uiLayers, messages = fore.messages;
		for(var i = messages.count-1; i >= 0; i--) messages[i].assignTransSrc();
		for(var i = layers.count-1; i >= 0; i--) layers[i].assignTransSrc();
		historyLayer.assignTransSrc();
        forEachEventHook('onCopyLayer',
				function(handler, f) { handler(f.toback); } incontextof this,
				%[toback:false]);
    }
	//交换表层与里层
	function exchangeForeBack()
	{
		swapBaseLayer();
		swapCharacterLayer();
		swapStageLayer();
		forEachEventHook('onExchangeForeBack',
				function(handler, f) { handler(); } incontextof this);

		// 強制显示変更
		fore.base.visible = true;
		back.base.visible = false;

        // 選択肢復帰
        if (selectShowing) {
            showSelect();
        }
        if (mapSelectShowing) {
            showMapSelect();
        }
    }
	//交换表层与里层
	function exchangeUiForeBack()
	{
		swapBaseUiLayer();
		swapMessageLayer();
		swapUiLayer();
		swapHistoryLayer();
		forEachEventHook('onExchangeForeBack',
				function(handler, f) { handler(); } incontextof this);
		fore.ui.visible = true;
		// back.ui.visible = false;
    }

	function swapBaseLayer()
	{
        // 背景レイヤのみを取り替える
        var tmp = fore.base;
		fore.base = back.base;
		back.base = tmp;
    }
	function swapBaseUiLayer()
	{
        // 背景レイヤのみを取り替える
        var tmp = fore.ui;
		fore.ui = back.ui;
		back.ui = tmp;
        current = (currentPage?back:fore).messages[currentNum]; // current は設定し直し
    }

	function swapStageLayer(id)
	{
		if(isBlank(id)){
			swapStageLayer("event");
			swapStageLayer("stage");
			return;
		}
        // 前景レイヤの表と裏を取り替える
        var fl = fore[id], bl = back[id];
        var tmp = fl;
        fl = bl;
        bl = tmp;
	}
    
	function swapCharacterLayer(id)
	{
		// 前景レイヤの表と裏を取り替える
		var fl = fore.layers, bl = back.layers;
		if(isBlank(id)){
			var tmp = bl;
			back.layers = fore.layers;
			fore.layers = tmp;
		}else{
			var tmp = fl[id];
			fl[id] = bl[id];
			bl[id] = tmp;
		}
	}

	function swapUiLayer(id)
	{
		var fl = fore.uiLayers, bl = back.uiLayers;
		if(isBlank(id)){
			var tmp = bl;
			back.uiLayers = fore.uiLayers;
			fore.uiLayers = tmp;
		}else{
			var tmp = fl[id];
			fl[id] = bl[id];
			bl[id] = tmp;
		}
    }

	function swapMessageLayer(id)
	{
		// メッセージレイヤの表と裏を取り替える
		var fl = fore.messages, bl = back.messages;
		if(isBlank(id)){
			var tmp = bl;
			back.messages = fore.messages;
			fore.messages = tmp;
		}else{
			var tmp = fl[id];
			fl[id] = bl[id];
			bl[id] = tmp;
		}
		current = (currentPage?back:fore).messages[currentNum]; // current は設定し直し
	}
	function swapHistoryLayer(){
		var tmp = historyLayer;
		historyLayer = backHistoryLayer;
		backHistoryLayer = tmp;
	}


    
	//------------------------------------------------ ディレイ/スキップ関連 --
	//设置文字显示速度
	function setDelay(elm)
	{
		// delay タグの処理
		var speed = elm.speed;
		if(speed == 'nowait')
		{
			chSpeed = 0;
			chUserMode = false;
		}
		else if(speed == 'user')
		{
			chUserMode = true;
			setUserSpeed();
		}
		else
		{
			chSpeed = +speed;
			chUserMode = false;
		}
		if(!skipMode) actualChSpeed = chSpeed;
	}
	
	//设置为用户选择的文字表示速度，会根据已读还是未读进行改变速度
	function setUserSpeed()
	{
		// ユーザの選択した文字表示スピードを設定
		// この関数を読んだ時点ですでに userChSpeed には
		// あたらしい値が設定されているとみなす。
		// あるいは、ラベルごとに、その区域が既読か未読かで
		// 表示スピードを変える目的で呼ばれる
		/*设定用户选择的文字显示速度，在执行了该函数的时刻，认为已经对userChSpeed设定了新的值。	
		或者，对于每个标签，为了根据该区域是已读还是未读来改变显示速度而被调用*/
		if(chUserMode)
		{
			if(getCurrentRead())
				chSpeed = userCh2ndSpeed==-1?userChSpeed:userCh2ndSpeed; // 既読
			else
				chSpeed = userChSpeed; // 未読
		}
		if(!skipMode) actualChSpeed = chSpeed;
	}
	function canFastSkip() {
		return !noForceSkipUnread || allskip || getCurrentRead();
	}

	function skipToClick()
	{
		// クリック待ち記号までスキップ
		skipMode = 1;
		actualChSpeed = 0;
	}

	function skipToPage()
	{
		// 改ページ待ち記号までスキップ
		skipMode = 2;
		actualChSpeed = 0;
		if(currentWithBack) current.comp.complete();
		current.complete();	
	}

	function skipToStop()
	{
        // すべてスキップまたは既読の場合のみ
        if (allskip || getCurrentRead()) {
            // 次の停止までスキップ
            onPrimaryClick(); // クリックの動作をエミュレートする
            skipMode = 3;
            actualChSpeed = 0;
        }
		onModeChange();
	}
	//不带任何画面效果的高速快进  todo  还要检查选择支的部分
	function skipImmediate()
	{
		if (allskip || getCurrentRead()) {
            // 次の停止までスキップ
            onPrimaryClick(); // クリックの動作をエミュレートする
            skipMode = 6;
            actualChSpeed = 0;
        }
	}

	function skipToStop2()
	{
		// 次の停止までスキップ(早送りモード)	在下个指令前快进
		onPrimaryClick();
		skipMode = 4;
		actualChSpeed = 0;
		onModeChange();
	}

	function cancelSkip()	//取消快进
	{
		// スキップ動作をキャンセル
        skipMode = 0;
		skipKeyRepressed = false;
		actualChSpeed = chSpeed;
		onModeChange();
	}

	function enterNoWait()
	{
		// nowait タグの処理
		beforeNoWaitActualChSpeed = actualChSpeed;
		beforeNoWaitChUserMode = chUserMode;
		actualChSpeed = 0;
	}

	function leaveNoWait()
	{
		// endnowait タグの処理
		actualChSpeed = beforeNoWaitActualChSpeed;
		chUserMode = beforeNoWaitChUserMode;
	}

	function cancelAutoMode()//todo 解除自动显示换页
	{
		// 自動読みすすみモードのキャンセル
		if(autoMode)
		{
			autoMode = false;
			if(typeof this.autoModeMenuItem !== "undefined")	//todo 菜单
				autoModeMenuItem.checked = false;

            // 待ちを強制解除する
            // XXX なぜたしたのか？問題あるのではずし。要AUTOMODE 再確認
            //          conductor.run(false);
            var t = conductor.lastTagName;
            if(t == 'p'){
				showPageBreak();
			}
			onModeChange();
		}
	}
	//开启自动模式
	function enterAutoMode()
	{
		// 自動読みすすみモードに入る
		if(typeof this.autoModeMenuItem !== "undefined") //todo 菜单
			autoModeMenuItem.checked = true;
		// onPrimaryClick();
		if (clickWaiting) {
			conductor.trigger('click');
		}
		autoMode = true;
		onModeChange();
	}

	//--------------------------------------------------------- ウェイト関連 --

	function resetWait()
	{
		// 時間原点のリセット
		timeOrigin = System.getTickCount();
	}

	function waitTime(waittime, canskip, trans=false)
	{
        // waittime 分待つ
		if(waittime == 0) return 0;
		if(canskip)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ中の場合
				return 0; // スキップ中の場合はなにもせずに返る
			}

            if (trans) {
            conductor.waitWithTimeOut(%[
				click : function
				{
					updateBeforeCh = 1;
					stopAllTransitions(); // すべてのトランジションは停止
				} incontextof this,
				timeout : function
				{
					updateBeforeCh = 1;
					stopAllTransitions(); // すべてのトランジションは停止
				} incontextof this
				], waittime);

            } else {
            conductor.waitWithTimeOut(%[
				click : function
				{
					// やることなし
				} incontextof this,

				timeout : function
				{
					// やることなし
				} incontextof this
				], waittime);
            }
		}
		else
		{
			// スキップできない場合
            if (trans) {
			conductor.waitWithTimeOut(%[
				timeout : function
				{
					updateBeforeCh = 1;
					stopAllTransitions(); // すべてのトランジションは停止
				} incontextof this
				], waittime);
            } else {
			conductor.waitWithTimeOut(%[
				timeout : function
				{
					// やることなし
				} incontextof this
				], waittime);
            }
		}
		return -2; // break
		
	}
	//等待一定时间
	function doWait(elm)
	{
		// wait タグの処理
		var waittime;
		if(elm.mode == 'until')
		{
			// until モード
			waittime = timeOrigin + +elm.time - System.getTickCount();
			if(waittime < 0) { lastWaitTime = 0; return 0; } // すでに時間が経過している
			lastWaitTime = waittime;
			if(waittime < 6) return 0; // あまりに待ち時間が短いので待たない
		}
		else
		{
			waittime = +elm.time;
        }
		return waitTime(waittime, (elm.canskip === void || +elm.canskip) && clickSkipEnabled, elm.trans !== void ? elm.trans : false);
	}
	//等待文字显示的时间
	function doWaitCh(elm)
	{
		// +elm.time のカウント分、待つ
		var t = elm.time;
		return waitTime(actualChSpeed * (t === void ? 1 : +t),
			(elm.canskip === void || +elm.canskip) && clickSkipEnabled);
	}

	//------------------------------------------------------------ quake関連 --

	function doQuake(elm)
	{
		// elm に従って quake を開始
		if(elm.time !== void)
		{
			if(defaultQuakeTimeInChUnit)
			{
				if(elm.timemode == 'ms')
					quakeEndTick = System.getTickCount() + +elm.time;
				else
					quakeEndTick = System.getTickCount() + +elm.time * chSpeed;
			}
			else
			{
				if(elm.timemode == 'delay')
					quakeEndTick = System.getTickCount() + +elm.time * chSpeed;
				else
					quakeEndTick = System.getTickCount() + +elm.time;
			}
		}
		else
		{
			quakeEndTick = -1;
		}

		if(elm.hmax !== void) quakeHorzMax = +elm.hmax; else quakeHorzMax = 10;
		if(elm.vmax !== void) quakeVertMax = +elm.vmax; else quakeVertMax = 10;

		quakeTimer.enabled = true;
		quaking = true;
	}

	function restoreQuake()
	{
		// restore から呼ばれ、栞を保存したときに揺れていた場合は揺らす
		if(quaking && quakeEndTick == -1)
			quakeTimer.enabled =true;
	}
    
    /**
     * 调整层的显示位置	消息层不会因此层的位置而改变，但是注意移动幅度过大时，消息层会超过主层，这时超过的部分会不显示
     */
	function setBaseLayerPos(x, y) { 
		(global.Layer.setPos incontextof fore.base)(x,y);
		(global.Layer.setPos incontextof back.base)(x,y);
		for(var i = 0; i< fore.messages.count; i++) fore.messages[i].setDiff(-x, -y);
        for(var i = 0; i< back.messages.count; i++) back.messages[i].setDiff(-x, -y);
		forEachEventHook('setBaseLayerPos',
						 function(handler, info) { handler(info.x, info.y); } incontextof this, %[x:x, y:y]);
	}

	function stopQuake()
	{
		// 揺れを停止
		setBaseLayerPos(0, 0);
		quakeTimer.enabled = false;
		quaking = false;
		conductor.trigger('quake');
	}

	function onQuakeTimerInterval()
	{
		// quakeTimer により呼ばれる
		if(quakeEndTick != -1 && System.getTickCount() > quakeEndTick) { stopQuake(); return; }
        if(historyShowing || selectShowing || mapSelectShowing || currentDialog !== void)
		{
			// メッセージ履歴レイヤ表示中はさすがに揺れていられない			履历层不会随之震动
			setBaseLayerPos(0, 0);
			return;
		}
		var x, y;
		if(quakeHorzMax == quakeVertMax)
		{
			// だいたい同じ
			x = int(Math.random() * quakeHorzMax - quakeHorzMax);
			y = int(Math.random() * quakeVertMax - quakeVertMax);
		}
		else if(quakeHorzMax < quakeVertMax)
		{
			// 縦揺れ
			x = int(Math.random() * quakeHorzMax - quakeHorzMax);
			y = int((quakePhase ? Math.random() : -Math.random()) * quakeVertMax);
		}
		else
		{
			// 横揺れ
			x = int((quakePhase ? Math.random() : -Math.random()) * quakeHorzMax);
			y = int(Math.random() * quakeVertMax - quakeVertMax);
		}
		quakePhase = !quakePhase;
		setBaseLayerPos(x, y);
	}

	function waitQuake(elm)
	{
		// 揺れが終了するまでまつ
		if(!quaking || quakeEndTick == -1) return 0; // 揺れていなければ待たない
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ中の場合
				stopQuake();
				return 0; // スキップ中の場合は揺れを停止させて返る
			}
			conductor.wait(%[
				click : function
				{
					stopQuake(); // 揺れは停止する
				} incontextof this,

				quake : function
				{
					// やることなし
				} incontextof this
				]);
		}
		else
		{
			// スキップできない場合
			conductor.wait(%[
				quake : function
				{
					// やることなし
				} incontextof this
				]);
		}
		return -2;
	}

	//------------------------------------------------------------- クリック --
	function onExSystemMenuSelected(sel) {
		callHook("onExSystemMenuSelected",sel);
	}
	function onNcMouseMove(x, y, ht){
		callHook("onNcMouseMove",x, y, ht);
	}
	function onNcMouseDown(x, y, btn, ht) {	//	右键点击菜单栏 准备弹出显示隐藏菜单
		callHook("onNcMouseDown",x, y, btn,ht);
	}
	function onNcMouseUp(x, y, btn, ht) {//	右键点击菜单栏 弹出显示隐藏菜单
		callHook("onNcMouseUp",x, y, btn,ht);
	}
	function onMouseMove(x, y, shift){
		// dm("mousemove");
		callHook("onMouseMove",x, y, shift);
	}
	function onMouseLeave(){
		callHook("onMouseLeave");
	}

	function onPrimaryClick()
	{	
        // プライマリレイヤで「クリックの動作」がなにもフィルタリングされなかった
		// とき、プライマリレイヤから呼ばれる。
		clickCount ++;
		if(!callHook(leftClickHook))
		{
			if(messageLayerHiding)
			{
				showMessageLayerByUser(); // メッセージレイヤを表示する
			}
            else // 显示了就别做其他操作了
            {
				var st = conductor.status;
				var runst = conductor.mRun;
				var stopst = conductor.mStop;
				var waitst = conductor.mWait;

                if(st != stopst && canCancelSkipByClick && skipMode && skipMode != 4 && skipMode != 5)
				{
					// クリックによるスキップの解除が可能
					cancelSkip();
                    return;
				}
                
//				else
				{
					// この時点でフィルタリングされないメッセージは待ち状態のクリアなので
					// conductor に 'click' を送り解除を伝える。
					if(!conductor.trigger('click')) // 待ち状態でない場合は単に無視される
					{
                        // ハンドラが見つからないなど、処理されなかった場合
                        if (prevSkipMode !== void) {
                            skipMode = 5;
                        } else {
                            if(st == waitst && clickSkipEnabled && skipMode == 0)
  						    {
                                // クリックによるスキップが可能
                                // skipToClick(); // 新方式导致废弃
								skipToPage();	
                            }
                        }
                    } else {
                        if (prevSkipMode !== void) {
                            skipMode = 5;
                        }
                    }
				}

                // 順序をいれかえた。自動モード解除はクリックによるキャンセル処理の後にする
                if(st != stopst && autoMode)
				{
                    // 自動読みすすみの場合
                    cancelAutoMode();
				}

            }
		}
	}

	function onPrimaryClickByKey()
	{
		// キーが押されたときプライマリレイヤをクリックしたのと
		// 同じ動作をするが、さらに一時的にマウスカーソルを隠す
		onPrimaryClick();
		hideMouseCursor();
	}

	function waitClick(elm)
	{
		// クリックを待つ
		conductor.wait(%[
			click : function
			{
			} incontextof this]);
		return -2;
	}

	function onMouseDown(x, y, button)
	{
		lastMouseDownX = x;
		lastMouseDownY = y;
		// 全屏时画面外的点击判定 
		if (fullScreened)
		{
			// 确定xy 坐标是否是否为主图层
			var pl = primaryLayer;		// 起始这里用主图层而不是背景层也可以
			var px = pl.cursorX;
			var py = pl.cursorY;

			if (px < 0 || py < 0 || px >= pl.width || py >= pl.height)
			{
				if (button == mbLeft)
				{
					onPrimaryClick();
				}
				else if (button == mbRight)
				{
					onPrimaryRightClick();
				}
			}
		}
		super.onMouseDown(...);
	}
	function onMouseUp(x, y, button, shift)
	{
		if(callHook("onMouseUp",x, y, button, shift))return;
		super.onMouseUp(...);
	}

	function releaseCapture() {
		primaryLayer.releaseCapture();
	}
	// ネイティブフルスクリーンでプライマリレイヤ外をクリックされた時の処理（要WinodwEX）	在native全屏时单击主层外时的处理（需要WinodwEX）
	var _windowsClickEventMessageMap = %[];	//	触发的是	onWindowsMessageHook事件
	function setWindowsClickEventHook() {
		if (typeof this.setMessageHook != "Object" ||
			typeof global.Window.getNotificationNum != "Object") return;
		var setMH = setMessageHook;
		var getMN = global.Window.getNotificationNum;
		var map   = _windowsClickEventMessageMap;
		var ev    = [
			"CANCELMODE",	//取消模态的消息
			 ];	
		for (var i = 0; i < ev.count; i++) {
			var name = ev[i];
			if (name == "") continue;
			setMH(true, name);
			map[name] = getMN(name);
		}
	}
	function onWindowsMessageHook(msg, wp, lp) {
		if (msg > 0) with (_windowsClickEventMessageMap) switch (msg) {
		case .CANCELMODE:
			releaseCapture(); // [XXX]kirikiri2と違ってmouseUpがこない問題回避の暫定対応
			break;
		}
		return callHook("onWindowsMessageHook", msg, wp, lp);
	}


	//------------------------------------------------------- キーボード操作 --

	function processKeys(key, shift)
	{
        // CONTROL によるスキップ処理
        if(key == VK_CONTROL) {
            var sg = getKeyState;
            if(sg(VK_CONTROL)){
                if(clickSkipEnabled && !conductor.interrupted && canFastSkip()
					&& skipMode < SKIP_STOP ){
                    if(skipMode != 4)
                        skipToStop2(); // まだskipMode 4に入っていない場合は早送りモードに入る
                }
            }
        }

        if(checkProceedingKey(key, shift)) return;

		if(key == #'F')
		{
			// 次の選択肢/未読まで進む
			skipToNextStopByKey();
			return;
		}

		if(key == #'B')
		{
			// 前に戻る
			goBackByKey();
			return;
		}

		if(key == #'A')
		{
			// 自動的に読み進める
			switchAutoModeByKey();
			return;
		}
 
		if(freeSaveDataMode)
		{
			if(key == #'S')
			{
				// 栞をはさむ
				if(typeof this.storeMenu != "undefined" && storeMenu.enabled)	//TODO 菜单逻辑迁移
					storeMenu.click();
				return;
			}

			if(key == #'L')
			{
				// 栞をたどる
				if(typeof this.restoreMenu != "undefined" && restoreMenu.enabled)
					restoreMenu.click();
				return;
			}
		}

		if(key == #'R' || (key == VK_UP && (shift & ssShift)))
		{
			// メッセージ履歴を表示
			showHistoryByKey();
			return;
		}

		if(key == VK_ESCAPE)
		{
			// メッセージを消す
			if(typeof this.rightClickMenuItem != "undefined" &&
				rightClickMenuItem.enabled)
			{
				rightClickMenuItem.click(); // クリックをエミュレート
				return;
			}
		}
	}

	function preProcessKeys(key, shift)
	{
		return callHook(keyDownHook, key, shift);
	}

	function internalOnKeyDown(key, shift)
	{
		if(!preProcessKeys(key, shift)) processKeys(key, shift);
	}

	function checkProceedingKey(key, shift)// 检测文本前进键
	{
        // key が読みすすみのキー ( スペースキーかReturnキー ) の場合は
		// キーを処理し、true を返す。そうでなければ false を返す
		if(key == VK_RETURN || key == VK_SPACE)
		{
			// キーがメッセージキューに溜まってる場合があるので
			// 実際にそのキーが押されているのかどうかを
			// getKeyState を用いて調べる
			var sg = getKeyState;
			if(sg(VK_RETURN) || sg(VK_SPACE))
			{
				// キーが押されてた
				if((shift & ssRepeat) && clickSkipEnabled)
				{
					// キーリピート
					if(skipMode < SKIP_STOP && canFastSkip() && skipMode != 4 && skipKeyRepressed)
						skipToStop2(); // まだskipMode 4に入っていない場合は早送りモードに入る
					// skipKeyRepressed をチェックするのは
					// 連続してキーリピートが発生しているときに
					// cancelSkip 後にスキップに突入するのを防ぐため
				}
				else
				{
					skipKeyRepressed = true;
					onPrimaryClickByKey();
				}
				return true;
			}
		}

		return false;
	}

	function skipCancelKeyPressing()
	{
		// スキップを解除する要因となるキーあるいはマウスボタンが押されているか
		var sg = getKeyState;
		return sg(VK_RETURN) || sg(VK_SPACE) || sg(VK_LBUTTON);
	}
	//是否按下了快进键
	function skipKeyPressing()
	{
		// VK_RETURN あるいは VK_SPACE が押されているかどうか
		var sg = getKeyState;
		return sg(VK_RETURN) || sg(VK_SPACE) || sg(VK_CONTROL);
	}
	//----menuItem TODO  这些全都要改--------------
	function goBackByKey()
	{
		if(typeof this.goBackMenuItem != "undefined" &&
			goBackMenuItem.enabled)
			goBackMenuItem.click(); // クリックをエミュレート
	}

	function skipToNextStopByKey()
	{
		if(typeof this.skipToNextStopMenuItem != "undefined" &&
			skipToNextStopMenuItem.enabled)
			skipToNextStopMenuItem.click(); // クリックをエミュレート
	}

	function showHistoryByKey()//TODO 绕开履历检测  消去引用
	{
		onShowHistoryMenuItemClick();
		/*if(typeof this.showHistoryMenuItem != "undefined" &&
			showHistoryMenuItem.enabled)
			showHistoryMenuItem.click(); */
	}

	function switchAutoModeByKey()
	{
		if(typeof this.autoModeMenuItem != "undefined" &&
			autoModeMenuItem.enabled)
			autoModeMenuItem.click(); // クリックをエミュレート
	}

	function onKeyDown(key, shift)
	{
        if(focusedLayer === null)
			internalOnKeyDown(key, shift);
		super.onKeyDown(...);
	}
	
	function onMouseWheel(shift, delta, x, y)
	{
		// ホイールが回転した
		super.onMouseWheel(...);
        if (currentDialog !== void || !inStable) {
            return;
        }
		if(callHook("onMouseWheel",shift, delta, x, y))
			return;
        if(!historyLayer.visible)
		{
			if(delta > 0){
				SystemAction.backlog();	// 仅作尝试，实际是否会打开会做判断
			}
				// showHistoryByKey(); // メッセージ履歴を表示  todo 这个以后去掉
			else if(SystemHook.currentState=="game") 
				onPrimaryClick(); // クリックをエミュレート
		}
		else
		{
			// todo 以后这里或许可以改成 履历层获得焦点，然后处理鼠标的滚轮(或者hook的方式？)
			// メッセージ履歴にイベントを垂れ流す
			historyLayer.windowMouseWheel(shift, delta, x, y);
		}
	}

	//------------------------------------------------- クリック待ち記号処理 --

	function hideClickGlyphs()
	{
		// クリック待ち記号を非表示に
		current.hidePageBreakGlyph();
	}

	/*
	显示换页标记  
	 如果为特定快进模式则取消快进，未能取消快进的情况下直接继续快进  
	 为自动模式 则等待自动模式的等待时间
	 显示换页符号 并存储符号状态
	 等待用户点击换页
	*/
	function showPageBreak(elm)
	{	
		// 現在のメッセージレイヤにページ待ち記号を表示する
		stablePosibility = true;
		if(skipMode == 1 || skipMode == 2) cancelSkip();
		if(skipMode == 4 && !skipKeyPressing()) cancelSkip();
		if(skipMode == 6)return 0; // 直接跳过不处理图像
		if(skipMode) return -4; // いったんイベントを処理
		if(autoMode)
		{
            var wait = calcAutoModePageWait();
            if (wait <= 0) {
                wait = 1;
            }
            return wait;
        }

		current.showPageBreakGlyph();

		if(!current.nodeVisible)
		{
			dm("warnning : showing text at unvisible messsage layer:" +
				(currentPage ? "back" : "fore") + currentNum +
				"waitting repage click.");
		}

		// conductor を 'click' まで待ち状態に	extra 控制器不要去做这些东西
		mainConductor.wait(%[
			click : function
			{
				clickWaiting = false;
				fore.base.cursor = cursorDefault;
				notifyRun();
			} incontextof this
			]);
		clickWaiting = true;
		fore.base.cursor = cursorWaitingClick;
		notifyStable();
		return -2;
	}

	//------------------------------------------------------------- BGM 処理 --

	function onBGMFadeCompleted()
	{
		// BGM のフェードが完了した
		conductor.trigger('bgmfade');
	}

    // BGM停止処理
    var bgmStopExp;
    var bgmStopStorage;
    var bgmStopTarget;

    function handleBgmStop() {
        // BGM停止ハンドラ

        // パラメータを保持して破棄
        var exp     = bgmStopExp;
        var storage = bgmStopStorage;
        var target  = bgmStopTarget;
        clearBgmStop();
        
        // 処理実行
        if (exp !== void) {
            Scripts.eval(exp);
        }
        if (storage !== void || target !== void) {
            window.process(storage, target);
        }
    }
    
    function setBgmStop(elm) {
        // BGM停止時処理の登録
        bgmStopExp     = elm.exp;
        bgmStopStorage = elm.storage;
        bgmStopTarget  = elm.target;
    }
    
    function clearBgmStop() {
        // BGM停止時処理の解除
        bgmStopExp     = void;
        bgmStopStorage = void;
        bgmStopTarget  = void;
    }
    
    // BGM 停止時拡張ハンドラ
    var bgmStopHandler;
    
	function onBGMStop()
	{
        // BGM が停止した
        conductor.trigger('bgmstop');
        if (bgmStopHandler !== void) {
            bgmStopHandler();
        }
        if (bgmStopExp !== void || bgmStopStorage !== void || bgmStopTarget !== void) {
            global.stopBgmTrigger = new AsyncTrigger(handleBgmStop, '');
            global.stopBgmTrigger.cached = true;
            global.stopBgmTrigger.trigger();
        }
    }

    // ------------------------------------------
    
    var bgmLabelInfos = %[];
    var bgmLabelInfo;

    function handleBgmLabel() {
        if (bgmLabelInfo !== void) {
            if (bgmLabelInfo.exp !== void) {
                Scripts.eval(bgmLabelInfo.exp);
            }
            if (bgmLabelInfo.storage !== void || bgmLabelInfo.target !== void) {
                window.process(bgmLabelInfo.storage, bgmLabelInfo.target);
            }
        }
    }

    // BGM 停止時拡張ハンドラ
    var bgmLabelHandler;

    function onBGMLabel(label) {
        // BGM のラベル通過処理
        conductor.trigger('bgmlabel_' + label);
        if (bgmLabelHandler !== void) {
            bgmLabelHandler();
        }
        var obj = bgmLabelInfos[label];
        if (obj !== void) {
            bgmLabelInfo = obj;
            global.labelBgmTrigger = new AsyncTrigger(handleBgmLabel, '');
            global.labelBgmTrigger.cached = true;
            global.labelBgmTrigger.trigger();
        }
    }

    /**
     * BGM ラベル処理の登録
     */
    function setBgmLabel(elm) {
        if (elm.name !== void) {
            var obj = %[];
            obj.storage = elm.storage;
            obj.target  = elm.target;
            obj.exp     = elm.exp;
            bgmLabelInfos[elm.name] = obj;
        }
    }

    /**
     * BGM ラベル処理の解除
     */
    function clearBgmLabel() {
        bgmLabelInfos = %[];
        bgmLabelInfo = void;
    }

    // ----------------------------------------------------------------------
    
	function waitBGMFade(elm)
	{
		// BGM のフェード終了を待つ
		if(!bgm.inFading) return 0; // フェード中でなければ待たない
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ中の場合
				bgm.stopFade();
				return 0; // スキップ中の場合はフェードを停止させて返る
			}
			conductor.wait(%[
				click : function
				{
					bgm.stopFade(); // フェーディングは停止する
				} incontextof this,

				bgmfade : function
				{
					// やることなし
				} incontextof this
				]);
		}
		else
		{
			// スキップできない場合
			conductor.wait(%[
				bgmfade : function
				{
					// やることなし
				} incontextof this
				]);
		}
		return -2;
	}

	function waitBGMStop(elm)
	{
		// BGM の再生終了を待つ
		if(!bgm.canWaitStop) return 0; // BGM 再生終了を待てなければそのまま戻る
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ中の場合
				bgm.stop();
				return 0; // スキップ中の場合は再生を停止させて返る
			}
			conductor.wait(%[
				click : function
				{
					bgm.stop(); // 再生を終了する
				} incontextof this,

				bgmstop : function
				{
					// やることなし
				} incontextof this
				]);
		}
		else
		{
			// スキップできない場合
			conductor.wait(%[
				bgmstop : function
				{
					// やることなし
				} incontextof this
				]);
		}
		return -2;
	}

	//----------------------------------------------------------- 効果音処理 --

	function onSESoundBufferFadeCompleted(id)
	{
		// 効果音のフェードが終了した
		conductor.trigger('sefade' + id);
	}

    // SE 停止時拡張ハンドラ
    var seStopHandler;
    
    function onSESoundBufferStop(id)
	{
		// 効果音の再生が終了した
        conductor.trigger('sestop' + id);
        if (seStopHandler !== void) {
            seStopHandler(id);
        }
	}

	function waitSEFade(elm)
	{
		var id = +elm.buf;
		var buf = se[id];
		if(!buf.inFading) return 0; // フェード中でなければそのまま戻る
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ中の場合
				buf.stopFade();
				return 0; // スキップ中の場合はフェードを停止させて返る
			}
			conductor.wait(%[
				click : function (id)
				{
					se[id].stopFade(); // フェードを終了する
				} incontextof this,

				click_arg : id, // ハンドラへの引数

				'sefade'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'sefade'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		else
		{
			// スキップできない場合
			conductor.wait(%[
				'sefade'+id =>
					function (id)
					{
						// やることなし
					} incontextof this,

				'sefade'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		return -2;
	}

	function waitSEStop(elm)
	{
		var id = +elm.buf;
		var buf = se[id];
		if(!buf.canWaitStop()) return 0; // 終了を待てなければそのまま返る
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ中の場合
				buf.stop();
				return 0; // スキップ中の場合は再生を停止させて返る
			}
			conductor.wait(%[
				click : function (id)
				{
					se[id].stop(); // 再生を終了する
				} incontextof this,

				'click_arg' => id, // ハンドラへの引数

				'sestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'sestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		else
		{
			// スキップできない場合
			conductor.wait(%[
				'sestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'sestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		return -2;
	}
	//----------------------------------------------------------- 语音处理 ボイス処理 ----------------

	function onVoiceStart(id, type, loop) {
		if (type == 0) {
			resetVoicePlayingRatio();
			// 通常ボイスの場合はBGM音量下げ処理実行
			if (bgmdown) {
				delAction("bgmdown");
				addAction("bgmdown",true,[ %["bgmdownvalue", %[handler:MoveAction, value:bgmdownlevel/100.0, time:300]]]);
			}
		}
	}
	
	function onVoiceLabelStart(buf) {
	}
	
	function onVoiceLabel(label, count) {
	}
	
	function onVoiceLabelStop() {
	}

	/*
	 * 判断是否在播放语音中
	 * @param ret 指定した場合は normal:通常ボイスの再生状態 any:全ボイスの再生状態 を辞書にかえす
	 * @return 是否处于正常播放状态
	 */
	function getVoicePlayingState(ret) {
		var isPlayingNormal = false;
		var isPlayingAny = false;
		for(var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if (voice.canWait()) {
				if (voice.type == 0) {
					isPlayingNormal = true;
				}
				isPlayingAny = true;
			}
		}
		if (ret !== void) {
			ret.normal = isPlayingNormal;
			ret.any    = isPlayingAny;
		}
		return isPlayingNormal;
	}

	
	// ボイス停止通知
	function onVoiceStop(id, type, loop) {
		// 終了トリガ
		conductor.trigger("voicestop_" + id);
		// ループボイスを再開させる
		if (!loop) {
			loopVoiceTrigger.trigger();
		}

		// 全体判定
		var state = %[];
		getVoicePlayingState(state);
		// 全ボイス停止時処理
		if (!state.any) {
			conductor.trigger("voicestop");
			callHook('onVoiceStop');
		} else {
			callHook('onVoiceStop',,voices[+id].name)  if (id >= 0 && id < voices.count);
		}
		// 通常ボイス停止時処理
		if (!state.normal) {
			conductor.trigger("normalvoicestop");
			if (bgmdownvalue < 1.0) {
				// BGM下げを戻す
				delAction("bgmdown");
				addAction("bgmdown",true,[ %["bgmdownvalue", %[handler:MoveAction, value:1.0, time:300]]]);
			}
		}
	}

	function onVoiceFlip(id, level) {
		//dm(@"onVoiceFlip${voices[id].name}:${level}");
		callHook('onVoiceFlip',,voices[+id].name,level) if (id >= 0 && id < voices.count);
	}

	function getCharacterVoiceLevel(name) { // 判断嘴唇开合的等级 
		return void;
	}
	
	/**
	 * @param name 角色名
	 * @param type ボイス種別 0:通常 1:bvoice 2:lvoice 
	 * @return 是否启用了语言
	 */
	function isChVoiceOn(name, type=0) {
		if (getVoiceOn(name)) {
			switch (type) {
			case 0:
				return voiceenable;
			case 1:
				return bgvenable;
			case 2:
				return bgv2enable;
			}
		}
		return false;
	}

	/**
	 * @param name 角色名
	 * @param type 类别 0:通常 1:bvoice 2:lvoice 
	 * @return 获取实际的音量
	 */
	function getChVoiceVolume(name, type =0) {
		var per    = 100;//mainConductor.getCharacterVoicePer(name);//todo 
		var vol;
		switch (type) {
		case 0:
			vol = getVoiceVolume(name);
			break;
		case 1:
			vol = getBGVVolume(name);
			break;
		case 2:
			vol = getBGV2Volume(name);
			break;
		}
		vol = isChVoiceOn(name, type) ? vol : 0;
		return vol * per / 100 * 1000;
	}
	function _updateNextVoiceFlag(){
		var textInfo;
		try{
			textInfo = SystemLanguage.getScenarioText(,Storages.chopStorageExt(mainConductor.curStorage),currentTextNum+1);
			nextVoiceFlag = isBlank(textInfo.voice);
		}catch(e){
			nextVoiceFlag = false;	// 可能没有下条语音
		}
	}
	function checkVoiceWait() {
		// 调整在 autoMode 下语音结束后是否等待语音
		switch (autoModeWaitVoice) {
		case 0:
			// 待つ
			return true;
		case 1:
			// 如果是下一个语音时或最后一个文本，请等待
			return nextVoiceFlag;// XXX speech 插件的情况下有所不同 可能会修改 
		case 2:
			// 待たない(通常のオート待ちのみ)
			return false;
		}
	}
	
	// -----------------------------------------------------------------------
	// ボイス用ファイル処理
	// -----------------------------------------------------------------------
	
	// 標準名かどうか	todo 可以尝试去掉这个
	function isDefaultName() {
		return !(flags.name !== void && (flags.name != defaultName || flags.family != defaultFamily));
	}
	
	function checkExistVoiceFilename(storage) {
		if (!isDefaultName()) {
			// 名前指定がある場合でデフォルト名でない場合は Nつきのファイル名で参照する
			var name = getExistVoice(storage + "N");
			if (name !== void) {
				return name;
			}
		}
		return getExistVoice(storage);
	}

	function getPlayVoiceFilename(name, voice) {
		if (voice !== void) {
			var result = %[name:name,voice:voice];
			var success = callHook('onCheckExistVoiceFilename',result);
			if (!success) {
				result.voice = checkExistVoiceFilename(voice);
			}
			if (!isBlank(result.voice)) {
				return result.voice;
			} else {
				dm(@"${name}:can't load voive :${voice}");
			}
		}
	}

	
	/**
	 * 将voice定义更改为播放文件名列表
	 * @param voices 语音定义数组
	 * @param elm 补充信息
	 * @return 语音文件名信息列表
	 */
	function extractVoice(voices, elm) {
		var store = [];
		if (voices !== void) {
			var count = voices.count;
			for (var i=0;i<count;i++) with (voices[i]) {
				var name  = .name;
				var voice = .voice;		//指定文件名
				var type  = .type;		//指定角色名
				var pan   = +.pan;
				var noflip = +.noflip;
				var fade  = .fade !== void ? +.fade : 100;
				//dm(@"${name}:extractVoice:${fade}:${pan}");
				var vfile = getPlayVoiceFilename(name, voice);
				if (vfile !== void) {
					store.add(%[name:name, voice:vfile, type:type, pan:pan, noflip:noflip, fade:fade]);
					//dm(@"${name}:再生ボイス:${vfile}");
				}
				@if (GENERATE_SPEECHWAV_FOR_NO_VOICE)
				else if (elm !== void) {
					callHook("saveTextSpeech", name, getSpeechText(elm), System.exePath+@"data/voice/${voice}.wav");
				}
				@endif
			}
		}
		return store;
	}

	var defaultVoiceFadeTime = 300;
	
	/**
	 * 变更指定角色的语音音量
	 * @param name キャラ名
	 * @param fade 音量値(0～100)
	 * @param time フェード時間指定
	 */
	function fadeVoice(name, fade, fadetime) {
		if (fadetime === void) {
			fadetime = defaultVoiceFadeTime;
		}
		//dm(@"fadevoice:${name}:${fade}:${fadetime}");
		for(var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if (name == "" || voice.name == name) {
				voice.fade(fade, fadetime);
			}
		}
		loopVoiceInfo.fade(name, fade);
	}

	var voicePaused = false;
	
	/**
	 * 全ボイスをポーズする
	 */
	function pauseVoice() {
		for(var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			voice.paused = true;
		}
		voicePaused = true;
	}

	/**
	 * 全ボイスのポーズを解除する
	 */
	function resumeVoice() {
		for(var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			voice.paused = false;
		}
		voicePaused = false;
	}
	
	/**
	 * 停止指定角色的语音
	 * @param name 角色名
	 * @param fadetime 渐变时间
	 * @param force 背景循环音也停止 (-1 不会停止)
	 */
	function stopVoice(name, fadetime, force) {
		if (fadetime === void) {
			fadetime = defaultVoiceFadeTime;
		}
		for(var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if ((isBlank(name) || voice.name == name) && (force || voice.type == 0)) {
				voice.stop(fadetime);
			}
		}
		if (force && force > 0) {
			loopVoiceInfo.stop(name);
		}
		if (name == "") {
			stopTextSpeech();
			_lastVoicePlayingRatio = -1;
			resumeVoice();
		}
	}

    /**
	 * 全キャラのボイスを停止する
	 * @param fadetime フェード時間指定
	 * @param force バックボイス含めて停止
	 */
	function stopAllVoice(fadetime, force=false) {
		stopVoice("", fadetime, force);
	}

    /**
	 * 全ボイスの音量を調整
     */
	function resetAllVoiceVolume() {
		for(var i = 0; i<numVoiceBuffers; i++) {
			voices[i].resetVolume();
		}
	}

	/**
	 * 全ボイスの音量を調整
	 */
	function resetAllVoiceSpeed() {
		for(var i = 0; i<numVoiceBuffers; i++) {
			voices[i].speed = voicespeed;
		}
	}
	
	/**
	 * @param name 角色名
	 * @param all 任意mode都可以获取
	 * @return 获取角色播放中的音轨
	 */
	function getPlayingVoiceTrack(name, all=true) {
		for (var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if (voice.name == name && voice.status == "play" && (all || voice.mode)) {
				return voice;
			}
		}
	}

	/**
	 * @param name
	 * @return 返回角色对应的播放音轨
	 */
	function getVoiceTrack(name) {
		// 同名トラックを探す	先寻找同名音轨
		for (var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if (voice.name == name) {
				// [XXX] 念のため同名は消す
				for (var n = i+1; n<numVoiceBuffers; n++) {
					if (voices[n].name == name) {
						voices[n].stop();
					}
				}
				return voice;
			}
		}
		// 使ってないものを探す	找不到则使用未使用的音轨
		for (var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if (voice.name === void && voice.status == "stop") {
				return voice;
			}
		}
		// 一番古いものを探す	否则寻找最早的音轨
		var target = 0;
		var time   = voices[target].startTime;
		for (var i = 1; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if (voice.startTime < time) {
				target = i;
			}
		}
		return voices[target];
	}
	
    /*
	 * 指定したキャラで指定したボイスファイルを再生
	 * @param name キャラ名		角色名
	 * @param voicename ボイス名	语音名
	 * @param type ならすボイスの種別 0:通常 1:bgv 2:bgv2 	语音的种类
	 * @param mode trueならラベル反応させる		true则响应语音文件的标签
	 * @param noflip フリップさせない			是否响应口型事件
	 */
	function playVoice(name, voicename, pan=void, type=0, loop=false, mode=false, noflip=true, fade=void) {
		if (voicePaused) {
			resumeVoice();
		}
		//dm(@"${name}:playvoice:${voicename},${type},${mode}:${fade}");
		sflags["voice_" + _voiceNameFilter(name)] = true;
		var voice = getVoiceTrack(name);
		voice.start(name, voicename, voicepan ? pan : 0, type, loop, mode, noflip, 0,fade!==void ? +fade : 100);
	}

	/**
	 * 履歴データのボイスから直接全ボイス再生
	 * @param voices 语音定义定义信息
	 * @param mode true则不反应标签
	 */
	function playAllVoice(voices, mode=false) {
		var list = extractVoice(voices);
		var count = list.count;
		for (var i=0;i<count;i++) {
			// 似たような処理が全体にちらばってるので直すこと XXX
			var info = list[i];
			if (info !== void && isChVoiceOn(info.name)) {
				playVoice(info.name, info.voice, info.pan, info.type, false, mode, info.noflip, info.fade);
			}
		}
	}

 	 /**
     * ボイス待ち
     */
	function waitVoice(elm) {
		// startDelay();
		var voiceBuffer = getPlayingVoiceTrack(elm.name, elm.all);
		if (voiceBuffer !== void && voiceBuffer.canWait()) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			var trigger = "voicestop_" + voiceBuffer.id;
			if (canskip && clickSkipEnabled) {
				if (skipMode){
					stopVoice(elm.name);
					return 0;
				}
				conductor.wait(%[
				    click : function(arg)
					{
						stopVoice(arg);
					} incontextof this,
					click_arg : elm.name,
					trigger => function(arg)
					{
						return arg;
					} incontextof this,
					trigger + "_arg" => +elm.wait
				]);
			}
			else {
				conductor.wait(%[
					trigger => function(arg)
					{
						return arg;
					} incontextof this,
					trigger + "_arg" => +elm.wait
				]);
			}
			return -2;
		}
		return 0;
    }

    /**
     * ボイス待ち
     */
	function waitAllVoice(elm) {

		var canWait = false;
		for(var i = 0; i<numVoiceBuffers; i++) {
			var voice = voices[i];
			if (voice.canWait()) {
				canWait = true;
				break;
			}
		}
		if (canWait) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			if (canskip && clickSkipEnabled) {
				if (skipMode){
					stopAllVoice();
					return 0;
				}
				conductor.wait(%[
				    click : function(arg)
					{
						stopAllVoice();
					} incontextof this,
					voicestop : function(arg)
					{
						return arg;
					} incontextof this,
					voicestop__arg : +elm.wait
				]);
			} else {
				conductor.wait(%[
					voicestop : function(arg)
					{
						return arg;
					} incontextof this,
					voicestop_arg : +elm.wait
				]);
			}
			return -2;
		}
		return 0;
    }
	

	//--------------------------------------------------------- ムービー関連 --

		/**
	 * 全レイヤムービーの停止
	 */
	function stopAllLayerMovies() {
		stopAllGenericFlipsOneClass("movie");
	}

	// TODO  这部分逻辑做一下   全屏切换时  暂时停止 视频的播放 
	var movieRestoreTimer, ignoreMovieTrigger;
	function onMovieScreenChanging(full) {
		if (movieRestoreTimer === void) {
			movieRestoreTimer = new Timer(onMovieScreenChanged, "");
			with (movieRestoreTimer) .state=[], .enabled=false, .capacity=1, .interval=100, .mode=atmNormal;
		}
		with (movieRestoreTimer) {
			if (.enabled) {
				// 再ディレイ
				.enabled = false;
				.enabled = true;
				return;
			}
			ignoreMovieTrigger = true;
			.state.clear();
			for (var i=0;i<numMovies;i++) {
				var movie = movies[i], st = %[];
				movie.internalStore(st);
				movie.stop();
				.state.add(st);
			}
			.enabled = true;
		}
	}
	function onMovieScreenChanged() {
		if (movieRestoreTimer === void) return;
		var consvis = false;
		/**/consvis <-> Debug.console.visible;
		with (movieRestoreTimer) {
			.enabled = ignoreMovieTrigger = false;
			for (var i=0;i<numMovies;i++) {
				movies[i].internalRestore(.state[i]);
			}
			.state.clear();
		}
		if (consvis) with (Debug.console) {
			.visible = true;
			if (typeof this.bringTo == "Object") bringTo("top", true);
			else if (typeof .bringAfter == "Object") .bringAfter(this);
			else bringToFront();
		}
		onMoviePrimaryPosChanged(primaryLeft, primaryTop);
	}


	function onMovieStop(id)
	{
		// ムービーの再生が終了した
		conductor.trigger('moviestop'+id);
	}

	function waitMovieStop(elm)
	{
		var id = +elm.slot;

		// ムービーの再生終了を待つ
		if(!movies[id].canWaitStop) return 0; // ムービー再生終了を待てなければそのまま戻る
		if(elm.canskip !== void && +elm.canskip && clickSkipEnabled)
		{
			// スキップできる場合
			if(skipMode)
			{
				// スキップ中の場合
				movies[id].stop();
				return 0; // スキップ中の場合は再生を停止させて返る
			}
			conductor.wait(%[
				click : function (id)
				{
					movies[id].stop(); // 再生を終了する
				} incontextof this,

				'click_arg' => id, // ハンドラへの引数

				'moviestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'moviestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		else
		{
			// スキップできない場合
			conductor.wait(%[
				'moviestop'+id =>
				function (id)
				{
					// やることなし
				} incontextof this,

				'moviestop'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		return -2;
	}

	function onMoviePeriod(id,type)
	{
		// ムービーのピリオドイベントが発生した
		if( isLeavePeriodEvent != false )
		{
			holdPeriodEventQueue.add( 'movieperiod'+id+'_'+type );
		}
		else
		{
			conductor.trigger('movieperiod'+id+'_'+type);
		}
	}

	function waitMoviePeriod(elm)
	{
		isWaitPeriodEvent = true;
		waitedPeriodEventStorageName = conductor.curStorage;
	
		var id = +elm.slot;

		stablePosibility = true;

		if( holdPeriodEventQueue.count > 0 )
		{
			var		triggered = false;
			for( var i = 0; i < holdPeriodEventQueue.count; i++ )
			{
				if( elm.for !== void )
				{
					if( elm.for == 'loop' )
					{
						if( ('movieperiod'+id+'_'+perLoop) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else if( elm.for == 'period' )
					{
						if( ('movieperiod'+id+'_'+perPeriod) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else if( elm.for == 'prepare' )
					{
						if( ('movieperiod'+id+'_'+perPrepare) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else if( elm.for == 'segLoop' )
					{
						if( ('movieperiod'+id+'_'+perSegLoop) == holdPeriodEventQueue[i] )
							triggered = true;
					}
					else
					{
						triggered == true;
					}
				}
				else
				{
					triggered == true;
				}
			}
			holdPeriodEventQueue.clear();
			if( triggered == true )
			{
				isWaitPeriodEvent = false;
				return 0;
			}
		}

		// ムービーのピリオドイベントを待つ
		if(!movies[id].canWaitStop) return 0; // ムービーが再生中でなければそのまま戻る
		if( elm.for !== void )
		{
			if( elm.for == 'loop' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else if( elm.for == 'period' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perPeriod => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else if( elm.for == 'prepare' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perPrepare => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else if( elm.for == 'segLoop' )
			{
				conductor.wait(%[
					'movieperiod'+id+'_'+perSegLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
					'movieperiod'+id+'_arg' => id // ハンドラへの引数
					]);
			}
			else
			{
				return 0; // 引数が変
			}
		}
		else
		{
			conductor.wait(%[
				'movieperiod'+id+'_'+perLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_'+perPeriod => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_'+perPrepare => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_'+perSegLoop => function (id) { notifyRun(); isWaitPeriodEvent = false;} incontextof this,
				'movieperiod'+id+'_arg' => id // ハンドラへの引数
				]);
		}
		notifyStable();
		return -2;
	}

    
	//------------------------------------------------------- タグハンドラ群 --

	function getHandlers()
	{
		return %[ // 辞書配列オブジェクト

		/*
			タグハンドラ群は、名前とそれに対応する関数のペアを列挙するもので、
			関数名 : function(elm)
			{
				// 関数の中身
			} incontextof this,
			の書式を用いる。ただし、関数名が予約語の場合は、「関数名 : 」ではなく
			「"関数名" => 」を用いる。
			incontextof this は、関数が正しく このクラスの
			オブジェクトのコンテキスト上で動くようにするために必要。
		*/
	"break", function(elm) { return -4; }, 
	"dm",function (elm){
		if(elm.message!==void)dm(elm.message);
		if(elm.eval!==void)dm(Scripts.eval(elm.eval));
		if(void === elm.time)
			return 1000;
		else return +elm.time;
	},

	//--------------------------------------- タグハンドラ群(メッセージ操作) --		消息层操作
	text: function(elm){
		hideClickGlyphs();
		var num =elm.num;	
		currentTextNum = num;
		
		if(!(allskip || getCurrentRead()) && skipMode != 4)		// 未读尝试停止
				cancelSkip(); // 未読なのでスキップを停止
		 // 文字表示
		var acs = actualChSpeed;
		if(updateBeforeCh)
		{
			if(acs) { updateBeforeCh--; return -5; } else { updateBeforeCh--; } //为延后当前指令并优先处理绘图
		}
		if(isBlank(elm.storage))
			elm.storage = Storages.chopStorageExt(mainConductor.curStorage);
		storeFlags(); //存储当前系统状态
		pushHistoryOfStore();	//保存历史记录
		elm.type = "text";  //保存文本类型记录
		if(voicecut)stopAllVoice();		// 语音中断
		// 记录已读
		markAsRead(num);
		var textInfo = SystemLanguage.getScenarioText(,elm.storage,num);
		if(!isBlank(textInfo.voice)){
			tagHandlers.playvoice(%[name:"",voice:textInfo.voice,type:0]);
			var vc = getPlayingVoiceTrack("",true);
			if(autoMode && checkVoiceWait())	// 自动模式计算等待时间
				addAutoWait(vc.totalTime);
		}
		_updateNextVoiceFlag();	//  更新下条语音状态
		//履历层记录
		if(historyWriteEnabled)historyLayer.record(elm);	
		if(currentWithBack){
			 current.comp.clearLayer();
			 current.comp.processText(elm);
		}
		current.clearLayer();
		current.processText(elm);	
		if(skipMode){
			if(currentWithBack) current.comp.complete();
			current.complete();	
			mainConductor.enqueueTag(%[tagname:"p"]);
			return 0;
		}
		else{
			 mainConductor.wait(%[		// 要是当前控制器是extra就太搞了
				endText :function{
					mainConductor.enqueueTag(%[tagname:"p"]);
				}incontextof this,
			]);
			return -2;
		}
	}incontextof this,

	p :function(){
		return showPageBreak();
	} incontextof this,

	ch : function(elm)// 检查完成了
	{
		// dm("the old text process way has been deprecated!");
		return 0;
    } incontextof this,
                

	r : function(elm)//检查完成
	{
		 //dm("the old text process way has been deprecated!");
		 return 0;
	} incontextof this,


	font : function(elm)
	{
		// フォント設定
		if(currentWithBack) current.comp.setFont(elm);
		current.setFont(elm);
		return 0;
	} incontextof this,

	deffont : function(elm)
	{
		// デフォルトのフォント設定
		if(currentWithBack) current.comp.setDefaultFont(elm);
		current.setDefaultFont(elm);
		return 0;
	} incontextof this,

	resetfont : function(elm)
	{
		// フォントのリセット
		if(currentWithBack) current.comp.resetFont();
		current.resetFont();
		return 0;
	} incontextof this,

	style : function(elm)
	{
		// スタイル設定
		if(currentWithBack) current.comp.setStyle(elm);
		current.setStyle(elm);
		return 0;
	} incontextof this,

	defstyle : function(elm)
	{
		// デフォルトのスタイル設定
		if(currentWithBack) current.comp.setDefaultStyle(elm);
		current.setDefaultStyle(elm);
		return 0;
	} incontextof this,

	resetstyle : function(elm)
	{
		// スタイルのリセット
		if(currentWithBack) current.comp.resetStyle();
		current.resetStyle();
		return 0;
	} incontextof this,


	button : function(elm)
	{
		// グラフィカルボタン
		if(currentWithBack) current.comp.addButton(elm);
		current.addButton(elm);
		return 0;
	} incontextof this,

	edit : function(elm)
	{
		// 単一行編集
		if(currentWithBack) current.comp.addEdit(elm);
		current.addEdit(elm);
		return 0;
	} incontextof this,

	checkbox : function(elm)
	{
		// チェックボックス
		if(currentWithBack) current.comp.addCheckBox(elm);
		current.addCheckBox(elm);
		return 0;
	} incontextof this,

	slider : function(elm)
	{
		// スライダ
		if(currentWithBack) current.comp.addSlider(elm);
		current.addSlider(elm);
		return 0;
	} incontextof this,
                  
	commit : function(elm)
	{
		// フォーム要素のコミット
		current.commit();
		return 0;
	} incontextof this,

    timeout : function(elm)
    {
        // タイムアウト処理の登録(カレントのみ)
        current.addTimeout(elm);
        return 0;
    } incontextof this,

    click : function(elm)
    {
        // クリック処理の登録(カレントのみ)
        current.addClick(elm);
        return 0;
    } incontextof this,

                  
	l : function(elm)
	{
		dm("the old text process way has been deprecated!");
		// 行クリック待ち
		// return showLineBreak(elm);
		return 0;
	} incontextof this,

	current : function(elm)
	{
		// 操作対象のメッセージレイヤの指定
		setCurrentMessageLayer(elm);
		return 0;
	} incontextof this,

	ct : function(elm)
	{
		// メッセージレイヤのリセット(すべてのメッセージレイヤのクリアと
		// current のリセット)
		clearMessageLayers(true);
		return 0;
	} incontextof this,

	cm : function(elm)//TODO 待检查
	{
		// メッセージレイヤのリセットを行うが、ct のように
		// current のリセットは行わないもの
		clearMessageLayers(false);
		return 0;
	} incontextof this,

	er : function(elm)//履历层换页 当前消息层清空
	{
		// 現在のメッセージレイヤのクリア
		if(currentWithBack) current.comp.clear(elm.all);
		current.clear(elm.all);
		return 0;
	} incontextof this,


	delay : function(elm)
	{
		// 文字表示速度の指定
		setDelay(elm);
		return 0;
	} incontextof this,

	nowait : function(elm)
	{
		// 一時的にノーウェイトで実行
		enterNoWait();
		return 0;
	} incontextof this,

	endnowait : function(elm)
	{
		// nowait の解除
		leaveNoWait();
		return 0;
	} incontextof this,

	glyph : function(elm)
	{
		// クリック待ち記号を指定
		current.setGlyph(elm);
		return 0;
	} incontextof this,

	locklink : function(elm)
	{
		// リンクのロック
		lockMessageLayerSelProcess();
		return 0;
	} incontextof this,

	unlocklink : function(elm)
	{
		// リンクのアンロック
		unlockMessageLayerSelProcess();
		return 0;
	} incontextof this,

	//----------------------------------------- タグハンドラ群(システム操作) --

	loadplugin : function(elm)
	{
		// プラグインの読み込み
		Plugins.link(elm.module);
		dm("插件已经读取 : " + elm.module);
		return 0;
	} incontextof this,

	title : function(elm)
	{
		// タイトルの設定
		setTitle(elm.name);
		return 0;
	} incontextof this,

	s : function(elm)
	{
        // 実行停止
		stablePosibility = true;
		cancelSkip();
		inSleep = true;
		notifyStable();

        // メッセージレイヤタイムアウト呼び出し開始
        current.startTimeout();

        return -1;
	} incontextof this,

	clickskip : function(elm)
	{
		// クリックスキップの設定
		clickSkipEnabled = +elm.enabled;
		return 0;
	} incontextof this,

	nextskip : function(elm)
	{
		// 次の選択肢(/未読)まで進むの設定
		nextSkipEnabled = +elm.enabled;
		onModeChange();
		return 0;
	} incontextof this,

	cancelskip : function(elm)
	{
		// スキップの解除
		cancelSkip();
        // setMenuAccessibleAll();
		return 0;
	} incontextof this,

	cancelautomode : function(elm)
	{
		// 「自動的に読み進む」の解除
		cancelAutoMode();
        // setMenuAccessibleAll();
		return 0;
	} incontextof this,

	resetwait : function(elm)
	{
		// 時間原点の設定
		resetWait();
		return 0;
	} incontextof this,

	wait : function(elm)
	{
		// ウェイト
		return doWait(elm);
	} incontextof this,

	wc : function(elm)
	{
		// 指定文字分のウェイト
		return doWaitCh(elm);
	} incontextof this,

	waitclick : function(elm)
	{
		// クリックを待つ
		return waitClick(elm);
	} incontextof this,

	rclick : function(elm)
	{
		// 右クリックの動作設定
		setRightClickOptions(elm);
		return 0;
	} incontextof this,

	history : function(elm)
	{
		// メッセージ履歴レイヤの設定
		setHistoryOptions(elm);
		return 0;
	} incontextof this,

	clearhistory : function(elm)
	{
        // メッセージ履歴レイヤの消去
        historyLayer.clear();
        historyOfStore.clear();
        return 0;
	} incontextof this,
                  
	showhistory : function(elm)
	{
		// メッセージ履歴レイヤの表示
		SystemAction.backlog();
		return -2;
	} incontextof this,

	hidemessage : function(elm)
	{
		// メッセージを一時的に隠す
		return hideMessageLayerByScenario(elm);
	} incontextof this,

	quake : function(elm)
	{
		// 揺れ
		doQuake(elm);
		return 0;
	} incontextof this,

	stopquake : function(elm)
	{
		// 揺れの停止
		stopQuake();
		return 0;
	} incontextof this,

	wq : function(elm)
	{
		// 揺れの停止を待つ
		return waitQuake(elm);
	} incontextof this,

	cursor : function(elm)
	{
		// マウスカーソルの変更
		setCursor(elm);
		return 0;
	} incontextof this,

	close : function(elm)
	{
		// ウィンドウを閉じる
		closeByScript(elm);
		return -2;
	} incontextof this,

	clearplaytime : function(elm) // 清除游玩时间，从0开始计数，每次开始剧本使用该指令
	{
        // プレイ時間のクリア
		clearPlayTime();
		return 0;
	} incontextof this,

	copybookmark : function(elm)
	{
		// 栞をコピー
		copyBookMark(+elm.from, +elm.to);
		return 0;
	} incontextof this,

	erasebookmark : function(elm)
	{
		// 栞を削除
		eraseBookMark(+elm.place);
		return 0;
	} incontextof this,

	disablestore : function(elm)
	{
		// 栞を一時的に使用不可に
		tempDisableStore(elm);
		return 0;
	} incontextof this,

	store : function(elm)
	{
		// 栞の使用不可・使用可を設定する
		setStoreEnabled(+elm.enabled);
		return 0;
	} incontextof this,

	load : function(elm)
	{
		// 栞の読み込み
		if(elm.ask !== void && +elm.ask)
			loadBookMarkWithAsk(+elm.place);
		else
			loadBookMark(+elm.place);
		return -4;
	} incontextof this,

	save : function(elm)
	{
		// 栞の読み込み
		if(elm.ask !== void && +elm.ask)
			saveBookMarkWithAsk(+elm.place);
		else
			saveBookMark(+elm.place);
		return -4;
	} incontextof this,

	startanchor : function(elm)
	{
		// 「最初に戻る」の使用不可・使用可を設定する
		setStartAnchorEnabled(elm.enabled === void || +elm.enabled);
		return 0;
	} incontextof this,

	gotostart : function(elm)
	{
		// 「最初に戻る」
		if(elm.ask !== void && +elm.ask)
			goToStartWithAsk();
		else
			goToStart();
		return -4;
	} incontextof this,

	goback : function(elm)
	{
		// 通過記録を戻る
		if(elm.ask !== void && +elm.ask)
			goBackHistory(historyOfStore.count-1,true);
		else
			goBackHistory(historyOfStore.count-1,false);
		return -4;
	} incontextof this,

	tempsave : function(elm)
	{
		// 状態のメモリへの保存
		tempSave(+elm.place);
		return 0;
	} incontextof this,

	tempload : function(elm)
	{
		// 状態のメモリへの保存
		tempLoad(+elm.place, elm);
			//elm.se === void || +elm.se, elm.bgm === void || +elm.bgm,
			//elm.backlay !== void && +elm.backlay);
		return 0;
	} incontextof this,

	mappfont : function(elm)
	{
		// レンダリング済みフォントを現在のフォントにマッピング
		mapPrerenderedFont(elm.storage);
		return 0;
	} incontextof this,

	locksnapshot : function(elm)
	{
		// 画面のスナップショットをロックする
		lockSnapshot();
		return 0;
	} incontextof this,

	unlocksnapshot : function(elm)
	{
		// 画面のスナップショットのロックを解除する
		unlockSnapshot();
		return 0;
	} incontextof this,

	//------------------------------------------- タグハンドラ群(レイヤ操作) --
	//storage 指定读入的文件名
	uiload : function(elm){
		var lay = getLayerFromElm(elm);
		if(!lay instanceof "DialogLayer")
			throw new ConductorException("only dialog layer can load ui!");

		elm.storage = elm.storage.split(",");	// 可处理多文件
		
		uiload(lay,elm);
		if(elm.visible)
			lay.visible = true;
		return 0;
	} incontextof this,

	image : function(elm)
	{
		// 画像読み込み
		updateBeforeCh = 1;
		var start = System.getTickCount();
		getLayerFromElm(elm).loadImages(elm);
		dm(elm.storage + " 's loading consume' " + (System.getTickCount() - start) + "ms。");
		return 0;
	} incontextof this,

	img : function(elm)	// image别名
	{
		return tagHandlers.image(elm);
	} incontextof this,

	/** 
	* @description: 加载立绘,代表的全名是standView
	* @return 
	*/		
	sv : function(elm){
		updateBeforeCh = 1;
		var layer = getLayerFromElm(elm);
		if(!(layer instanceof "CharacterLayer"))
			throw new ConductorException("the sv tag is only can use for CharacterLayer");
		if(!isBlank(elm.parts))
			elm.parts = elm.parts.split(",");
		layer.setStandView(elm);
		if(facemode) layer.syncFace();
		return 0;
	}incontextof this,

    clearlayers : function(elm) {
        updateBeforeCh = 1;
		var base;
		if (elm !== void && elm.page == "back") {
            base   = back;
        } else {
            base   = fore;
        }
		clearLayers(base);
		return 0;
    } incontextof this,

    syncmsg : function(elm) {
        //dm("メッセージ窓シンクロ");
        // メッセージ窓だけ表から裏にコピー
        var messages = fore.messages;
        for(var i = messages.count-1; i >= 0; i--) messages[i].assignComp();
        return 0;
    } incontextof this,
                  
	freeimage : function(elm)
	{
		// 画像のクリア
		updateBeforeCh = 1;
		getLayerFromElm(elm).freeImage(elm);
		return 0;
	} incontextof this,

	animstart : function(elm)
	{
		// アニメーションの開始
		updateBeforeCh = 1;
		getLayerFromElm(elm).startAnim(elm);
		return 0;
	} incontextof this,

	animstop : function(elm)
	{
		// アニメーションの停止
		updateBeforeCh = 1;
		getLayerFromElm(elm).stopAnim(+elm.name);
		return 0;
	} incontextof this,

	wa : function(elm)
	{
		// アニメーションの停止待ち
		return waitAnimation(elm);
	} incontextof this,

	mapimage : function(elm)
	{
		// クリッカブルマップの領域画像を読み込む
		getLayerFromElm(elm).loadProvinceImage(elm.storage);
		return 0;
	} incontextof this,

	mapaction : function(elm)
	{
		// クリッカブルマップの領域アクション定義を読み込む
		getLayerFromElm(elm).loadProvinceActions(elm.storage);
		return 0;
	} incontextof this,

	mapdisable : function(elm)
	{
		// クリッカブルマップを無効にする
		getLayerFromElm(elm).clearProvinceActions();
		return 0;
	} incontextof this,

	backlay : function(elm)
	{
		// レイヤを裏画面にコピー
		updateBeforeCh = 1;
		backupLayer(elm, true);
		return 0;
	} incontextof this,

	forelay : function(elm)
	{
		// レイヤを表画面にコピー
		updateBeforeCh = 1;
		backupLayer(elm, false);
		return 0;
	} incontextof this,

	copylay : function(elm)
	{
		// 同種のレイヤ同士のコピー
		updateBeforeCh = 1;
		copyLayer(elm);
		return 0;
	} incontextof this,

	layopt : function(elm)
	{
		// レイヤのオプションを設定
		updateBeforeCh = 1;
		var lay = getLayerFromElm(elm);
        lay.setOptions(elm);
		if(!isBlank(elm.action))
			lay[elm.action]();
		return 0;
	} incontextof this,

    laylevel : function(elm)
    {
        updateBeforeCh = 1;
        var base = (elm.page == 'back') ? back : fore;
        toLevel(elm.layer, elm.level, base);
        return 0;
	} incontextof this,

    layfront : function(elm)
    {
        updateBeforeCh = 1;
        var base = (elm.page == 'back') ? back : fore;
        toFront(elm.layer, base);
        return 0;
	} incontextof this,

    layback : function(elm)
    {
        updateBeforeCh = 1;
        var base = (elm.page == 'back') ? back : fore;
        toBack(elm.layer, base);
        return 0;
	} incontextof this,
                  
	trans : function(elm)
	{
        // トランジションの開始
        getLayerPageFromElm(elm, false).beginTransition(elm);
		return 0;
	} incontextof this,

	wt : function(elm)
	{
		// トランジションを待つ
		return waitTransition(elm);
	} incontextof this,

	stoptrans : function(elm)
	{
		
		if(isBlank(elm.layer)){
			stopAllTransitions();
			return 0;
		}
		elm.page = "fore";
		getLayerPageFromElm(elm).stopTransition();
		return 0;
	} incontextof this,

	laycount : function(elm)
	{
		updateBeforeCh = 1;
		allocateCharacterLayers(+elm.layers) if elm.layers !== void;
		allocateMessageLayers(+elm.messages) if elm.messages !== void;
		return 0;
	} incontextof this,

   /*
    action : function(elm)
    {
        updateBeforeCh = 1;
        var layer = getLayerFromElm(elm);
        if (layer instanceof "GraphicLayerEx") {
            layer.beginAction(elm);
        } else {
            dm("指定的层无法执行Action");
        }
        return 0;
    } incontextof this,

    // アクション停止
	stopaction : function(elm)
	{
        if (elm.layer !== void) {
            var layer = getLayerFromElm(elm);
            if (layer instanceof "GraphicLayerEx") {
                layer.stopAction();
            } else {
                dm("指定的层无法执行Action");
            }
        } else {
            stopAllActions();
        }
		return 0;
	} incontextof this,

	wact : function(elm)
	{
        if (elm.layer !== void) {
            // 特定レイヤのアクションを待つ
            return waitLayerAction(elm);
        } else {
            // 全レイヤのアクションを待つ
            return waitAction(elm);
        }
	} incontextof this,*/
                  
	//------------------------------ タグハンドラ群(効果音・BGM・ビデオ操作) --

	playbgm : function(elm)
	{
        // BGM の演奏
		bgm.play(elm);
        clearBgmStop();
        clearBgmLabel();
        return 0;
	} incontextof this,

	stopbgm : function(elm)
	{
		// BGM の停止
		bgm.stop();
		return 0;
	} incontextof this,

	pausebgm : function(elm)
	{
		// BGM の一時停止
		bgm.pause();
		return 0;
	} incontextof this,

	resumebgm : function(elm)
	{
		// BGM の再開
		bgm.resume();
		return 0;
	} incontextof this,

	fadeinbgm : function(elm)
	{
		// BGM のフェードイン
		bgm.fadeIn(elm);
		return 0;
	} incontextof this,

	fadeoutbgm : function(elm)
	{
		// BGM のフェードアウト
		bgm.fadeOut(elm);
		return 0;
	} incontextof this,

	fadepausebgm : function(elm)
	{
		// BGM のフェードポーズ
		bgm.fadePause(elm);
		return 0;
	} incontextof this,
                  
	fadebgm : function(elm)
	{
		// BGM の指定音量までのフェード
		bgm.fade(elm);
		return 0;
	} incontextof this,

	xchgbgm : function(elm)
	{
		// BGM の入れ替え/クロスフェード
		bgm.exchange(elm);
        clearBgmStop();
        clearBgmLabel();
		return 0;
	} incontextof this,

	bgmopt : function(elm)
	{
		// BGM のオプション設定
		bgm.setOptions(elm);
		return 0;
	} incontextof this,

    setbgmstop : function(elm)
	{
		// BGM の終了時コールバックの登録
        setBgmStop(elm);
        return 0;
	} incontextof this,

    clearbgmstop : function(elm)
	{
		// BGM の終了時コールバックの削除
        clearBgmStop();
        return 0;
	} incontextof this,

    setbgmlabel : function(elm) {
        // BGM のラベル時コールバックの登録
        setBgmLabel(elm);
        return 0;
    } incontextof this,

    clearbgmlabel : function(elm)
	{
        // BGM のラベル時コールバックの削除
        clearBgmLabel();
        return 0;
	} incontextof this,
                  
	wb : function(elm)
	{
		// BGM のフェード終了待ち
		return waitBGMFade(elm);
	} incontextof this,

	wl : function(elm)
	{
		// BGM の再生終了待ち
		return waitBGMStop(elm);
	} incontextof this,

	playse : function(elm)
	{
		// 効果音の再生
		se[+elm.buf].play(elm);
		return 0;
	} incontextof this,

	stopse : function(elm)
	{
		// 効果音の停止
		se[+elm.buf].stop();
		return 0;
	} incontextof this,

	fadeinse : function(elm)
	{
		// 効果音のフェードイン再生
		se[+elm.buf].fadeIn(elm);
		return 0;
	} incontextof this,

	fadeoutse : function(elm)
	{
		// 効果音のフェードアウト
		se[+elm.buf].fadeOut(elm);
		return 0;
	} incontextof this,

	fadese : function(elm)
	{
		// 効果音のフェード
		se[+elm.buf].fade(elm);
		return 0;
	} incontextof this,

	seopt : function(elm)
	{
		// 効果音のフェード
		se[+elm.buf].setOptions(elm);
		return 0;
	} incontextof this,

	wf : function(elm)
	{
		// 効果音のフェード終了待ち
		return waitSEFade(elm);
	} incontextof this,

	ws : function(elm)
	{
		// 効果音の再生終了待ち
		return waitSEStop(elm);
	} incontextof this,

	// -----------------------------------------------------
    playvoice : function(elm) {
		// ボイス直接再生指定
		var mode = elm.mode !== void ? +elm.mode : true;
		var type = +elm.type;
		var loop = +elm.loop;
		var pan = +elm.pan;
		var noflip = +elm.noflip;
		var fade = elm.volume !== void ? +elm.volume : elm.fade !== void ? +elm.fade : 100;
		if (!skipMode || type != 0) {
			if (elm.name !== void) {
				var name = elm.name.toLowerCase();
				var voice = elm.voice;
				if (loop) {	// 循环语音(例如hs喘息)的方式
					// 新規ループボイス指定
					var voiceBuffer = getPlayingVoiceTrack(name, true);
					if (voiceBuffer !== void && voiceBuffer.type != 0) {
						stopVoice(name, voice, true);
					}
					loopVoiceInfo.start(%[name:name, voice:Scripts.clone(voice), type:type, noflip:noflip, pan:pan, fade:fade]);
					loopVoiceTrigger.trigger();
				} else {
					// stopVoice(name);
					stopAllVoice();
					playVoice(name, getPlayVoiceFilename(name, voice), pan, type, false, mode, noflip, fade);
				}
			}
		}
		if(isBlank(elm.wait))return 0;
		else return waitVoice(elm);	//自动等待语音结束
	} incontextof this,

	stopvoice : function(elm) {
		// ボイスの停止
		stopVoice(elm.name, elm.time, elm.all);
		return 0;
	} incontextof this,

	fadevoice : function(elm) {
		// ボイスの音量調整
		var fade = elm.volume !== void ? +elm.volume : elm.fade !== void ? +elm.fade : 100;
		fadeVoice(elm.name, fade, elm.time);
		return 0;
	} incontextof this,

    waitvoice : function(elm) {
		// ボイス再生待ち
		if(isBlank(elm.wait))elm.wait = 0;
		return elm.name !== void ? waitVoice(elm) : waitAllVoice(elm);
	} incontextof this,

	video : function(elm)
	{
		// ムービーのオプションを設定する
		movies[+elm.slot].setOptions(elm);
		return 0;
	} incontextof this,

	playvideo : function(elm)
	{
		// ムービーを再生する
		movies[+elm.slot].play(elm.storage);
		return 0;
	} incontextof this,

	stopvideo : function(elm)
	{
		// ムービーを停止する
		movies[+elm.slot].stop();
		return 0;
	} incontextof this,

	openvideo : function(elm)
	{
		// ムービー再生の準備をする
		movies[+elm.slot].open(elm.storage);
		return 0;
	} incontextof this,

	wv : function(elm)
	{
		// ムービーの再生終了を待つ
		return waitMovieStop(elm);
	} incontextof this,

// Start: Add: T.Imoto
	wp : function(elm)
	{
		// ムービーのピリオドイベントを待つ
		return waitMoviePeriod(elm);
	} incontextof this,

	pausevideo : function(elm)
	{
		movies[+elm.slot].pause();
		return 0;
	} incontextof this,

	resumevideo : function(elm)
	{
		movies[+elm.slot].resume();
		return 0;
	} incontextof this,

	preparevideo : function(elm)
	{
		movies[+elm.slot].prepare();
		return 0;
	} incontextof this,

	rewindvideo : function(elm)
	{
		movies[+elm.slot].rewind();
		return 0;
	} incontextof this,

	videolayer : function(elm)
	{
		movies[+elm.slot].storeLayer( elm.layer, elm.page, elm.channel );
		movies[+elm.slot].setVideoLayer(getLayerFromElm(elm),elm);
		return 0;
	} incontextof this,

	clearvideolayer : function(elm)
	{
		movies[+elm.slot].cancelLayer( elm.channel );
		movies[+elm.slot].setVideoLayer(null,elm);
		return 0;
	} incontextof this,

	videosegloop : function(elm)
	{
		movies[+elm.slot].setSegment(elm);
		return 0;
	} incontextof this,

	cancelvideosegloop : function(elm)
	{
		movies[+elm.slot].cancelSegmentLoop();
		return 0;
	} incontextof this,

	videoevent : function(elm)
	{
		movies[+elm.slot].setPeriod(elm);
		return 0;
	} incontextof this,

	cancelvideoevent : function(elm)
	{
		movies[+elm.slot].cancelPeriodEvent();
		return 0;
	} incontextof this,
// End: Add: T.Imoto

	//--------------------------------------- タグハンドラ群(変数・TJS 操作) --
	ask : function(elm){
		var yesFunc = function(elm){kag.process(elm.ystorage,elm.ytarget);};
		var noFunc = function(elm){kag.process(elm.nstorage,elm.ntarget);};
		askYesNo(elm.name,elm.title,yesFunc,noFunc,elm);
		return 0;
	}  incontextof this,
	eval : function(elm)
	{
		// 式の評価
		Scripts.eval(elm.exp);
		return 0;
	} incontextof this,

	trace : function(elm)
	{
		// 式のトレース表示
		var exp = elm.exp;
		var result = Scripts.eval(exp);
		dm("▼[trace] expression=\"" + exp + "\" type of result=" + typeof result + 
			" result=" + result);
		return 0;
	} incontextof this,

	input : function(elm)
	{
		// 文字列の入力
		inputString(elm);
		return 0;
	} incontextof this,

	clearsysvar : function(elm)
	{
		// システム変数のクリア
		clearSystemVariables();
		return 0;
	} incontextof this,

	clearvar : function(elm)
	{
		// ゲーム変数のクリア
		clearVariables();
		return 0;
	} incontextof this,

	waittrig : function(elm)
	{
		// トリガを待つ
		return waitTrigger(elm);
	} incontextof this,

	//----------------------------------------- タグハンドラ群(選択肢) --

    seladd : function(elm)
    {
        addSelect(elm);
        return 0;
	} incontextof this,

    select : function(elm)
    {
        if (selectLayer.msgoff && setCurrentMessageLayerVisible(false)) {
            // 処理待ち
            return -3;
        }


        if (skipMode == 1 || skipMode == 2) cancelSkip();
        if (skipMode == 4 && !skipKeyPressing()) cancelSkip();
        
        stablePosibility = true;
        notifyStable();
        
        selectPrevSkipMode = skipMode;
        selectPrevAutoMode = autoMode;

        showSelect();

        conductor.sleep();
        conductor.interrupt();
		onModeChange();
        // setMenuAccessibleAll();
        return -1;
	} incontextof this,

	selopt : function(elm)
	{
		setSelectOptions(elm);
		return 0;
	} incontextof this,

	//----------------------------------------- タグハンドラ群(選択肢) --

    mselinit : function(elm)
    {
        initMapSelect();
        return 0;
	} incontextof this,

    mselbutton : function(elm)
    {
        addMapSelectButton(elm);
        return 0;
	} incontextof this,

    mselpos : function(elm)
    {
        addMapSelectPosition(elm);
        return 0;
	} incontextof this,

    mseladd : function(elm)
    {
        addMapSelect(elm);
        return 0;
	} incontextof this,

    mselect : function(elm)
    {
        if (mapSelectLayer.msgoff && setCurrentMessageLayerVisible(false)) {
            // 処理待ち
            return -3;
        }

        if (skipMode == 1 || skipMode == 2) cancelSkip();
        if (skipMode == 4 && !skipKeyPressing()) cancelSkip();
        if (!afterauto) cancelAutoMode();
        if (!afterskip) cancelSkip();

        stablePosibility = true;
        notifyStable();
        
        selectPrevSkipMode = skipMode;
        selectPrevAutoMode = autoMode;

        showMapSelect();

        conductor.sleep();
        conductor.interrupt();
		onModeChange();
		// setMenuAccessibleAll();
        return -1;
	} incontextof this,

	mselopt : function(elm)
	{
        setMapSelectOptions(elm);
		return 0;
	} incontextof this,
                  
	//----------------------------------------- タグハンドラ群(特殊スキップ処理) --

    beginskip : function(elm)
	{
        // 現在のスキップモードを記録
        if (prevSkipMode !== void) {
            throw new Exception("beginskip can't be nested!!!");
        } else {
            prevSkipMode = skipMode;
            if (skipMode) {
                // 既にスキップしてた場合は停止できないスキップ状態にする
                skipMode = 5;
            }
        }
        return 0;
	} incontextof this,

    endskip : function(elm)
	{
        if (prevSkipMode == 0) {
            cancelSkip();
        } else {
            skipMode = prevSkipMode;
        }
        prevSkipMode = void;
        return 0;
	} incontextof this,

	//----------------------------------------------- 回想モード --

    recollection : function(elm)
	{
        startRecollection(elm);
        return 0;
	} incontextof this,

    stoprecollection : function(elm)
    {
        stopRecollection(elm);
        return 0;
    } incontextof this,
                  
    endrecollection : function(elm)
	{
        return endRecollection();
	} incontextof this,
                  
	//----------------------------------------------- タグハンドラ群の終わり --

		interrupt : function(elm) { return -2; } incontextof this ];
	}

	//------------------------------------------------------ 特殊変数処理 --
    // システム画面用に簡易参照できるメソッド・プロパティを追加

	// サウンド関連の設定読み出し／変更
	function getSoundProperty(tag, prop, defval) {
		var table = scflags[tag];
		return (table !== void && table[prop] !== void) ? table[prop] : defval;
	}
	function setSoundProperty(tag, prop, value) {
		var table = scflags[tag];
		if (table === void) table = scflags[tag] = %[];
		table[prop] = value;
		callHook("onSoundPropertyChanged", tag, prop, value);
	}

	/**
	 * BGM 有効値の設定
	 * true / false
	 */
	property bgmenable {
		getter()  { return getSoundProperty("bgm", "enable", true); }
		setter(v) {        
			setSoundProperty("bgm", "enable", !!v);
			bgm.restoreSystemState(scflags); 
			callHook('onBgmVolumeChange'); 
		}
	}

	/**
	 * BGM ボリューム値の設定
	 * 100段階指定
	 */
	property bgmvolume {
		getter()  { return getSoundProperty("bgm", "globalVolume", 100000) / 1000; }
		setter(v) {
			setSoundProperty("bgm", "globalVolume",      v  * 1000);
			bgm.restoreSystemState(scflags); 
			callHook('onBgmVolumeChange');
		}
	}

	// 下げ制御用プロパティ
	var _bgmdownvalue = 1.0;
	property bgmdownvalue  {
		getter() { return _bgmdownvalue; }
		setter(v) {
			if (v != _bgmdownvalue) {
				_bgmdownvalue = v;
				bgm.restoreSystemState(scflags); 
				callHook('onBgmVolumeChange');
			}
		}
	}
	/**
	 * BGM 有効値の設定
	 * true / false
	 */
	property seenable {
		getter()  { return getSEGroupProperty("enable", true); }
		setter(v) {        
			setSEGroupProperty("enable", !!v);
		 	callHook('onSEVolumeChange'); }
	}

	/**
	 * SE ボリューム値の設定
	 * 100段階設定
	 */
	property sevolume {
		getter()  { return getSEGroupProperty("globalVolume", 100000) / 1000;  }
		setter(v) {        
			setSEGroupProperty("globalVolume",       v * 1000); 
			callHook('onSEVolumeChange');
		}
	}

    /**
     * BGM 有効値の設定
     * true / false
     */
    property seenable {
        getter() {
            if (scflags.se !== void && scflags.se[0] !== void && scflags.se[0].enable !== void) {
                return scflags.se[0].enable;
            }
            return true;
        }
        setter(v) {
            if (scflags.se === void) {
                scflags.se = %[];
            }
            for(var i = 0; i<numSEBuffers+1; i++) {
                if (scflags.se[i] === void) {
                    scflags.se[i] = %[];
                }
                scflags.se[i].enable = v;
                se[i].restoreSystemState(scflags);
            }
        }
    }
    
    /**
     * SE ボリューム値の設定
     * 100段階設定
     */
    property sevolume {
        getter() {
            if (scflags.se !== void && scflags.se[0] !== void) {
                return scflags.se[0].globalVolume / 1000;
            }
            return 100;
        }
        setter(v) {
            if (scflags.se === void) {
                scflags.se = %[];
            }
            for(var i = 0; i<numSEBuffers+1; i++) {
                if (scflags.se[i] === void) {
                    scflags.se[i] = %[];
                }
                scflags.se[i].globalVolume = v * 1000;
                se[i].restoreSystemState(scflags);
            }
        }
    }

	/**
	 * ボイス有効値の設定
	 * true / false
	 */
	property voiceenable {
		getter()  { return getSoundProperty("voice", "enable", true); }
		setter(v) {        
			setSoundProperty("voice", "enable", !!v); 
			resetAllVoiceVolume(); 
		}
	}

	property voicepan {
		getter()  { return getSoundProperty("voice", "panenable", true); }
		setter(v) {        
			setSoundProperty("voice", "panenable", !!v); 
		}
	}
	
	/**
	 * ボイスの代表ボリューム
	 * 100段階設定
	 */
	property voicevolume {
		getter()  { return getSoundProperty("voice", "globalVolume", 100000) / 1000; }
		setter(v) {        
			setSoundProperty("voice", "globalVolume",      v  * 1000); 
			resetAllVoiceVolume(); 
		}
	}

	/**
     * ボイスの再生倍速
     */
    property voicespeed {
		getter() {
			if (scflags.voicespeed === void) {
                return 1.0;
            }
            return scflags.voicespeed;
        }
        setter(v) {
			if (scflags.voicespeed != v) {
				scflags.voicespeed = v;
				resetAllVoiceSpeed();
				// updateVoiceSpeedMenu(v); // todo 菜单更新
			}
        }
    }

	// {get/set}Voice{On/Volume} で渡されるnameを正規化
	function _voiceNameFilter(name) {
		@if (DEBUG)
			// scflags.voice を使いまわすので下記の名前が競合する（まず使わないだろうけど）
			if (name == "enable" || name == "globalVolume")
				dm("{get/set}Voice{On/Volume}: the using voice namehas been occupied");
		@endif
		return (name != "") ? name : "etc";
	}

	/**
	 * 指定された名前のキャラのボイスが有効かどうか
	 */
	function getVoiceOn(name) {
		return getSoundProperty("voiceon", _voiceNameFilter(name), true);
	}

	/**
	 * 指定された名前のキャラのボイスを有効にする
	 */
	function setVoiceOn(name, on=true) {
		setSoundProperty("voiceon", _voiceNameFilter(name), !!on);
		resetAllVoiceVolume();
	}

	/**
	 * 指定された名前のキャラのボイスの音量を取得する
	 * @param name キャラ名
	 * @param rawvalue trueならvoicevolumeの補正をしない
	 */
	function getVoiceVolume(name, rawvalue = false) {
		var vol = getSoundProperty("voice", _voiceNameFilter(name), 100000) / 1000;
		return rawvalue ? vol : (vol * voicevolume / 100);
	}

	/**
	 * 指定された名前のキャラのボイスの音量を変更する
	 */
	function setVoiceVolume(name, vol) {
		setSoundProperty("voice", _voiceNameFilter(name), vol * 1000);
		callHook('onVoiceVolumeUpdate');
		resetAllVoiceVolume();
	}
	/**
	 * 特殊的循环音效
	 */
	property bgvenable {
		getter()  { return getSoundProperty("bgv", "enable", true); }
		setter(v) { 
			setSoundProperty("bgv", "enable", !!v);
			resetAllVoiceVolume();
		}
	}
	property bgv2enable {
		getter()  { return getSoundProperty("bgv2", "enable", true); }
		setter(v) {
			setSoundProperty("bgv2", "enable", !!v);
			resetAllVoiceVolume();
		}
	}
	/**
	 * BGVの代表ボリューム
	 * 100段階設定
	 */
	property bgvvolume {
		getter()  { return getSoundProperty("bgv", "globalVolume", 100000) / 1000;  }
		setter(v) {        setSoundProperty("bgv", "globalVolume",      v  * 1000); resetAllVoiceVolume(); }
	}
	property bgv2volume {
		getter()  { return getSoundProperty("bgv2", "globalVolume", 100000) / 1000;  }
		setter(v) {        setSoundProperty("bgv2", "globalVolume",      v  * 1000); resetAllVoiceVolume(); }
	}

	/**
	 * 指定された名前のキャラのループボイスの音量を取得
	 */
	function getBGVVolume (name) { return bgvvolume  * getVoiceVolume(name, true) / 100; }
	function getBGV2Volume(name) { return bgv2volume * getVoiceVolume(name, true) / 100; }

	/**
     * テキスト速度制御
     * 0～_textSpeedMax で指定 (_textSpeedMaxが最速)
     */
	var _textSpeedMax = 10;
    property textspeed {
        getter() {
			var max = _textSpeedMax;
            return max - (userChSpeed / (chSpeeds.slow / max));
        }
        setter(v) {
			var max = _textSpeedMax;
            userChSpeed = (max - v) * (chSpeeds.slow / max);
			callHook("onTextSpeedChanged", textspeed);// todo 这些放到menu中去
            /*if (userChSpeed <= chSpeeds.fast) {
                if (typeof this.chFastMenuItem != "undefined") {
                    this.chFastMenuItem.checked = true;
                }
            } else if (userChSpeed <= chSpeeds.normal) {
                if (typeof this.chNormalMenuItem != "undefined") {
                    this.chNormalMenuItem.checked = true;
                }
            } else {
				if (typeof this.chSlowMenuItem != "undefined") {
                    this.chSlowMenuItem.checked = true;
                }
            }*/
        }
    }

	var _autoSpeedMax = 10;
    property autospeed {
        getter() {
			var max = _autoSpeedMax;
            return max - (autoModePageWait / (autoModePageWaits.slow / max));
        }
        setter(v) {
			var max = _autoSpeedMax;
            autoModePageWait = (int)((max - v) * (autoModePageWaits.slow / max));
            autoModeLineWait = (int)((max - v) * (autoModeLineWaits.slow / max));
			callHook("onAutoSpeedChanged", autospeed);//todo 这些放到menus中去
            /*if (autoModePageWait <= autoModePageWaits.fast) {
                if (typeof this.autoModeFastMenuItem != "undefined") {
                    this.autoModeFastMenuItem.checked = true;
                }
            } else if (autoModePageWait <= autoModePageWaits.faster) {
                if (typeof this.autoModeFasterMenuItem != "undefined") {
                    this.autoModeFasterMenuItem.checked = true;
                }
            } else if (autoModePageWait <= autoModePageWaits.medium) {
                if (typeof this.autoModeMediumMenuItem != "undefined") {
                    this.autoModeMediumMenuItem.checked = true;
                }
            } else if (autoModePageWait <= autoModePageWaits.slower) {
                if (typeof this.autoModeSlowerMenuItem != "undefined") {
                    this.autoModeSlowerMenuItem.checked = true;
                }
            } else {
                if (typeof this.autoModeSlowMenuItem != "undefined") {
                    this.autoModeSlowMenuItem.checked = true;
                }
            }*/
        }
    }

    /**
     * 描画速度 (トランジションの再生倍率を指定する）
     */
    property drawspeed {
		getter() {
			if (skipNoDispOrFast || noeffect) {
				return 0;
			} 
			return isBlank(scflags.drawspeed)?1.0:scflags.drawspeed;
		}
		setter(v) {
            scflags.drawspeed = v;
        }
        
    }
    
	function updateEffectButton() {
		forEachEventHook('onUpdateEffect');
	}


    /**
     * エフェクトの有効・無効（トランジション補正と連動）
     */
    /*property noeffect {
        getter() {
            if (scflags.drawspeed === void) {
                return false;
            }
            return scflags.drawspeed == 0;
        }
        setter(v) {
            if (v) {
                scflags.drawspeed = 0;
            } else {
                delete scflags.drawspeed;
            }
        }
    }*/

	 property noeffect {
        getter() {
			if (scflags.noeffect === void) {
				return false;
			}
			return scflags.noeffect;
        }
        setter(v) {
			scflags.noeffect = v;
			//updateEffectButton();	// todo 加上hook
		}
    }


@if (SOUNDGAIN_ENABLED)
	// -------------------------------------------------------------
	// ゲイン補正用
	// -------------------------------------------------------------

	var _soundGainSetup = 0; //< サウンドゲインコールバック初期化済みフラグ
	var _soundGainInfo = %[]; //< ファイルに対するゲイン	文件名-数组 的键值对  数组0号位是文件的数量，1号位是文件名
	var _soundGainConfig = %[]; //< 識別IDに対するゲイン

	function setupSoundGain() {
		if (!_soundGainSetup) {
			var query = this.querySoundGain,  r = 0;
			var wsb = WaveSoundBuffer, method = "setGainQueryCallback";
			if (typeof wsb[method       ] == "Object") { wsb[method       ](query); r |= 1; } // for wuvorbis.dll
			if (typeof wsb[method+"OPUS"] == "Object") { wsb[method+"OPUS"](query); r |= 2; } // for wuopus.dll
			if (r)  _soundGainSetup = r;
			else {
				_soundGainSetup = -1; // disable soundgain (normal wuvorbis)
				dm("SOUNDGAIN_ENABLED is on but wuvorbis/opus.dll is not fitable version");
			}
		}
		if (_soundGainSetup > 0) {
			loadSoundGainInfo();
			loadFileGainInfo();
		}
	}

	// 名前の正規化
	function normalizeSoundGainName(file) {
		with (Storages) return .chopStorageExt(.extractStorageName(((string)file).toLowerCase())); // 名前を正規化
	}

	// モジュールからの問いあわせ
	function querySoundGain(url) {
		try {
			var name = normalizeSoundGainName(url);
			if (name != "") {
				var info = _soundGainInfo[name];
				if (info !== void) {
					//dm(@"gain query:${name} gain:${info[1]}");
					return info[1];
				}
			}
			return 0.0;
		} catch(e) {
			Debug.notice(e.message);
		}
	}

	/**
	 * ゲイン情報のコンフィグの読み込み
	 */
	function loadSoundGainInfo(filename="soundgain.csv") {
		(Dictionary.clear incontextof _soundGainConfig)();
		_loadSoundGainFile(filename, function (line, count, num) {
			var name = line[0];
			if (count >= 2 && name != "") {
				_soundGainConfig[name] = +line[1];
				//dm(@"ゲイン情報登録:${name}:${line[1]}");
			}
		} incontextof this);
	}
	function loadFileGainInfo(filename="filegain.csv") {
		_loadSoundGainFile(filename, function (line, count, num) {
			var name = line[0];
			if (count >= 2 && name != "") {
				// 複数回よまれるとカウント上書きで消えなくなるがそれはそれでOK
				addFileSoundGain(name, +line[1], true);
			}
		} incontextof this);
	}
	function _loadSoundGainFile(filename, callback) {
		if (Storages.isExistentStorage(filename)) {
			var temp = [];
			var sep = (Storages.extractStorageExt(filename).toLowerCase() == ".txt") ? "\t" : ",";
			temp.load(filename);
			for (var i = 0; i < temp.count; i++) {
				var line = [];
				line.split(sep, temp[i]);
				callback(line, line.count, i) if (((string)line[0]).charAt(0) != "#");
			}
		}
	}

	/**
	 * 指定のファイルのゲイン情報を登録
	 * @param filename ファイル名
	 * @param gain ゲイン値またはサウンドコンフィグ名
	 * @param override 上書き指定
	 */
	function addFileSoundGain(filename, gain=0, override = false) {
		var name = normalizeSoundGainName(filename);
		if (name == "") return;
		gain = _soundGainConfig[gain] if (typeof gain == "String" && gain != "");
		gain = +gain;
		var info = _soundGainInfo[name];
		if (info === void) {
			_soundGainInfo[name] = [1,gain];
			//dm(@"ファイルゲイン登録:${name}:${gain}");
		} else {
			// カウントだけあげる。override指定がなければ初期状態の調整はいじらない
			info[0]++;
			info[1] = gain if (override);
		}
	}

	/**
	 * 指定のファイルのゲイン情報を削除
	 * @param filename ファイル名
	 */
	function removeFileSoundGain(filename) {
		var name = normalizeSoundGainName(filename);
		if (name == "") return;
		var info = _soundGainInfo[name];
		if (info !== void) {
			if (--info[0] == 0) {
				delete _soundGainInfo[name];
				//dm(@"ファイルゲイン削除:${name}");
			}
		}
	}
	// alias
	function removeVoiceGain(filename) { return removeFileSoundGain(...); }

	function addVoiceGain(filename, name) {
		if (name == "" || filename == "") return;
		if (_soundGainConfig[name] === void) {
			/*
			var info = characterVoiceInfo[name];
			if (info !== void) {
				name = info.config;
			}
			 */
		}
		addFileSoundGain(filename, name);
	}

@endif
}

